<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CAN通信学习</title>
    <url>/2025/06/12/CAN%E9%80%9A%E4%BF%A1%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="can通信笔记"><a class="markdownIt-Anchor" href="#can通信笔记"></a> CAN通信笔记</h1>
<p>CAN（Controller Area Network Bus），控制局域网总线。</p>
<h2 id="基本特征"><a class="markdownIt-Anchor" href="#基本特征"></a> 基本特征</h2>
<ul>
<li>
<p>两根通信线（CAN_H、CAN_L），<strong>无需共地</strong></p>
</li>
<li>
<p><strong>差分信号</strong>通信，抗干扰能力强</p>
</li>
<li>
<p>高速CAN（ISO11898）：125k~1Mbps，&lt;40m</p>
</li>
<li>
<p>低速CAN（ISO11519）：10k~125kbps，&lt;1km</p>
</li>
<li>
<p><strong>异步</strong>，无需时钟线，通信速率由双方协定</p>
</li>
<li>
<p><strong>半双工</strong>，可挂载多设备，<strong>多设备同时发送通过仲裁判断先后</strong></p>
</li>
<li>
<p><strong>11/29位报文ID</strong>，用于区分消息功能，同时决定优先级**（小的优先）**</p>
</li>
<li>
<p>可配置<strong>1~8字节的有效载荷</strong></p>
</li>
<li>
<p>可实现<strong>广播式和请求式</strong>两种传输</p>
</li>
<li>
<p>应答、CRC校验、位填充、位同步、错误处理等特性</p>
</li>
</ul>
<h2 id="硬件电路"><a class="markdownIt-Anchor" href="#硬件电路"></a> 硬件电路</h2>
<p><img src="https://s2.loli.net/2025/07/24/FydOPNIJWvxrp94.png" alt="" /></p>
<h3 id="两个终端电阻的意义"><a class="markdownIt-Anchor" href="#两个终端电阻的意义"></a> 两个终端电阻的意义</h3>
<ol>
<li>
<p><strong>防止回波反射</strong></p>
</li>
<li>
<p><strong>没有设备操作时</strong>，将两根差分线电压“收紧”，<strong>使其电压一致</strong></p>
</li>
</ol>
<p>（高速CAN的电阻阻值小，所以收紧更快，但能耗更大）</p>
<h3 id="电平标准"><a class="markdownIt-Anchor" href="#电平标准"></a> 电平标准</h3>
<p>CAN总线使用<strong>差分信号</strong>,即（<strong>Vcan_H - Vcan_L</strong>）</p>
<ul>
<li><strong>高速CAN</strong>规定</li>
</ul>
<p>电压差为0V表示逻辑1（隐性电平）</p>
<p>电压差为2V表示逻辑0（显性电平）</p>
<ul>
<li><strong>低速CAN</strong>规定</li>
</ul>
<p>电压差为-1.5V表示逻辑1（隐性电平）</p>
<p>电压差为3V表示逻辑0（显性电平）</p>
<h2 id="帧格式"><a class="markdownIt-Anchor" href="#帧格式"></a> 帧格式</h2>
<table>
<thead>
<tr>
<th style="text-align:center">帧类型</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">数据帧</td>
<td style="text-align:center">发送设备主动发送数据</td>
</tr>
<tr>
<td style="text-align:center">遥控帧</td>
<td style="text-align:center">接收设备主动请求数据</td>
</tr>
<tr>
<td style="text-align:center">错误帧</td>
<td style="text-align:center">某个设备检测出错误时向其他设备通知错误</td>
</tr>
<tr>
<td style="text-align:center">过载帧</td>
<td style="text-align:center">接收设备通知其尚未做好接收准备</td>
</tr>
<tr>
<td style="text-align:center">帧间隔</td>
<td style="text-align:center">用于将数据帧及遥控帧与前面的帧分隔开</td>
</tr>
</tbody>
</table>
<h3 id="数据帧"><a class="markdownIt-Anchor" href="#数据帧"></a> 数据帧</h3>
<p><img src="https://s2.loli.net/2025/07/24/NIBvbY56zMZ3LQx.png" alt="" /></p>
<p>SOF（Start of Frame）：帧起始，表示后面一段波形是传输的数据位</p>
<p>ID（Identify）：标识符，区分功能，决定优先级</p>
<p>RTR（Remote Transmission Request）：数据帧（0），遥控帧（1）。</p>
<p>IDE（Identifier Extension）：用于区分标准格式（0）和扩展格式（1）</p>
<p>r0/r1（Reserve）：保留位，为后续留空间</p>
<p>DLC（Data Length Code）：数据长度</p>
<p>ACK槽，发送方（1），接收方（0），如果没有接收方就（1），告知发送方</p>
<p><strong>ACK槽允许多个接收方共同拉开总线</strong></p>
<p><strong>SRR</strong>：替代RTR的位，用于<strong>保证标准格式高于扩展格式的优先级</strong></p>
<p>EOF（End of Frame）：帧结束，表示传输完毕</p>
<h3 id="遥控帧"><a class="markdownIt-Anchor" href="#遥控帧"></a> 遥控帧</h3>
<p><strong>遥控帧无数据段，RTR为隐形电平1</strong>，其他部分与数据帧相同</p>
<p><img src="https://s2.loli.net/2025/07/24/ivsZVrE8J4Tb5FU.png" alt="" /></p>
<h3 id="错误帧"><a class="markdownIt-Anchor" href="#错误帧"></a> 错误帧</h3>
<p>总线上所有设备都会监督总线数据，一旦发现“位错误”、“填充错误”、“CRC错误”、“格式错误”、“应答错误”，<strong>这些设备就会发出错误帧来破坏数据，同时终止当前的发送设备</strong>。</p>
<p><img src="https://s2.loli.net/2025/07/24/ywMD7HjAbCeGX3B.png" alt="" /></p>
<ul>
<li>主动错误会破坏别人的，被动错误会破坏自己的</li>
</ul>
<h3 id="过载帧"><a class="markdownIt-Anchor" href="#过载帧"></a> 过载帧</h3>
<p>接收方收到大量数据而无法处理时，其可以发出过载帧，延缓发送方的数据发送，以平衡总线负担，避免数据丢失。</p>
<p><img src="https://s2.loli.net/2025/07/24/4RGkZDB1efXtS5U.png" alt="" /></p>
<h3 id="帧间隔"><a class="markdownIt-Anchor" href="#帧间隔"></a> 帧间隔</h3>
<p>将数据帧和远程帧与前面的帧分离开</p>
<p><img src="https://s2.loli.net/2025/07/24/Au6SR5a4dLzi2br.png" alt="" /></p>
<h3 id="位填充"><a class="markdownIt-Anchor" href="#位填充"></a> 位填充</h3>
<p><strong>规则</strong>：发送方<strong>连续发送5个相同电平</strong>后，自动<strong>追加一个相反电平</strong>的填充位；<strong>接收方</strong>检测到填充位时，<strong>会自动移除</strong>，恢复原始数据。</p>
<p>例如：<br />
即时发送： 100000110       10000011110</p>
<p>实际发送： 1000001110     1000001111100</p>
<p>实际接收： 1000001110     1000001111100</p>
<p>移除填充： 100000110       10000011110</p>
<p><strong>位填充的作用</strong>：</p>
<ul>
<li>增加波形的定位信息，利于接收方执行“再同步”，防止波形长时间无变化，当只接收方不能精准掌握数据采样时机</li>
<li>将正常数据流与“错误帧”、“过载帧”区分开</li>
<li>保持CAN总线在发送正常数据流时的活跃状态，防止被总线误认为空闲</li>
</ul>
<h2 id="位同步"><a class="markdownIt-Anchor" href="#位同步"></a> 位同步</h2>
<ul>
<li>
<p>CAN总线没有时钟线，总线上所有设备通过<strong>约定波特率</strong>来<strong>确定每一位数据位时长</strong></p>
</li>
<li>
<p>发送方以约定的位时长每隔固定时间输出一个数据位</p>
</li>
<li>
<p>接收方以约定的位时长每个固定时间采样总线的电平，输入一个数据位</p>
</li>
<li>
<p>理想状态下，接收方能依次采样到发送方发出的每个数据位，且采样点位于数据位中心附近</p>
</li>
</ul>
<h3 id="位时序"><a class="markdownIt-Anchor" href="#位时序"></a> 位时序</h3>
<p>为了能够灵活调整每个采样点的位置，使采样点对齐数据位中心附近，<strong>CAN总线对每一个数据位的时长进行更细划分</strong>，分为同步段（SS）、传播时间段（PTS）、相位缓冲段1（PBS1）和相位缓冲段2（PBS2），每隔段由若干个最小时间单位（Tq）构成</p>
<ul>
<li>SS = 1Tq</li>
<li>PTS = 1 ~ 8 Tq</li>
<li>PBS1 = 1 ~ 8 Tq</li>
<li>PBS2 = 2 ~ 8 Tq</li>
</ul>
<p><img src="https://s2.loli.net/2025/07/24/ntCflEzV3guBori.png" alt="" /></p>
<p><strong>最开始就没有同步时序</strong>。</p>
<h3 id="硬同步初始位置同步"><a class="markdownIt-Anchor" href="#硬同步初始位置同步"></a> 硬同步(初始位置同步)</h3>
<p>每个设备都有一个位时序计时周期，当某个设备（发送方）率先发送报文，其他所有设备（接收方）收到SOF的下降沿时，接收方会将自己的位时序计时周期拨到SS段，与发送方的位时序计时周期保持同步；</p>
<p><strong>硬同步只在第一个下降沿（SOF下降沿）有效</strong>；</p>
<p>经过硬同步后，若发送方和接收方的时钟没有误差，则后续所有数据位的采样点必须都会对齐数据位中心附近</p>
<p><img src="https://s2.loli.net/2025/07/24/lwtY9Hd21jNs7Zz.png" alt="" /></p>
<p><strong>最开始接收采样正确，但始终有误差，随着误差积累，采样点逐渐偏离。</strong></p>
<h3 id="再同步"><a class="markdownIt-Anchor" href="#再同步"></a> 再同步</h3>
<ul>
<li>若发送方或接收方的时钟有误差，随着误差积累，数据位边沿逐渐偏离SS段，则此时接收方根据再同步补偿宽度（SJW）通过<strong>加长PBS1段，或缩短PBS2段</strong>，调整同步</li>
<li>再同步可以发生在每一个下降沿之后的每个数据位跳变边沿</li>
</ul>
<p>SJW = 1 ~ 4 Tq</p>
<p><strong>如果误差值小于等于SJW指定值，则误差几个Tq，补偿几个Tq，否则补偿SJW</strong></p>
<p>SJW是补偿的上限，防止波形中的噪声对位时序造成过大影响。</p>
<p><img src="https://s2.loli.net/2025/07/24/jDnNcMzGxSUtuOK.png" alt="" /></p>
<h3 id="波特率的计算"><a class="markdownIt-Anchor" href="#波特率的计算"></a> 波特率的计算</h3>
<p>波特率 = 1 / (一个数据位的时长) = 1 / (Tss + Tpts + Tpbs1 + Tpbs2)</p>
<p>举例</p>
<p>SS = 1 Tq，PTS = 3 Tq，PBS1 = 3 Tq，PBS2 = 3 Tq；Tq = 0.5 us</p>
<p>波特率 = 1 / (0.5us + 1.5us + 1.5us + 1.5us) = 200kbps</p>
<h2 id="仲裁"><a class="markdownIt-Anchor" href="#仲裁"></a> 仲裁</h2>
<p>CAN总线只有一对差分信号线，同一时间只能有一个设备操作总线发送数据，<strong>如果多个设备同时有发送需求，该如何分配？</strong></p>
<h3 id="规则1先占先得"><a class="markdownIt-Anchor" href="#规则1先占先得"></a> 规则1——先占先得</h3>
<ul>
<li>
<p>若当前<strong>已经有设备操作总线发送数据帧/遥控帧</strong>，则其他任何设备不能再同时发送数据帧/遥控帧（<strong>可以发送错误帧/过载帧破坏当前数据</strong>）</p>
</li>
<li>
<p>任何设备检测到<strong>连续11个隐性电平</strong>，即认为<strong>总线空闲</strong>，<strong>只有总线空闲，设备才可以发送数据帧/遥控帧</strong></p>
</li>
<li>
<p>一旦有设备正在发送数据帧/遥控帧，总线就会变活跃状态，必然不会出现连续11个隐性电平（连续6个就是错误帧/过载帧），其他设备自然也不会破坏当前发送</p>
</li>
<li>
<p>若总线活跃，其他设备有发送需求，则需要等待总线变空闲，才能执行发送需求</p>
</li>
</ul>
<h3 id="规则2非破坏性仲裁"><a class="markdownIt-Anchor" href="#规则2非破坏性仲裁"></a> 规则2——非破坏性仲裁</h3>
<p><strong>根据ID号（仲裁段）进行非破坏性仲裁，ID号小的取到总线控制权</strong>，ID号大的仲裁失利将转为接收状态，等待下一次总线空闲时再尝试发送。</p>
<h4 id="实现非破坏性仲裁两个要求"><a class="markdownIt-Anchor" href="#实现非破坏性仲裁两个要求"></a> 实现非破坏性仲裁两个要求：</h4>
<ul>
<li>
<p>线与特性：总线上任何一个设备发送显性电平0时，总线就会呈现显性电平0，只有当所有设备都发送隐性电平1时，总线才会呈现隐性电平1；即0 &amp; X  = 0， 1 &amp; 1 = 1.</p>
</li>
<li>
<p>回读机制：每隔设备发出一个数据位后，都会读回总线当前的电平状态，以确认自己发出的电平是否被真实发送出去了。根据线与特性，发出0，读回必然是0，但是发出1读回不一定是1.<strong>（此刻是还在仲裁段，发出数据1，读回数据0，表示有设备在占用总线，ID小的优先）</strong></p>
</li>
</ul>
<h4 id="优先级补充"><a class="markdownIt-Anchor" href="#优先级补充"></a> 优先级补充</h4>
<ul>
<li>
<p><strong>数据帧和遥控帧ID号一样时，数据帧的优先级高于遥控帧</strong></p>
</li>
<li>
<p><strong>标准格式的11位ID号和扩展格式29位ID号的前11位系统，标准格式的优先级高于扩展格式</strong>（SSR必须始终为1）</p>
</li>
</ul>
<h2 id="错误类型"><a class="markdownIt-Anchor" href="#错误类型"></a> 错误类型</h2>
<p>错误有5种：位错误、填充错误、CRC错误、格式错误、应答错误</p>
<p><img src="https://s2.loli.net/2025/07/24/MmE48gt5k3LKpD7.png" alt="" /></p>
<p>为了防止某个设备发疯一样，一直认为别的设备发送是错误帧，引入<strong>错误状态</strong></p>
<h3 id="错误状态"><a class="markdownIt-Anchor" href="#错误状态"></a> 错误状态</h3>
<ul>
<li>主动错误状态的设备正常参与通信并检测到错误时发出主动错误帧（会破坏别的数据帧）</li>
<li>被动错误状态的设备正常参与通信但检测到错误时只能发出被动错误帧（不会破坏别的数据帧）</li>
<li>总线关闭状态的设备不能参与通信</li>
<li>每隔设备内部管理一个TEC和REC，根据TEC和REC确定直接的状态</li>
</ul>
<p><img src="https://s2.loli.net/2025/07/24/SkbB8ojwI2rM1O5.png" alt="" /></p>
<p><img src="https://s2.loli.net/2025/07/24/I68snYPTvfMuiQU.png" alt="" /></p>
<h2 id="stm32-can外设"><a class="markdownIt-Anchor" href="#stm32-can外设"></a> STM32 CAN外设</h2>
<ul>
<li>
<p>波特率最高可达1Mbps</p>
</li>
<li>
<p>3个可配置优先级的发送邮箱 —— 发送缓冲区</p>
</li>
<li>
<p>2个3级深度接收FIFO —— 接收缓冲区</p>
</li>
<li>
<p>14个过滤器组 —— 过滤无关报文</p>
</li>
<li>
<p>时间触发通信、自动离线恢复、自动唤醒、禁止自动重传、接收FIFO溢出处理方式可配置、发送优先级可配置、双CAN模式</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2025/07/24/4fXN3hrozaApKw2.png" alt="" /></p>
<h3 id="标识符过滤器"><a class="markdownIt-Anchor" href="#标识符过滤器"></a> 标识符过滤器</h3>
<ul>
<li>
<p>每个过滤器的核心由两个32位寄存器组成：R1[31:0]和R2[31:0]；x = 0,…,13</p>
</li>
<li>
<p>FSCx：位宽设置；置0，16位；置1，32位</p>
</li>
<li>
<p>FBMx：模式设置；置0，屏蔽模式；置1，列表模式</p>
</li>
<li>
<p>FFAx：关联模式；置0，FIFO 0；置1，FIFO 1</p>
</li>
<li>
<p>FACTx：激活设置；置0，禁用；置1，启用、</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2025/07/24/D53jncszLtSyEKO.png" alt="" /></p>
<p><img src="https://s2.loli.net/2025/07/24/NzLVncImCh8sZjB.png" alt="" /></p>
<p>（TIP：第二行Mask的0x700 ---- 0111 0000 0000，表示接收的第2到4位必须和ID相同）</p>
<h3 id="测试模式"><a class="markdownIt-Anchor" href="#测试模式"></a> 测试模式</h3>
<p><img src="https://s2.loli.net/2025/07/24/oHWz7Z3FiTdPuan.png" alt="" /></p>
<h3 id="工作模式"><a class="markdownIt-Anchor" href="#工作模式"></a> 工作模式</h3>
<p><img src="https://s2.loli.net/2025/07/24/l7gpX8YyLdzs21e.png" alt="" /></p>
<h3 id="位时间特征"><a class="markdownIt-Anchor" href="#位时间特征"></a> 位时间特征</h3>
<p><img src="https://s2.loli.net/2025/07/24/vFjc6RTKwbhLIXs.png" alt="" /></p>
<p>TIP：STM32里面PBS1和PBS2合并成一个BS段</p>
<h3 id="中断"><a class="markdownIt-Anchor" href="#中断"></a> 中断</h3>
<p><img src="https://s2.loli.net/2025/07/24/hHASOJDMRbKeBvT.png" alt="" /></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>CAN通信</tag>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Bootloader学习笔记</title>
    <url>/2025/05/10/Bootloader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="bootloaderiap"><a class="markdownIt-Anchor" href="#bootloaderiap"></a> Bootloader+IAP</h1>
<h2 id="简要说明"><a class="markdownIt-Anchor" href="#简要说明"></a> 简要说明</h2>
<p>本学习笔记主要包括<strong>STM32F103C8T6</strong>下的Bootloader+IAP</p>
<p><strong>Bootloader</strong>：用于更新APP的程序</p>
<p><strong>IAP</strong>：在设备运行时，由Bootloader引导对自身程序擦写</p>
<p><strong>OTA</strong>：无线通信将新的固件下载到设备中（Over The Air）</p>
<h3 id="说明"><a class="markdownIt-Anchor" href="#说明"></a> 说明</h3>
<p><strong>使用的APP数据，OTA标志位，版本号存储在AT24C02</strong></p>
<p><strong>多个备份APP数据存储在W25Q64</strong></p>
<p>Q：已经操作了AT24C02和W25Q64，为什么还要操作单片机上的SRAM？</p>
<p>A：AT24C02和Flash读写太慢，跟不上CPU的速度，<strong>SRAM是临时、高速的数据交换区</strong>。</p>
<h2 id="整体流程图"><a class="markdownIt-Anchor" href="#整体流程图"></a> 整体流程图</h2>
<p><img src="https://s2.loli.net/2025/05/10/ADCErlteIk9JBR4.png" alt="" /></p>
<h2 id="分区"><a class="markdownIt-Anchor" href="#分区"></a> 分区</h2>
<p>A区存放APP，B区存放Bootloader程序。<strong>OTA_Flag表示是否更新APP，存放在AT24C02中</strong></p>
<ol>
<li>
<p>❌️ <strong>| A | B |</strong> ------&gt;程序运行后，先进入A区；若OTA_Flag=1开始更新数据，当正在更新的A区出现异常退出，下一次上电后运行A发现程序不全，无法再进入B区进行后续更新A区的操作，并且之前的A区程序有出现问题，<strong>悲报，成砖头了</strong>。</p>
</li>
<li>
<p>✔️ <strong>| B | A |</strong> ------&gt;程序运行后，先进入B区，观测到OTA_Flag=1后对A区进行数据更新，即使异常退出，后续仍然可以进入B区对A区进行更新，更新完成后置OTA_Flag=0。</p>
</li>
</ol>
<h2 id="方案"><a class="markdownIt-Anchor" href="#方案"></a> 方案</h2>
<p>🦝<strong>DMA + 空闲中断</strong></p>
<p>在无需CPU帮助下，<strong>DMA</strong>负责外设与寄存器之间<strong>数据传输</strong></p>
<p><strong>空闲中断</strong>（IDLE）是串口通信中<strong>判断“接收完成”的经典方式</strong></p>
<p><strong>环形缓冲区</strong>：<strong>数据传输</strong>过程中，<strong>接收速度和处理速度可能不一致</strong>，因此<strong>需要缓冲区先保存数据，防止数据丢失</strong>；一维数组，确认<strong>单次接收最大量</strong>，防止出现越界问题</p>
<p><strong>SE指针对（环形缓冲）</strong>：缓冲区是一维数组，总长度为 2048 Byte，划分为10个数据块，每个数据块200 Byte。通过两个指针 IN（生产者指针）和 OUT（消费者指针）管理缓冲区的读写操作。当 IN ≠ OUT 时，表示缓冲区中存在待处理的数据包。指针每次移动一个数据块（200字节），当指针到达缓冲区末尾时自动回卷到起始位置，实现环形缓冲机制。</p>
<img src="https://s2.loli.net/2025/08/22/Mg31NUZXFtv5TCk.png" style="zoom:50%;" />
<p>❗TIP：每次接收后，都<strong>需要判断剩余空间</strong>，以防内存不足，及时回卷；需要记录已经存放的<strong>累加值</strong></p>
<h2 id="编程"><a class="markdownIt-Anchor" href="#编程"></a> 编程</h2>
<p>STM32F103C8T6使用外部高速时钟HSE，8MHz；通过PLL（倍频锁相环）可以达到72MHz</p>
<h3 id="串口与dma"><a class="markdownIt-Anchor" href="#串口与dma"></a> 串口与DMA</h3>
<h5 id="h程序"><a class="markdownIt-Anchor" href="#h程序"></a> .h程序</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 缓冲区大小定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> URx_SIZE 2048           <span class="comment">// 接收缓冲区总大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTx_SIZE 2048           <span class="comment">// 发送缓冲区大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> URx_MAX 200             <span class="comment">// 单次DMA接收最大字节数</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 10                  <span class="comment">// 接收数据包队列深度</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> URx_Buff[URx_SIZE];</span><br><span class="line"><span class="type">uint8_t</span> UTx_Buff[UTx_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 某一组数据接收开始与结束， start：开始， end：结尾</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">uint8_t</span> *start;             <span class="comment">// 数据包起始地址</span></span><br><span class="line">	<span class="type">uint8_t</span> *end;               <span class="comment">// 数据包结束地址</span></span><br><span class="line">&#125;UCB_URxBuff;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 管理串口接收数据</span></span><br><span class="line"><span class="comment">   URxCounter	当前缓冲区中未处理的数据量</span></span><br><span class="line"><span class="comment">   URxDataPtr	缓冲区存储数组序号</span></span><br><span class="line"><span class="comment">   URxDataIN	指向下一组可写入数据的位置</span></span><br><span class="line"><span class="comment">   URxDataOUT	指向下一个待读取数据的位置</span></span><br><span class="line"><span class="comment">   URxDataEND	指向数组末尾	*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">uint16_t</span> URxCounter;        <span class="comment">// 接收计数器，记录当前接收位置</span></span><br><span class="line">	UCB_URxBuff URxDataPtr[NUM]; <span class="comment">// 数据包指针数组（环形队列）</span></span><br><span class="line">	UCB_URxBuff *URxDataIN;     <span class="comment">// 输入指针（生产者）</span></span><br><span class="line">	UCB_URxBuff *URxDataOUT;    <span class="comment">// 输出指针（消费者）</span></span><br><span class="line">	UCB_URxBuff *URxDataEND;    <span class="comment">// 队列末尾指针</span></span><br><span class="line">&#125;UCB_CB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> UCB_CB UCB;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> URx_Buff[URx_SIZE];</span><br></pre></td></tr></table></figure>
<h4 id="配置串口和dma"><a class="markdownIt-Anchor" href="#配置串口和dma"></a> 配置串口和DMA</h4>
<ol>
<li>设置相关<strong>外设时钟</strong></li>
<li>初始化<strong>GPIO(IO分区,MODE,频率,IO口)</strong></li>
<li>配置<strong>串口（初始化，波特率，校验，数据位长度，停止位个数，接收发情况）</strong></li>
<li>配置<strong>串口DMA</strong></li>
<li>打开<strong>串口中断（IDLE为空闲中断）</strong></li>
<li><strong>调用其他功能函数</strong></li>
<li><strong>使能串口</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RCC_USART_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_USART1, ENABLE);</span><br><span class="line">	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);		<span class="comment">// 配置DMA</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_USART_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;<span class="comment">// 配置PA9为TX（复用推挽输出）</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;<span class="comment">// 配置PA10为RX（浮空输入）</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">NVIC_USART_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 配置中断</span></span><br><span class="line">	NVIC_SetPriorityGrouping(NVIC_PriorityGroup_2);</span><br><span class="line">		</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">0</span>;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">0</span>;</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_USART_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">    <span class="comment">//URx_Buff长度为URx_MAX，此处+1是为了配合IDLE实现中断</span></span><br><span class="line">	DMA_InitStructure.DMA_BufferSize = URx_MAX + <span class="number">1</span>;</span><br><span class="line">	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;</span><br><span class="line">	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;</span><br><span class="line">	DMA_InitStructure.DMA_MemoryBaseAddr = (<span class="type">uint32_t</span>)URx_Buff;</span><br><span class="line">	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;</span><br><span class="line">	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;</span><br><span class="line">	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;</span><br><span class="line">	DMA_InitStructure.DMA_PeripheralBaseAddr = (<span class="type">uint32_t</span>)&amp;USART1-&gt;DR;</span><br><span class="line">	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;</span><br><span class="line">	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;</span><br><span class="line">	DMA_InitStructure.DMA_Priority = DMA_Priority_High;</span><br><span class="line">	DMA_Init(DMA1_Channel5, &amp;DMA_InitStructure);</span><br><span class="line">	</span><br><span class="line">	DMA_Cmd(DMA1_Channel5, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// USART1初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_Init</span><span class="params">(<span class="type">uint32_t</span> band)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 使能时钟</span></span><br><span class="line">	RCC_USART_Init();</span><br><span class="line">	GPIO_USART_Init();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 配置USART1参数</span></span><br><span class="line">	USART_InitTypeDef USART_InitStructure;</span><br><span class="line">	USART_InitStructure.USART_BaudRate = band;</span><br><span class="line">	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class="line">	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;</span><br><span class="line">	USART_InitStructure.USART_Parity = USART_Parity_No;</span><br><span class="line">	USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class="line">	USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class="line">	USART_Init(USART1, &amp;USART_InitStructure);</span><br><span class="line">	</span><br><span class="line">	USART_DMACmd(USART1, USART_DMAReq_Rx, ENABLE);</span><br><span class="line">	USART_ITConfig(USART1, USART_IT_IDLE, ENABLE);</span><br><span class="line">	</span><br><span class="line">	NVIC_USART_Init();</span><br><span class="line">	DMA_USART_Init();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 初始化串口控制块</span></span><br><span class="line">	UCB.URxCounter = <span class="number">0</span>;</span><br><span class="line">	UCB.URxDataIN = &amp;UCB.URxDataPtr[<span class="number">0</span>];</span><br><span class="line">	UCB.URxDataOUT = &amp;UCB.URxDataPtr[<span class="number">0</span>];</span><br><span class="line">	UCB.URxDataEND = &amp;UCB.URxDataPtr[NUM - <span class="number">1</span>];</span><br><span class="line">	UCB.URxDataIN-&gt;start = URx_Buff;</span><br><span class="line">	</span><br><span class="line">	USART_Cmd(USART1, ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="串口空闲中断函数"><a class="markdownIt-Anchor" href="#串口空闲中断函数"></a> 串口空闲中断函数</h4>
<ol>
<li><strong>检测空闲中断</strong></li>
<li><strong>消除空闲中断标志位</strong>（只有读标志位寄存器和数据位寄存器才能将空闲标志位清除）</li>
<li>在空闲中断中<strong>读取串口DMA增添数据的长度</strong>(DMA,通道) — counter += (总量 - 剩余空闲值)</li>
<li><strong>设置缓冲区的IN指针</strong></li>
<li>Disable DMA，重新配置DMA（DMA，通道，大小，地址），保证不出现完成状态，再使能DMA</li>
</ol>
<p><strong>要一直让DMA读取数据，直到出现空闲中断才会停止，因此不会出现完成状态</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief USART1中断处理函数</span></span><br><span class="line"><span class="comment"> * @param 无</span></span><br><span class="line"><span class="comment"> * @return 无</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 处理USART1的IDLE（空闲）中断：</span></span><br><span class="line"><span class="comment"> * 1. 检测到串口空闲时，表示一个数据包接收完成</span></span><br><span class="line"><span class="comment"> * 2. 计算实际接收的数据长度</span></span><br><span class="line"><span class="comment"> * 3. 更新环形缓冲区指针</span></span><br><span class="line"><span class="comment"> * 4. 重新配置DMA为下一次接收做准备</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 工作流程：</span></span><br><span class="line"><span class="comment"> * - IDLE中断触发 -&gt; 数据包接收完成</span></span><br><span class="line"><span class="comment"> * - 计算接收长度 -&gt; 更新数据包结束指针</span></span><br><span class="line"><span class="comment"> * - 移动输入指针 -&gt; 处理环形缓冲区绕回</span></span><br><span class="line"><span class="comment"> * - 重启DMA接收 -&gt; 准备接收下一个数据包</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 检查IDLE中断标志位</span></span><br><span class="line">	<span class="keyword">if</span>(USART_GetFlagStatus(USART1, USART_FLAG_IDLE) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 清除IDLE中断标志位</span></span><br><span class="line">		USART_ClearFlag(USART1, USART_FLAG_IDLE);</span><br><span class="line">		<span class="comment">// 读取数据寄存器以清除IDLE标志（必须操作）</span></span><br><span class="line">		USART_ReceiveData(USART1);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 计算本次接收的数据长度并更新接收计数器</span></span><br><span class="line">		UCB.URxCounter += (URx_MAX + <span class="number">1</span>) - DMA_GetCurrDataCounter(DMA1_Channel5);</span><br><span class="line">		<span class="comment">// 设置当前数据包的结束地址</span></span><br><span class="line">		UCB.URxDataIN-&gt;end = &amp;URx_Buff[UCB.URxCounter - <span class="number">1</span>];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 移动输入指针到下一个数据包位置</span></span><br><span class="line">		UCB.URxDataIN++;</span><br><span class="line">		<span class="comment">// 检查是否到达队列末尾，进行环形处理</span></span><br><span class="line">		<span class="keyword">if</span>(UCB.URxDataIN == UCB.URxDataEND)</span><br><span class="line">		&#123;</span><br><span class="line">			UCB.URxDataIN = &amp;UCB.URxDataPtr[<span class="number">0</span>];     <span class="comment">// 回到队列开头</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 检查剩余缓冲区空间，决定下一次DMA接收的起始地址</span></span><br><span class="line">		<span class="keyword">if</span>(URx_SIZE - UCB.URxCounter &gt;= URx_MAX)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 剩余空间足够，继续在当前位置接收</span></span><br><span class="line">			UCB.URxDataIN-&gt;start = &amp;URx_Buff[UCB.URxCounter];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 剩余空间不足，回到缓冲区开头</span></span><br><span class="line">			UCB.URxDataIN-&gt;start = URx_Buff;</span><br><span class="line">			UCB.URxCounter = <span class="number">0</span>;                     <span class="comment">// 重置接收计数器</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 重新配置DMA为下一次接收</span></span><br><span class="line">		DMA_Cmd(DMA1_Channel5, DISABLE);                           <span class="comment">// 禁用DMA</span></span><br><span class="line">		DMA_SetCurrDataCounter(DMA1_Channel5, URx_MAX + <span class="number">1</span>);        <span class="comment">// 设置传输计数</span></span><br><span class="line">		DMA1_Channel5-&gt;CMAR = (<span class="type">uint32_t</span>)UCB.URxDataIN-&gt;start;      <span class="comment">// 设置内存地址</span></span><br><span class="line">		DMA_Cmd(DMA1_Channel5, ENABLE);                            <span class="comment">// 重新启用DMA</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编写新的printf函数"><a class="markdownIt-Anchor" href="#编写新的printf函数"></a> 编写新的Printf函数</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 格式化打印函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uprintf</span><span class="params">(<span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list list_data;</span><br><span class="line">    va_start(list_data, format);</span><br><span class="line"></span><br><span class="line">    vsnprintf((<span class="type">char</span> *)UTx_Buff, <span class="keyword">sizeof</span>(UTx_Buff), format, list_data);</span><br><span class="line">    va_end(list_data);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> len = <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)UTx_Buff);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TXE) != <span class="number">1</span>);</span><br><span class="line">        USART_SendData(USART1, UTx_Buff[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TC) != <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="i2c"><a class="markdownIt-Anchor" href="#i2c"></a> I2C</h3>
<p><strong>软件I2C</strong>，延时部分需要自己重新设计</p>
<h4 id="h程序-2"><a class="markdownIt-Anchor" href="#h程序-2"></a> .h程序</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SCL_H GPIO_SetBits(GPIOB, GPIO_Pin_3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCL_L GPIO_ResetBits(GPIOB, GPIO_Pin_3)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDA_H GPIO_SetBits(GPIOB, GPIO_Pin_4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDA_L GPIO_ResetBits(GPIOB, GPIO_Pin_4)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Read_SDA GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_4)</span></span><br></pre></td></tr></table></figure>
<h4 id="delay"><a class="markdownIt-Anchor" href="#delay"></a> Delay</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 延时功能初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微秒级延时</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_us</span><span class="params">(<span class="type">uint16_t</span> us)</span></span><br><span class="line">&#123;</span><br><span class="line">	SysTick_Config(SystemCoreClock / <span class="number">1000000</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(us--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(!((SysTick-&gt;CTRL) &amp; (SysTick_CTRL_COUNTFLAG)));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 毫秒级延时</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">uint16_t</span> ms)</span></span><br><span class="line">&#123;</span><br><span class="line">	SysTick_Config(SystemCoreClock / <span class="number">1000</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(ms--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(!((SysTick-&gt;CTRL) &amp; (SysTick_CTRL_COUNTFLAG)));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="初始化-start和stop信号"><a class="markdownIt-Anchor" href="#初始化-start和stop信号"></a> 初始化、START和STOP信号</h4>
<ol>
<li>
<p>硬件I2C，开启<strong>时钟</strong></p>
</li>
<li>
<p>配置<strong>GPIO</strong>（PB6，PB7，开漏模式）</p>
</li>
<li>
<p>配置<strong>SCL和SDA</strong>两条线</p>
</li>
</ol>
<p><strong>起始信号</strong>：SCL高电平，SDA从高电平变为低电平</p>
<p><strong>停止信号</strong>：SCL高电平，SDA从低电平变为高电平</p>
<p><strong>数据信号</strong>：SCL高电平，SDA保持不变；<strong>SCL低电平，SDA电平可以修改</strong></p>
<p><strong>应答信号</strong>：SCL高电平，SDA<strong>低电平</strong>，<strong>应答</strong>，否则，非应答</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C1_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 使能GPIOB时钟</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 配置SCL引脚（PB3）为开漏输出</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;   <span class="comment">// 开漏输出模式</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 配置SDA引脚（PB4）为开漏输出</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;   <span class="comment">// 开漏输出模式</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置总线初始状态为高电平（空闲状态）</span></span><br><span class="line">	SCL_H;</span><br><span class="line">	SDA_H;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Start信号 */</span></span><br><span class="line"><span class="comment">// 一旦 Start 产生后，数据传输必须在 SCL 为低时开始。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	SCL_H;                              <span class="comment">// 确保SCL为高电平</span></span><br><span class="line">	SDA_H;                              <span class="comment">// 确保SDA为高电平</span></span><br><span class="line">	delay_us(<span class="number">2</span>);                        <span class="comment">// 延时等待信号稳定</span></span><br><span class="line">	SDA_L;                              <span class="comment">// SDA变为低电平（起始条件）</span></span><br><span class="line">	SCL_L;                              <span class="comment">// SCL变为低电平，准备发送数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* End信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	SCL_L;                              <span class="comment">// 确保SCL为低电平</span></span><br><span class="line">	SDA_L;                              <span class="comment">// 确保SDA为低电平</span></span><br><span class="line">	delay_us(<span class="number">2</span>);                        <span class="comment">// 延时等待信号稳定</span></span><br><span class="line">	SCL_H;                              <span class="comment">// SCL变为高电平</span></span><br><span class="line">	SDA_H;                              <span class="comment">// SDA变为高电平（停止条件）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="发送一个字节"><a class="markdownIt-Anchor" href="#发送一个字节"></a> 发送一个字节</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_SendByte</span><span class="params">(<span class="type">uint8_t</span> tx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 从最高位开始发送（MSB first）</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int8_t</span> i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		SCL_L;                              <span class="comment">// SCL置低，准备设置数据</span></span><br><span class="line">		<span class="keyword">if</span>(tx &amp; (<span class="number">1</span> &lt;&lt; i))                   <span class="comment">// 检查当前位是否为1</span></span><br><span class="line">		&#123;</span><br><span class="line">			SDA_H;                          <span class="comment">// 发送逻辑1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			SDA_L;                          <span class="comment">// 发送逻辑0</span></span><br><span class="line">		&#125;</span><br><span class="line">		delay_us(<span class="number">2</span>);                        <span class="comment">// 延时等待数据稳定</span></span><br><span class="line">		SCL_H;                              <span class="comment">// SCL置高，让从机读取数据</span></span><br><span class="line">		delay_us(<span class="number">2</span>);                        <span class="comment">// 延时保持时钟高电平</span></span><br><span class="line">	&#125;</span><br><span class="line">	SCL_L;                                  <span class="comment">// 发送完成，SCL置低</span></span><br><span class="line">	SDA_H;                                  <span class="comment">// 释放SDA线，准备接收ACK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读取一个字节"><a class="markdownIt-Anchor" href="#读取一个字节"></a> 读取一个字节</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">I2C_ReadByte</span><span class="params">(<span class="type">uint8_t</span> ack)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> rx = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 从最高位开始接收（MSB first）</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int8_t</span> i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		SCL_L;                              <span class="comment">// SCL置低，准备读取数据</span></span><br><span class="line">		delay_us(<span class="number">2</span>);</span><br><span class="line">		SCL_H;                              <span class="comment">// SCL置高，读取数据</span></span><br><span class="line">		<span class="keyword">if</span>(Read_SDA)                        <span class="comment">// 读取SDA上的数据</span></span><br><span class="line">		&#123;</span><br><span class="line">			rx |= (<span class="number">1</span> &lt;&lt; i);                 <span class="comment">// 如果SDA为高，设置对应位</span></span><br><span class="line">		&#125;</span><br><span class="line">		delay_us(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	SCL_L;                                  <span class="comment">// 数据接收完成，SCL置低</span></span><br><span class="line">	<span class="comment">// 发送应答或非应答</span></span><br><span class="line">	<span class="keyword">if</span>(ack)</span><br><span class="line">	&#123;</span><br><span class="line">		SDA_L;                              <span class="comment">// 发送ACK（应答）</span></span><br><span class="line">		SCL_H;</span><br><span class="line">		delay_us(<span class="number">2</span>);</span><br><span class="line">		SCL_L;</span><br><span class="line">		SDA_H;                              <span class="comment">// 释放SDA线</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		SDA_H;</span><br><span class="line">		SCL_H;</span><br><span class="line">		delay_us(<span class="number">2</span>);</span><br><span class="line">		SCL_L;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="等待从机ack"><a class="markdownIt-Anchor" href="#等待从机ack"></a> 等待从机ACK</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">I2C_Wait_ACK</span><span class="params">(<span class="type">int16_t</span> timeout)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 等待SDA变为低电平（从机应答）</span></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		timeout--;</span><br><span class="line">		delay_us(<span class="number">2</span>);</span><br><span class="line">	&#125;<span class="keyword">while</span>(Read_SDA &amp;&amp; timeout &gt;= <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(timeout &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;                           <span class="comment">// 等待超时</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	SCL_H;                                  <span class="comment">// SCL置高，读取应答信号</span></span><br><span class="line">	delay_us(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span>(Read_SDA != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;                           <span class="comment">// 应答信号无效</span></span><br><span class="line">	&#125;</span><br><span class="line">	SCL_L;                                  <span class="comment">// SCL置低，应答读取完成</span></span><br><span class="line">	delay_us(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;                               <span class="comment">// 成功接收应答</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="at24c02"><a class="markdownIt-Anchor" href="#at24c02"></a> AT24C02</h3>
<p><strong>I2C通信</strong>，设备地址：1 0 1 0  E2 E1 E0 R/非W；</p>
<p>读R=1，0XA1；</p>
<p>写W=0，0XA0；</p>
<p><strong>按字节写入</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AT24C02_WADDR 0xA0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AT24C02_RADDR 0xA1</span></span><br></pre></td></tr></table></figure>
<p>AT24C02共<strong>16页</strong>，<strong>一页16字节</strong>，共256字节；<strong>存在回卷问题</strong></p>
<h4 id="写入"><a class="markdownIt-Anchor" href="#写入"></a> 写入</h4>
<img src="https://s2.loli.net/2025/05/09/4LQS8qFYM3cmdbp.png" style="zoom:80%;" />
<h5 id="byte-write"><a class="markdownIt-Anchor" href="#byte-write"></a> Byte Write</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// addr:写入的EEPROM内存地址</span></span><br><span class="line"><span class="comment">// wdata:写入的数据</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">AT24C02_WriteByte</span><span class="params">(<span class="type">uint8_t</span> addr, <span class="type">uint8_t</span> wdata)</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C_Start();</span><br><span class="line">    I2C_SendByte(AT24C02_WADDR); 			<span class="comment">// 发送写入信号</span></span><br><span class="line">    <span class="keyword">if</span> (I2C_Wait_ACK(<span class="number">100</span>) != <span class="number">0</span>)  			<span class="comment">// 100为等待应答的信号</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                			<span class="comment">// 芯片无应答</span></span><br><span class="line">    </span><br><span class="line">    I2C_SendByte(addr);</span><br><span class="line">    <span class="keyword">if</span> (I2C_Wait_ACK(<span class="number">100</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>; 							<span class="comment">// 写入地址失败</span></span><br><span class="line">    </span><br><span class="line">    I2C_SendByte(wdata);</span><br><span class="line">    <span class="keyword">if</span> (I2C_Wait_ACK(<span class="number">100</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>; 							<span class="comment">// 写入数据失败</span></span><br><span class="line">    I2C_Stop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; 								<span class="comment">// 成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="page-write"><a class="markdownIt-Anchor" href="#page-write"></a> Page Write</h5>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// addr：写入地址</span></span><br><span class="line"><span class="comment">// wdata：写入数据</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">AT24C02_WritePage</span><span class="params">(<span class="type">uint8_t</span> addr, <span class="type">uint8_t</span> *wdata)</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C_Start();</span><br><span class="line">    I2C_SendByte(AT24C02_WADDR); 			<span class="comment">// 发送写入信号</span></span><br><span class="line">    <span class="keyword">if</span> (I2C_Wait_ACK(<span class="number">100</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; 							<span class="comment">// 芯片无应答</span></span><br><span class="line"></span><br><span class="line">    I2C_SendByte(addr);</span><br><span class="line">    <span class="keyword">if</span> (I2C_Wait_ACK(<span class="number">100</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>; 							<span class="comment">// 写入地址失败</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        I2C_SendByte(wdata[i]);</span><br><span class="line">        <span class="keyword">if</span> (I2C_Wait_ACK(<span class="number">100</span>) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span> + i; 					<span class="comment">// 写入数据失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    I2C_Stop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; 								<span class="comment">// 成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读取"><a class="markdownIt-Anchor" href="#读取"></a> 读取</h4>
<img src="https://s2.loli.net/2025/05/09/74nb8woeaplzTcr.png" style="zoom:67%;" />
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// addr：读取的起始地址</span></span><br><span class="line"><span class="comment">// rdata：指向存储读取数据的缓冲区的指针</span></span><br><span class="line"><span class="comment">// datalen:读取数据长度</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">AT24C02_ReadData</span><span class="params">(<span class="type">uint8_t</span> addr, <span class="type">uint8_t</span> *rdata, <span class="type">uint16_t</span> datalen)</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C_Start();</span><br><span class="line">    I2C_SendByte(AT24C02_WADDR); 			<span class="comment">// 发送写入信号</span></span><br><span class="line">    <span class="keyword">if</span> (I2C_Wait_ACK(<span class="number">100</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; 							<span class="comment">// 芯片无应答</span></span><br><span class="line"></span><br><span class="line">    I2C_SendByte(addr); 					<span class="comment">// 写入读取地址</span></span><br><span class="line">    <span class="keyword">if</span> (I2C_Wait_ACK(<span class="number">100</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>; 							<span class="comment">// 写入读取地址失败</span></span><br><span class="line"></span><br><span class="line">    I2C_Start();</span><br><span class="line">    I2C_SendByte(AT24C02_RADDR); 			<span class="comment">// 发送读取信号</span></span><br><span class="line">    <span class="keyword">if</span> (I2C_Wait_ACK(<span class="number">100</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>; 							<span class="comment">// 切换读模式时芯片无应答</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; datalen - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rdata[i] = I2C_ReadByte(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rdata[datalen - <span class="number">1</span>] = I2C_ReadByte(<span class="number">0</span>); 	<span class="comment">// 读取最后一个字节时不发送ACK信号</span></span><br><span class="line">    I2C_Stop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; 								<span class="comment">// 成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spi"><a class="markdownIt-Anchor" href="#spi"></a> SPI</h3>
<p>外部FLASH型号为W25Q64，使用<strong>硬件SPI</strong></p>
<img src="https://s2.loli.net/2025/05/09/WoTtsqaOecy1FAw.png" style="zoom:50%;" />
<ol>
<li>
<p>配置<strong>SPI0时钟</strong>，相关<strong>GPIO开启</strong></p>
</li>
<li>
<p><strong>复位SPI外设</strong></p>
</li>
<li>
<p>配置<strong>SPI结构体成员（主从模式，发送类型（全双工），一帧大小，硬件/软件，大端/小端（大端），工作方式（极性（上下）/相位（一二），从机决定），传输速度）</strong></p>
</li>
<li>
<p><strong>初始化SPI</strong></p>
</li>
<li>
<p><strong>使能SPI</strong></p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初始化SPI1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI1_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使能GPIOA和SPI1时钟</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_SPI1, ENABLE);</span><br><span class="line"></span><br><span class="line">    GPIO_InitTypeDef GPIO_StructInit;</span><br><span class="line">    GPIO_StructInit.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_7;	<span class="comment">// 配置SCK和MOSI引脚(PA5,PA7)</span></span><br><span class="line">    GPIO_StructInit.GPIO_Mode = GPIO_Mode_AF_PP; 		<span class="comment">// 复用推挽输出</span></span><br><span class="line">    GPIO_StructInit.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_StructInit);</span><br><span class="line"></span><br><span class="line">    GPIO_StructInit.GPIO_Pin = GPIO_Pin_6;				<span class="comment">// 配置MISO引脚(PA6)</span></span><br><span class="line">    GPIO_StructInit.GPIO_Mode = GPIO_Mode_IN_FLOATING;	<span class="comment">// 浮空输入</span></span><br><span class="line">    GPIO_StructInit.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_StructInit);</span><br><span class="line">    </span><br><span class="line">    SPI_I2S_DeInit(SPI1);					<span class="comment">// 复位SPI1外设</span></span><br><span class="line">    </span><br><span class="line">    SPI_InitTypeDef SPI_InitStructure;		<span class="comment">// 配置SPI参数</span></span><br><span class="line">    <span class="comment">/* SPI初始化结构体配置 */</span></span><br><span class="line">    <span class="comment">// SPI工作模式：主模式（控制时钟信号）</span></span><br><span class="line">    SPI_InitStructure.SPI_Mode = SPI_Mode_Master;</span><br><span class="line">    <span class="comment">// SPI通信方向：双线全双工（同时发送和接收）</span></span><br><span class="line">    SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;</span><br><span class="line">    <span class="comment">// 数据帧格式：8位数据</span></span><br><span class="line">    SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;</span><br><span class="line">    <span class="comment">// 时钟极性：高电平空闲（CPOL=1）</span></span><br><span class="line">    SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;</span><br><span class="line">    <span class="comment">// 时钟相位：第二个边沿采样（CPHA=1）</span></span><br><span class="line">    SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;</span><br><span class="line">    <span class="comment">// 片选控制：软件NSS管理（手动控制片选）</span></span><br><span class="line">    SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;</span><br><span class="line">    <span class="comment">// 波特率预分频：系统时钟2分频（fPCLK/2）</span></span><br><span class="line">    SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;</span><br><span class="line">    <span class="comment">// 数据传输顺序：高位先发送（MSB first）</span></span><br><span class="line">    SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;</span><br><span class="line">    <span class="comment">// CRC多项式：7,大部分SPI设备用不到，随便给个值</span></span><br><span class="line">    SPI_InitStructure.SPI_CRCPolynomial = <span class="number">7</span>;</span><br><span class="line">    SPI_Init(SPI1, &amp;SPI_InitStructure);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使能SPI1</span></span><br><span class="line">    SPI_Cmd(SPI1, ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2025/05/09/TlW7HSEm5eXfPBD.png" style="zoom: 50%;" />
<h4 id="数据收发"><a class="markdownIt-Anchor" href="#数据收发"></a> 数据收发</h4>
<p><strong>SPI_I2S_FLAG_TXE</strong>表示<strong>发送区空了</strong>，<strong>SPI_SPI_FLAG_RXNE</strong>表示<strong>接收区不为空</strong>。切记<strong>全双工，有发就有收！</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// SPI单字节读写，tx是要发送的数据字节</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">SPI1_ReadWrite_Byte</span><span class="params">(<span class="type">uint16_t</span> tx)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">while</span> (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) != <span class="number">1</span>);	<span class="comment">// 等待发送缓冲区空</span></span><br><span class="line">    SPI_I2S_SendData(SPI1, tx);									<span class="comment">// 发送数据</span></span><br><span class="line">    <span class="keyword">while</span> (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) != <span class="number">1</span>);<span class="comment">// 等待接收缓冲区非空</span></span><br><span class="line">    <span class="keyword">return</span> SPI_I2S_ReceiveData(SPI1);							<span class="comment">// 返回接收到的数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多字节写入SPI，wdata要发送的数据缓冲区指针，datalen要发送的数据长度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI1_Write</span><span class="params">(<span class="type">uint8_t</span> *wdata, <span class="type">uint16_t</span> datalen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; datalen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SPI1_ReadWrite_Byte(wdata[i]); 			<span class="comment">// 只发送数据，忽略接收内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多字节读取SPI，rdata接收数据缓冲区指针，datalen要读取的数据长度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI1_Read</span><span class="params">(<span class="type">uint8_t</span> *rdata, <span class="type">uint16_t</span> datalen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; datalen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rdata[i] = SPI1_ReadWrite_Byte(<span class="number">0xff</span>); <span class="comment">// 发送dummy数据(0xFF)来读取，想想Flash清零</span></span><br><span class="line">    &#125;							</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="w25q64"><a class="markdownIt-Anchor" href="#w25q64"></a> W25Q64</h3>
<h4 id="状态寄存器"><a class="markdownIt-Anchor" href="#状态寄存器"></a> <strong>状态寄存器</strong></h4>
<p>主要看<strong>S0 — BUSY</strong></p>
<img src="https://s2.loli.net/2025/05/09/KWenVOwYPLpoXaz.png" style="zoom:67%;" />
<h4 id="指令表"><a class="markdownIt-Anchor" href="#指令表"></a> <strong>指令表</strong></h4>
<img src="https://s2.loli.net/2025/05/09/piZ37vGDV6htqL8.png" style="zoom: 80%;" />
<h4 id="相关程序"><a class="markdownIt-Anchor" href="#相关程序"></a> <strong>相关程序</strong></h4>
<p>SPI+Flash需等待<strong>Busy状态</strong>，先读取状态寄存器地址，后随便写入其它（此时写入什么都不重要，主要获取寄存器中的数值），<strong>打开片选，使能Write再关闭</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CS_ENABLE GPIO_ResetBits(GPIOA, GPIO_Pin_4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CS_DISABLE GPIO_SetBits(GPIOA, GPIO_Pin_4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// W25Q64初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">    GPIO_InitTypeDef GPIO_StructInit;</span><br><span class="line">    GPIO_StructInit.GPIO_Pin = GPIO_Pin_4;         	<span class="comment">// CS片选引脚（低电平有效）</span></span><br><span class="line">    GPIO_StructInit.GPIO_Mode = GPIO_Mode_Out_PP;  	<span class="comment">// 推挽输出模式</span></span><br><span class="line">    GPIO_StructInit.GPIO_Speed = GPIO_Speed_50MHz; 	<span class="comment">// 50MHz速度</span></span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_StructInit);</span><br><span class="line">    CS_DISABLE;  									<span class="comment">// 默认禁用片选</span></span><br><span class="line">    SPI1_Init(); 									<span class="comment">// 初始化SPI1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待芯片空闲</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_WaitBusy</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> res;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        CS_ENABLE;                       			<span class="comment">// 使能片选</span></span><br><span class="line">        SPI1_ReadWrite_Byte(<span class="number">0x05</span>);       			<span class="comment">// 发送读取状态寄存器命令</span></span><br><span class="line">        res = SPI1_ReadWrite_Byte(<span class="number">0xff</span>); 			<span class="comment">// 读取状态寄存器值</span></span><br><span class="line">        CS_DISABLE;                      			<span class="comment">// 禁用片选</span></span><br><span class="line">    &#125; <span class="keyword">while</span> ((res &amp; <span class="number">0x01</span>) == <span class="number">0x01</span>); 				<span class="comment">// 检查BUSY位（bit0）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使能写操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Enable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    W25Q64_WaitBusy(); 								<span class="comment">// 等待空闲</span></span><br><span class="line">    CS_ENABLE;</span><br><span class="line">    SPI1_ReadWrite_Byte(<span class="number">0x06</span>); 						<span class="comment">// 发送写使能指令</span></span><br><span class="line">    CS_DISABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="擦除64kb"><a class="markdownIt-Anchor" href="#擦除64kb"></a> 擦除64KB</h4>
<p>W25Q64总共<strong>8MB</strong> = 8 * 1024KB，<strong>一次擦除64KB</strong>，可得共计8 * 1024 / 64 = <strong>128个Block</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 擦除64KB的块，block: 要擦除的块编号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Erase_64k</span><span class="params">(<span class="type">uint8_t</span> block)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> wdata[<span class="number">4</span>];</span><br><span class="line">    wdata[<span class="number">0</span>] = <span class="number">0xD8</span>;                      		<span class="comment">// 块擦除指令</span></span><br><span class="line">    wdata[<span class="number">1</span>] = (block * <span class="number">64</span> * <span class="number">1024</span>) &gt;&gt; <span class="number">16</span>; 		<span class="comment">// 计算块起始地址（高字节）</span></span><br><span class="line">    wdata[<span class="number">2</span>] = (block * <span class="number">64</span> * <span class="number">1024</span>) &gt;&gt; <span class="number">8</span>;  		<span class="comment">// 中字节</span></span><br><span class="line">    wdata[<span class="number">3</span>] = (block * <span class="number">64</span> * <span class="number">1024</span>) &gt;&gt; <span class="number">0</span>;  		<span class="comment">// 低字节</span></span><br><span class="line">    W25Q64_WaitBusy();							<span class="comment">// 等待BUSY</span></span><br><span class="line">    W25Q64_Enable(); 							<span class="comment">// 使能写操作</span></span><br><span class="line">    CS_ENABLE;</span><br><span class="line">    SPI1_Write(wdata, <span class="number">4</span>); 						<span class="comment">// 发送擦除指令和地址</span></span><br><span class="line">    CS_DISABLE;</span><br><span class="line">    W25Q64_WaitBusy(); 							<span class="comment">// 等待擦除完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="页写入256byte"><a class="markdownIt-Anchor" href="#页写入256byte"></a> 页写入256Byte</h4>
<p><strong>页地址 = page * 256 Byte，每次从页地址开始写入256 Byte，页地址总长24位</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 按页写入数据</span></span><br><span class="line"><span class="comment">// wbuff: 待写入数据的缓冲区指针</span></span><br><span class="line"><span class="comment">// page: 目标页号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_PageWrite</span><span class="params">(<span class="type">uint8_t</span> *wbuff, <span class="type">uint16_t</span> page)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> wdata[<span class="number">4</span>];</span><br><span class="line">    wdata[<span class="number">0</span>] = <span class="number">0x02</span>;               				<span class="comment">// 页写指令</span></span><br><span class="line">    wdata[<span class="number">1</span>] = (page * <span class="number">256</span>) &gt;&gt; <span class="number">16</span>; 				<span class="comment">// 计算页起始地址（高字节）</span></span><br><span class="line">    wdata[<span class="number">2</span>] = (page * <span class="number">256</span>) &gt;&gt; <span class="number">8</span>;  				<span class="comment">// 中字节</span></span><br><span class="line">    wdata[<span class="number">3</span>] = (page * <span class="number">256</span>) &gt;&gt; <span class="number">0</span>;  				<span class="comment">// 低字节</span></span><br><span class="line">    W25Q64_WaitBusy();</span><br><span class="line">    W25Q64_Enable(); 							<span class="comment">// 使能写操作</span></span><br><span class="line">    CS_ENABLE;</span><br><span class="line">    SPI1_Write(wdata, <span class="number">4</span>);   					<span class="comment">// 发送写指令和地址</span></span><br><span class="line">    SPI1_Write(wbuff, <span class="number">256</span>); 					<span class="comment">// 写入256字节数据</span></span><br><span class="line">    CS_DISABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读取数据"><a class="markdownIt-Anchor" href="#读取数据"></a> 读取数据</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line"><span class="comment">// rbuff: 数据读取缓冲区指针</span></span><br><span class="line"><span class="comment">// addr: 起始地址</span></span><br><span class="line"><span class="comment">// datalen: 要读取的字节数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Read</span><span class="params">(<span class="type">uint8_t</span> *rbuff, <span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> datalen)</span> <span class="comment">// 地址只用24位</span></span><br><span class="line">&#123;</span><br><span class="line">    W25Q64_WaitBusy();</span><br><span class="line">    CS_ENABLE;</span><br><span class="line">    SPI1_ReadWrite_Byte(<span class="number">0x03</span>);</span><br><span class="line">    SPI1_ReadWrite_Byte((<span class="type">uint16_t</span>)(addr &gt;&gt; <span class="number">16</span>));</span><br><span class="line">    SPI1_ReadWrite_Byte((<span class="type">uint16_t</span>)(addr &gt;&gt; <span class="number">8</span>));</span><br><span class="line">    SPI1_ReadWrite_Byte((<span class="type">uint16_t</span>)(addr &gt;&gt; <span class="number">0</span>));</span><br><span class="line">    SPI1_Read(rbuff, datalen);</span><br><span class="line">    CS_DISABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="stm32的flash"><a class="markdownIt-Anchor" href="#stm32的flash"></a> STM32的FLASH</h3>
<p>Flash<strong>擦除后为0xFF</strong></p>
<h4 id="擦除flash"><a class="markdownIt-Anchor" href="#擦除flash"></a> 擦除Flash</h4>
<p>Flash<strong>一页1KB</strong>，下面函数实现<strong>一次擦除num页</strong>数据</p>
<p><strong>流程</strong>：</p>
<ol>
<li>
<p>Flash开锁</p>
</li>
<li>
<p><strong>确认地址，擦除地址数据</strong></p>
</li>
<li>
<p>Flash锁定</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// start	起始页号</span></span><br><span class="line"><span class="comment">// num		需要擦除的页数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_Erase</span><span class="params">(<span class="type">uint16_t</span> start, <span class="type">uint16_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> i;</span><br><span class="line">    FLASH_Unlock(); 					<span class="comment">// 解锁FLASH操作</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算目标页地址：FLASH起始地址 + 起始页号 * 页大小 + 当前页偏移</span></span><br><span class="line">        FLASH_ErasePage((FLASH_SADDR + start * <span class="number">1024</span>) + (<span class="number">1024</span> * i));</span><br><span class="line">    &#125;</span><br><span class="line">    FLASH_Lock(); 						<span class="comment">// 锁定FLASH</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="写入flash"><a class="markdownIt-Anchor" href="#写入flash"></a> 写入Flash</h4>
<p>一次写入<strong>num个4字节数据</strong>，地址自动递增</p>
<p><strong>流程</strong>：</p>
<ol>
<li>
<p>Flash开锁</p>
</li>
<li>
<p><strong>将数据写入对应地址</strong></p>
</li>
<li>
<p>Flash锁定</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//	saddr	目标起始地址（必须为4的倍数）</span></span><br><span class="line"><span class="comment">//	wdata	待写入数据的指针</span></span><br><span class="line"><span class="comment">//	wnum	需要写入的字节数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_Write</span><span class="params">(<span class="type">uint32_t</span> saddr, <span class="type">uint32_t</span> *wdata, <span class="type">uint32_t</span> wnum)</span></span><br><span class="line">&#123;</span><br><span class="line">    FLASH_Unlock(); 						<span class="comment">// 解锁FLASH操作</span></span><br><span class="line">    <span class="keyword">while</span> (wnum)</span><br><span class="line">    &#123;</span><br><span class="line">        FLASH_ProgramWord(saddr, *wdata); 	<span class="comment">// 按uint32_t写入数据</span></span><br><span class="line">        wnum -= <span class="number">4</span>;                        	<span class="comment">// 剩余字节数减4</span></span><br><span class="line">        saddr += <span class="number">4</span>;                       	<span class="comment">// 地址指针递增4字节</span></span><br><span class="line">        wdata++;                          	<span class="comment">// 数据指针指向下一个32位数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    FLASH_Lock(); 							<span class="comment">// 锁定FLASH</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bootloader功能实现"><a class="markdownIt-Anchor" href="#bootloader功能实现"></a> Bootloader功能实现</h2>
<img src="https://s2.loli.net/2025/05/10/NkZvJ52acX16gfT.png" style="zoom:50%;" />
<h3 id="ab分区规划"><a class="markdownIt-Anchor" href="#ab分区规划"></a> AB分区规划</h3>
<p><strong>1个扇页1KB</strong>，A区起始位置：0x 0800 5000， 单片机RAM位置：0x20000000 ~ 0x20004FFF</p>
<table>
<thead>
<tr>
<th style="text-align:center">STM32F103C8T6</th>
<th style="text-align:center">64KB</th>
<th style="text-align:center">扇页</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B区</td>
<td style="text-align:center">20KB</td>
<td style="text-align:center">0 ~ 19</td>
</tr>
<tr>
<td style="text-align:center">A区</td>
<td style="text-align:center">44KB</td>
<td style="text-align:center">20 ~ 63</td>
</tr>
</tbody>
</table>
<h3 id="注意点"><a class="markdownIt-Anchor" href="#注意点"></a> 注意点</h3>
<table>
<thead>
<tr>
<th style="text-align:center">问题</th>
<th style="text-align:center">解答</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>谁将OTA_Flag打勾？</strong></td>
<td style="text-align:center">A区负责控制，标志位存放在24C02</td>
</tr>
<tr>
<td style="text-align:center"><strong>什么时候OTA_flag打勾</strong></td>
<td style="text-align:center">A区下载完毕之后</td>
</tr>
<tr>
<td style="text-align:center"><strong>OTA时，最新版本的程序文件下载到哪？</strong></td>
<td style="text-align:center">分片下载，共计256片塞入W25Q64（一页256Byte，共256页）</td>
</tr>
<tr>
<td style="text-align:center"><strong>OTA时，最新版本的程序文件如何下载？下载多少？</strong></td>
<td style="text-align:center">服务器下发程序大小，分片下载到W25Q64</td>
</tr>
<tr>
<td style="text-align:center"><strong>下载多少这个变量用不用保存？</strong></td>
<td style="text-align:center">需要，保存到24C02之中</td>
</tr>
<tr>
<td style="text-align:center"><strong>发生OTA事件时，B区如何更新A区</strong></td>
<td style="text-align:center">从W25Q64读取数据，写入A区Flash</td>
</tr>
</tbody>
</table>
<h3 id="ota宏定义"><a class="markdownIt-Anchor" href="#ota宏定义"></a> OTA宏定义</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FLASH_SADDR 0x08000000                                     <span class="comment">// FLASH起始地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLASH_PAGE_SIZE 1024                                       <span class="comment">// Flash页大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLASH_NUM 64                                               <span class="comment">// FLASH总页数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLASH_B_NUM 20                                             <span class="comment">// B区页数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLASH_A_NUM FLASH_NUM - FLASH_B_NUM                        <span class="comment">// A区页数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLASH_A_SPAGE FLASH_B_NUM                                  <span class="comment">// A区起始页数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLASH_A_SADDR FLASH_SADDR + FLASH_A_SPAGE *FLASH_PAGE_SIZE <span class="comment">// A区起始地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPDATA_A_FLAG 0x00000001     <span class="comment">// A区更新标志</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IAP_XMODEM_FLAG 0x00000002   <span class="comment">// 使用Xmodem协议的标志</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IAP_XMODEMD_FLAG 0x00000004  <span class="comment">// Xmodem协议传输数据的标志</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_VERSION_FLAG 0x00000008  <span class="comment">// 设置版本号的命令标志</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_5_FLAG 0x000000010       <span class="comment">// 向外部FLASH下载程序的命令标志</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD5_XMODEM_FLAG 0x000000020 <span class="comment">// 标记使用命令5后，Xmodem协议传输</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_6_FLAG 0x000000040       <span class="comment">// 使用外部FLASH内程序</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OTA_SET_FLAG 0xAABBCCDD</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于数组大小是11的原因，一个uint32_t为4位，(1+11)*4=48 Byte，对应24C02存储中每页16Byte，只需要3页就能存储</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> OTA_flag;    			<span class="comment">// OTA标志位</span></span><br><span class="line">    <span class="type">uint32_t</span> FireLen[<span class="number">11</span>]; 			<span class="comment">// 用于存储固件各部分的大小,0号成员固定W25Q64</span></span><br><span class="line">    <span class="type">uint8_t</span> OTA_Ver[<span class="number">32</span>];  			<span class="comment">// 版本号</span></span><br><span class="line">&#125; OTA_CB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> UpDataBuff[FLASH_PAGE_SIZE]; <span class="comment">// 临时存储外部接收的固件数据块</span></span><br><span class="line">    <span class="type">uint32_t</span> W25Q64_BlockNM;             <span class="comment">// 记录当前固件写入哪个块</span></span><br><span class="line">    <span class="type">uint32_t</span> XmodemTimer;                <span class="comment">// 记录延时</span></span><br><span class="line">    <span class="type">uint32_t</span> XmodemNB;                   <span class="comment">// 数据包接收数量</span></span><br><span class="line">    <span class="type">uint32_t</span> XmodemCRC;                  <span class="comment">// 存放CRC校验</span></span><br><span class="line">&#125; UpData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> OTA_CB OTA;</span><br><span class="line"><span class="keyword">extern</span> UpData Updata_A;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OTA_INFO_SIZE sizeof(OTA_CB)</span></span><br></pre></td></tr></table></figure>
<h3 id="ota读取标志位"><a class="markdownIt-Anchor" href="#ota读取标志位"></a> OTA读取标志位</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 读取OTA标志位,判断是否有数据需要更新</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AT24C02_ReadOTA</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;OTA, <span class="number">0</span>, OTA_INFO_SIZE); 	<span class="comment">// 开辟一个OTA_INFO_SIZE大小的地址，初始化为0</span></span><br><span class="line">    <span class="comment">// 从AT24C02读取OTA_INFO_SIZE的数据到结构体中</span></span><br><span class="line">    AT24C02_ReadData(<span class="number">0</span>, (<span class="type">uint8_t</span> *)&amp;OTA, OTA_INFO_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ota保存关键变量到at24c02"><a class="markdownIt-Anchor" href="#ota保存关键变量到at24c02"></a> OTA保存关键变量到AT24C02</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 写入OTA配置到EEPROM</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AT24C02_WriteOTA</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> *pdata = (<span class="type">uint8_t</span> *)&amp;OTA;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; (OTA_INFO_SIZE + <span class="number">7</span>) / <span class="number">8</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		AT24C02_WritePage(i * <span class="number">8</span>, pdata + i * <span class="number">8</span>);</span><br><span class="line">    	delay_ms(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引导更新ota"><a class="markdownIt-Anchor" href="#引导更新ota"></a> 引导更新OTA</h3>
<p><strong>(从下面向上看)</strong></p>
<p><strong>分区跳转</strong>两大关键<strong>SP、PC</strong>设定</p>
<p>Cortex-M3有<strong>R0-R12通用寄存器，R13有MSP（主堆栈指针）和PSP（进程堆栈指针）(保存现场和恢复现场的指针)，R14是LR（连接寄存器，保存子函数之间跳转的返回值），R15是PC（程序计数器）</strong></p>
<ul>
<li>
<p>20(A区起始页) * 1024 = 20480 —&gt; 0x00005000 + 0x08000000 = <strong>0x08005000</strong>，此为A区开始时SP<strong>地址</strong></p>
</li>
<li>
<p>A区起始位置<strong>0x08005000 + 4</strong>(32位的指针是4Byte)，此为A区开始时<strong>PC地址</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RAM ： 0x20000000 ~ 0x20004FFF</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLASH_A_SADDR FLASH_SADDR + FLASH_A_SPAGE * FLASH_PAGE_SIZE <span class="comment">// A区起始地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*load_a)</span><span class="params">(<span class="type">void</span>)</span>; 	<span class="comment">// 回调函数，函数指针，指向一个无参数、无返回值的函数</span></span><br><span class="line">load_a load_A;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于修改主堆栈指针(MSP)</span></span><br><span class="line">__ASM <span class="type">void</span> <span class="title function_">MSR_SP</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;				 				</span><br><span class="line">	MSR MSP, r0;<span class="comment">// MSR指令用于将程序状态寄存器的内容传送到通用寄存器中，R0=addr</span></span><br><span class="line">	BX r14;<span class="comment">// 通过链接寄存器LR(r14)返回调用者，等同于return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转到A区应用程序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LOAD_A</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ((*(<span class="type">uint32_t</span> *)addr &gt;= <span class="number">0x20000000</span>) &amp;&amp; (*(<span class="type">uint32_t</span> *)addr &lt;= <span class="number">0x20004FFF</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 设置A区起始地址,因为MSR_SP函数接收uint32_t的数据，所以先强制转换，再指针取地址</span></span><br><span class="line">		MSR_SP(*(<span class="type">uint32_t</span> *)addr);</span><br><span class="line">		load_A = (load_a) * (<span class="type">uint32_t</span> *)(addr + <span class="number">4</span>); <span class="comment">// 获取复位中断处理程序地址</span></span><br><span class="line">		load_A();									<span class="comment">// 实际执行的是Reset_Handler</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		uprintf(<span class="string">&quot;跳转A分区失败\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引导OTA函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BootLoader_Jump</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 等待20*100ms检测是否进入命令行模式</span></span><br><span class="line">	<span class="keyword">if</span> (BootLoader_Enter(<span class="number">20</span>) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 检查OTA更新标志</span></span><br><span class="line">		<span class="keyword">if</span> (OTA.OTA_flag == OTA_SET_FLAG)</span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;OTA更新 \r\n&quot;</span>);</span><br><span class="line">			BootState |= UPDATA_A_FLAG;	 <span class="comment">// 设置A区更新标志</span></span><br><span class="line">			UpDATA_A.W25Q64_BlockNM = <span class="number">0</span>; <span class="comment">// 默认使用W25Q64的块0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;跳转A分区 \r\n&quot;</span>);</span><br><span class="line">			LOAD_A(FLASH_A_SADDR); <span class="comment">// 跳转到A区应用程序</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	uprintf(<span class="string">&quot;进入BootLoader命令行 \r\n&quot;</span>);</span><br><span class="line">	BootLoader_Info();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 复位外设，没用到</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BootLoader_Clear</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	USART_DeInit(USART1);</span><br><span class="line">	GPIO_DeInit(GPIOA);</span><br><span class="line">	GPIO_DeInit(GPIOB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bootloader事件"><a class="markdownIt-Anchor" href="#bootloader事件"></a> BootLoader事件</h3>
<p><strong>(从上面向下看)</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint32_t</span> BootState; 			<span class="comment">// 系统启动状态标志位</span></span><br><span class="line"><span class="type">uint8_t</span> wdata[<span class="number">2048</span>];</span><br><span class="line"><span class="type">uint8_t</span> rdata[<span class="number">2048</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*	显示BootLoader命令行帮助信息	*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BootLoader_Info</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	uprintf(<span class="string">&quot; \r\n&quot;</span>);</span><br><span class="line">	uprintf(<span class="string">&quot;[1]擦除A区 \r\n&quot;</span>);</span><br><span class="line">	uprintf(<span class="string">&quot;[2]串口IAP下载A区 \r\n&quot;</span>);</span><br><span class="line">	uprintf(<span class="string">&quot;[3]设置OTA版本号 \r\n&quot;</span>);</span><br><span class="line">	uprintf(<span class="string">&quot;[4]查询OTA版本号 \r\n&quot;</span>);</span><br><span class="line">	uprintf(<span class="string">&quot;[5]向外部FLASH下载程序 \r\n&quot;</span>);</span><br><span class="line">	uprintf(<span class="string">&quot;[6]使用外部FLASH内程序 \r\n&quot;</span>);</span><br><span class="line">	uprintf(<span class="string">&quot;[7]重启 \r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*	检测是否进入命令行模式，timeout 超时时间，1-进入命令行，0-不进入	*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">BootLoader_Enter</span><span class="params">(<span class="type">uint8_t</span> timeout)</span></span><br><span class="line">&#123;</span><br><span class="line">	uprintf(<span class="string">&quot;输入小写字母w,进入BootLoader命令行 \r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (timeout--)</span><br><span class="line">	&#123;</span><br><span class="line">		Delay_ms(<span class="number">200</span>);</span><br><span class="line">		<span class="keyword">if</span> (U1_RX_Buff[<span class="number">0</span>] == <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>; 							<span class="comment">// 进入命令行</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; 									<span class="comment">// 不进入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Bootloader事件组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BootLoader_Event</span><span class="params">(<span class="type">uint8_t</span> *data, <span class="type">uint16_t</span> datalen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> temp, i;</span><br><span class="line">	<span class="keyword">if</span> (BootState == <span class="number">0</span>)<span class="comment">// BootState=0：不进行其他操作，显示界面</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((datalen == <span class="number">1</span>) &amp;&amp; (data[<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>))<span class="comment">//	擦除A区</span></span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;[1]擦除A区 \r\n&quot;</span>);</span><br><span class="line">			FLASH_Erase(FLASH_A_SPAGE, FLASH_A_NUM);</span><br><span class="line">			Delay_ms(<span class="number">100</span>);</span><br><span class="line">			BootLoader_Info();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((datalen == <span class="number">1</span>) &amp;&amp; (data[<span class="number">0</span>] == <span class="string">&#x27;2&#x27;</span>))<span class="comment">//	通过Xmodem下载固件到A区</span></span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;通过Xmodem协议,串口IAP下载A区程序,使用bin文件 \r\n&quot;</span>);</span><br><span class="line">			FLASH_Erase(FLASH_A_SPAGE, FLASH_A_NUM);		   <span class="comment">// 擦除目标区域</span></span><br><span class="line">			BootState |= (IAP_XMODEM_FLAG | IAP_XMODEMD_FLAG); <span class="comment">// 设置Xmodem标志</span></span><br><span class="line">			UpDATA_A.XmodemTimer = <span class="number">0</span>;						   <span class="comment">// 重置计时器</span></span><br><span class="line">			UpDATA_A.XmodemNB = <span class="number">0</span>;							   <span class="comment">// 重置数据包计数器</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((datalen == <span class="number">1</span>) &amp;&amp; (data[<span class="number">0</span>] == <span class="string">&#x27;3&#x27;</span>))	<span class="comment">//	设置版本号</span></span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;设置版本号 \r\n&quot;</span>);</span><br><span class="line">			BootState |= SET_VERSION_FLAG;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((datalen == <span class="number">1</span>) &amp;&amp; (data[<span class="number">0</span>] == <span class="string">&#x27;4&#x27;</span>))	<span class="comment">//	查询版本号</span></span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;查询版本号 \r\n&quot;</span>);</span><br><span class="line">			AT24C02_ReadOTA();							</span><br><span class="line">			uprintf(<span class="string">&quot;版本号:%s \r\n&quot;</span>, OTA.OTA_Ver);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((datalen == <span class="number">1</span>) &amp;&amp; (data[<span class="number">0</span>] == <span class="string">&#x27;5&#x27;</span>))	<span class="comment">//向外部FLASH传输程序</span></span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;向外部FLASH传输程序,输入需要使用的块编号(1~9) \r\n&quot;</span>);</span><br><span class="line">			BootState |= CMD_5_FLAG;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((datalen == <span class="number">1</span>) &amp;&amp; (data[<span class="number">0</span>] == <span class="string">&#x27;6&#x27;</span>))	<span class="comment">//使用外部FLASH下载程序</span></span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;使用外部FLASH下载程序,输入需要使用的块编号(1~9) \r\n&quot;</span>);</span><br><span class="line">			BootState |= CMD_6_FLAG;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((datalen == <span class="number">1</span>) &amp;&amp; (data[<span class="number">0</span>] == <span class="string">&#x27;7&#x27;</span>))	<span class="comment">// Reset</span></span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;重启中 \r\n&quot;</span>);</span><br><span class="line">			__set_FAULTMASK(<span class="number">1</span>);</span><br><span class="line">			Delay_ms(<span class="number">100</span>);</span><br><span class="line">			NVIC_SystemReset();							<span class="comment">//NVIC重启</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (BootState &amp; IAP_XMODEMD_FLAG)				<span class="comment">// Xmodem协议数据处理</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 接收数据包（133字节：1个字节+128字节+2CRC+2Byte序号）</span></span><br><span class="line">		<span class="keyword">if</span> ((datalen == <span class="number">133</span>) &amp;&amp; (data[<span class="number">0</span>] == <span class="number">0x01</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			BootState &amp;= ~IAP_XMODEM_FLAG;	</span><br><span class="line">			UpDATA_A.XmodemCRC = Xmodem_CRC16(&amp;data[<span class="number">3</span>], <span class="number">128</span>);<span class="comment">// 计算接收数据的CRC校验值</span></span><br><span class="line">			<span class="keyword">if</span> (UpDATA_A.XmodemCRC == data[<span class="number">131</span>] * <span class="number">256</span> + data[<span class="number">132</span>])	<span class="comment">// 校验通过处理</span></span><br><span class="line">			&#123;</span><br><span class="line">				UpDATA_A.XmodemNB++;<span class="comment">// Xmodem接收数据包增加					</span></span><br><span class="line">				<span class="comment">// 将数据拷贝到缓冲区</span></span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;UpDATA_A.UpDataBuff[((UpDATA_A.XmodemNB - <span class="number">1</span>) % (FLASH_PAGE_SIZE / <span class="number">128</span>)) * <span class="number">128</span>], &amp;data[<span class="number">3</span>], <span class="number">128</span>); </span><br><span class="line">                <span class="comment">//&amp;data[3]：Xmodem包的数据部分从第4字节开始（跳过1字节头+2字节序号）</span></span><br><span class="line">                <span class="comment">//(FLASH_PAGE_SIZE(1024) / 128)计算一页可以存下的包数，对该取模，当超过一页重新计算</span></span><br><span class="line">				<span class="keyword">if</span> ((UpDATA_A.XmodemNB % (FLASH_PAGE_SIZE / <span class="number">128</span>)) == <span class="number">0</span>) <span class="comment">// 1024/128=8，每8个数据包发送一次</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (BootState &amp; CMD5_XMODEM_FLAG)<span class="comment">// 选择写入W25Q64或FLASH</span></span><br><span class="line">					&#123;							</span><br><span class="line">						<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)<span class="comment">// 写入外部W25Q64，每次写入256字节，写4次为一页</span></span><br><span class="line">						&#123;</span><br><span class="line">							W25Q64_PageWrite(&amp;UpDATA_A.UpDataBuff[i * <span class="number">256</span>], </span><br><span class="line">							(UpDATA_A.XmodemNB / <span class="number">8</span> - <span class="number">1</span>) * <span class="number">4</span> + i + UpDATA_A.W25Q64_BlockNM * <span class="number">64</span> * <span class="number">4</span>);</span><br><span class="line">							<span class="comment">//(x/8-1)*4+i,x表示接收到的数据包个数，4表示写入W25Q64的页数,i用来定位页数</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="comment">// FLASH_A_SADDR + ((UpDATA_A.XmodemNB / (FLASH_PAGE_SIZE / 128)) - 1) * FLASH_PAGE_SIZE</span></span><br><span class="line">						<span class="comment">// A区的起始地址+((接收的8个Xmodem协议包 / (一页占据的协议包数量)) -1(索引从0开始) * 当前页偏移地址</span></span><br><span class="line">                        <span class="comment">// 通过Xmodem协议传输的写入到缓冲区的数据</span></span><br><span class="line">						FLASH_Write(FLASH_A_SADDR + ((UpDATA_A.XmodemNB / (FLASH_PAGE_SIZE / <span class="number">128</span>)) - <span class="number">1</span>) * FLASH_PAGE_SIZE,</span><br><span class="line">						(<span class="type">uint32_t</span> *)UpDATA_A.UpDataBuff, FLASH_PAGE_SIZE);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				uprintf(<span class="string">&quot;\x06&quot;</span>); 			<span class="comment">// 表示Xmodem协议包读取成功</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				uprintf(<span class="string">&quot;\x15&quot;</span>); 			<span class="comment">// 表示Xmodem协议包读取失败</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ((datalen == <span class="number">1</span>) &amp;&amp; (data[<span class="number">0</span>] == <span class="number">0x04</span>)) 					<span class="comment">// 读取Xmodem协议包剩余的数据</span></span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;\x06&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> ((UpDATA_A.XmodemNB % (FLASH_PAGE_SIZE / <span class="number">128</span>)) != <span class="number">0</span>) <span class="comment">// 如果有剩余的数据</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (BootState &amp; CMD5_XMODEM_FLAG)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">					&#123;</span><br><span class="line">						W25Q64_PageWrite(&amp;UpDATA_A.UpDataBuff[i * <span class="number">256</span>],</span><br><span class="line">						(UpDATA_A.XmodemNB / <span class="number">8</span>) * <span class="number">4</span> + i + UpDATA_A.W25Q64_BlockNM * <span class="number">64</span> * <span class="number">4</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					FLASH_Write(FLASH_A_SADDR + ((UpDATA_A.XmodemNB / (FLASH_PAGE_SIZE / <span class="number">128</span>))) * FLASH_PAGE_SIZE,</span><br><span class="line">					(<span class="type">uint32_t</span> *)UpDATA_A.UpDataBuff,</span><br><span class="line">					(UpDATA_A.XmodemNB % (FLASH_PAGE_SIZE / <span class="number">128</span>)) * <span class="number">128</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			BootState &amp;= ~IAP_XMODEMD_FLAG;</span><br><span class="line">			<span class="keyword">if</span> (BootState &amp; CMD5_XMODEM_FLAG) 		<span class="comment">// 将数据下载到W25Q64</span></span><br><span class="line">			&#123;</span><br><span class="line">				BootState &amp;= ~CMD5_XMODEM_FLAG;		<span class="comment">// 将标志位复位</span></span><br><span class="line">				OTA.FireLen[UpDATA_A.W25Q64_BlockNM] = UpDATA_A.XmodemNB * <span class="number">128</span>; <span class="comment">// 将Xmodem数据存入W25Q64中</span></span><br><span class="line">				AT24C02_WriteOTA();					<span class="comment">// 存储数据,掉电不丢失</span></span><br><span class="line">				Delay_ms(<span class="number">100</span>);</span><br><span class="line">				BootLoader_Info();					<span class="comment">//重新显示命令行</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				__set_FAULTMASK(<span class="number">1</span>); 				<span class="comment">// 关闭所有中断</span></span><br><span class="line">				Delay_ms(<span class="number">100</span>);</span><br><span class="line">				NVIC_SystemReset(); 				<span class="comment">// 程序重启</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (BootState &amp; SET_VERSION_FLAG) 		<span class="comment">// 设置版本号</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (datalen &lt;= <span class="number">32</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">sscanf</span>((<span class="type">const</span> <span class="type">char</span> *)data, <span class="string">&quot;VER-%d.%d.%d-%d/%d/%d-%d:%d&quot;</span>, &amp;temp, &amp;temp, &amp;temp, &amp;temp, &amp;temp, &amp;temp, &amp;temp, &amp;temp) == <span class="number">8</span>)</span><br><span class="line">			&#123;								   <span class="comment">// VER-1.0.0-2025/5/1-10:28</span></span><br><span class="line">				<span class="built_in">memset</span>(OTA.OTA_Ver, <span class="number">0</span>, <span class="number">32</span>);	   <span class="comment">// 将之前的版本号清零</span></span><br><span class="line">				<span class="built_in">memcpy</span>(OTA.OTA_Ver, data, <span class="number">32</span>); <span class="comment">// 填入新的版本号</span></span><br><span class="line">				AT24C02_WriteOTA();			   <span class="comment">// 写入掉电不丢失芯片</span></span><br><span class="line">				uprintf(<span class="string">&quot;版本号正确 \r\n&quot;</span>);</span><br><span class="line">				BootLoader_Info();</span><br><span class="line">				BootState &amp;= ~SET_VERSION_FLAG; <span class="comment">// 使用完复位标志位</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				uprintf(<span class="string">&quot;版本号格式错误 \r\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;版本号长度错误 \r\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (BootState &amp; CMD_5_FLAG)			<span class="comment">// 将bin程序传入W25Q64的第%d个块</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (datalen == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> ((data[<span class="number">0</span>] &gt;= <span class="number">0x31</span>) &amp;&amp; (data[<span class="number">0</span>] &lt;= <span class="number">0x39</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				UpDATA_A.W25Q64_BlockNM = data[<span class="number">0</span>] - <span class="number">0x30</span>; 	<span class="comment">// 字符转换数字</span></span><br><span class="line">				BootState |= (IAP_XMODEM_FLAG | IAP_XMODEMD_FLAG | CMD5_XMODEM_FLAG);<span class="comment">//加上XMODEM的标志位</span></span><br><span class="line">				UpDATA_A.XmodemTimer = <span class="number">0</span>;					<span class="comment">// 清空定时器</span></span><br><span class="line">				UpDATA_A.XmodemNB = <span class="number">0</span>;						<span class="comment">// 清空发送的包数</span></span><br><span class="line">				OTA.FireLen[UpDATA_A.W25Q64_BlockNM] = <span class="number">0</span>;	<span class="comment">// 置零表示清空数据</span></span><br><span class="line">				W25Q64_Erase_64k(UpDATA_A.W25Q64_BlockNM);	<span class="comment">// 擦除整块</span></span><br><span class="line">				uprintf(<span class="string">&quot;通过Xmodem协议,向外部FLASH第%d个块传输程序,使用bin文件 \r\n&quot;</span>, UpDATA_A.W25Q64_BlockNM);</span><br><span class="line">				BootState &amp;= ~CMD_5_FLAG;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				uprintf(<span class="string">&quot;编号错误 \r\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;数据长度错误 \r\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (BootState &amp; CMD_6_FLAG) 						<span class="comment">// 使用W25Q64保存的APP程序</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (datalen == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> ((data[<span class="number">0</span>] &gt;= <span class="number">0x31</span>) &amp;&amp; (data[<span class="number">0</span>] &lt;= <span class="number">0x39</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				UpDATA_A.W25Q64_BlockNM = data[<span class="number">0</span>] - <span class="number">0x30</span>; 		<span class="comment">// 字符转换数字</span></span><br><span class="line">				BootState |= UPDATA_A_FLAG;				  <span class="comment">// A区更新标志</span></span><br><span class="line">				BootState &amp;= ~CMD_6_FLAG;				  <span class="comment">// 将命令6标志置位</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				uprintf(<span class="string">&quot;编号错误 \r\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;长度错误 \r\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主程序"><a class="markdownIt-Anchor" href="#主程序"></a> 主程序</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 需要用到的功能：串口，SPI，FLASH</span></span><br><span class="line"><span class="type">uint32_t</span> BootState; 	<span class="comment">// 系统启动状态标志位</span></span><br><span class="line"><span class="type">uint8_t</span> wdata[<span class="number">2048</span>];</span><br><span class="line"><span class="type">uint8_t</span> rdata[<span class="number">2048</span>];</span><br><span class="line"><span class="keyword">extern</span> OTA_CB OTA;</span><br><span class="line"><span class="keyword">extern</span> UpData UpDATA_A;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint32_t</span> BootState;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> i;</span><br><span class="line">	USART1_Init(<span class="number">921600</span>); 	<span class="comment">// 初始化串口1，波特率921600</span></span><br><span class="line">	Delay_Init();		 <span class="comment">// 初始化延时函数</span></span><br><span class="line">	I2C1_Init();		 <span class="comment">// 初始化I2C1（用于AT24C02通信）</span></span><br><span class="line">	AT24C02_ReadOTA();	 <span class="comment">// 从AT24C02读取OTA标志位</span></span><br><span class="line">	W25Q64_Init();		 <span class="comment">// 初始化W25Q64（SPI Flash）</span></span><br><span class="line">	BootLoader_Jump();	 <span class="comment">// 检查是否需要跳转到BootLoader</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Delay_ms(<span class="number">10</span>); <span class="comment">// 主循环延时10ms</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 串口1处理缓冲区数据</span></span><br><span class="line">		<span class="keyword">if</span> (U1CB.URxDataOUT != U1CB.URxDataIN)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 处理接收到的数据（Xmodem协议或其他指令）</span></span><br><span class="line">			BootLoader_Event(U1CB.URxDataOUT-&gt;start, U1CB.URxDataOUT-&gt;end - U1CB.URxDataOUT-&gt;start + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">// 移动接收缓冲区指针</span></span><br><span class="line">			U1CB.URxDataOUT++;</span><br><span class="line">			<span class="keyword">if</span> (U1CB.URxDataOUT == U1CB.URxDataEND)</span><br><span class="line">			&#123;</span><br><span class="line">				U1CB.URxDataOUT = &amp;U1CB.URxDataPtr[<span class="number">0</span>]; <span class="comment">// 环形缓冲区回卷</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 检查是否需要发送Xmodem协议的控制字符&#x27;C&#x27;</span></span><br><span class="line">		<span class="keyword">if</span> (BootState &amp; IAP_XMODEM_FLAG)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (UpDATA_A.XmodemTimer &gt;= <span class="number">100</span>) 	<span class="comment">// 每100次循环发送一次&#x27;C&#x27;</span></span><br><span class="line">			&#123;</span><br><span class="line">				uprintf(<span class="string">&quot;C&quot;</span>); 				<span class="comment">// 发送Xmodem起始信号</span></span><br><span class="line">				UpDATA_A.XmodemTimer = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			UpDATA_A.XmodemTimer++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检查是否需要更新A区固件</span></span><br><span class="line">		<span class="keyword">if</span> (BootState &amp; UPDATA_A_FLAG)</span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;长度%d字节\r\n&quot;</span>, OTA.FireLen[UpDATA_A.W25Q64_BlockNM]);</span><br><span class="line">			<span class="comment">// 擦除目标FLASH区域(A区)</span></span><br><span class="line">			FLASH_Erase(FLASH_A_SPAGE, FLASH_A_NUM);</span><br><span class="line">			uprintf(<span class="string">&quot;A区已擦除 \r\n&quot;</span>);</span><br><span class="line">			<span class="comment">// 检查固件长度是否为4的倍数</span></span><br><span class="line">			<span class="keyword">if</span> (OTA.FireLen[UpDATA_A.W25Q64_BlockNM] % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 按1KB页循环写入完整数据块</span></span><br><span class="line">				<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (OTA.FireLen[UpDATA_A.W25Q64_BlockNM] / <span class="number">1024</span>); i++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">// 从W25Q64读取1KB数据到缓冲区</span></span><br><span class="line">                    			<span class="comment">// 源地址：块号×64KB + 偏移量， 读取长度=1KB</span></span><br><span class="line">					W25Q64_Read(UpDATA_A.UpDataBuff, i * FLASH_PAGE_SIZE + <span class="number">64</span> * <span class="number">1024</span> * UpDATA_A.W25Q64_BlockNM, FLASH_PAGE_SIZE);</span><br><span class="line">					<span class="comment">// 将1KB数据写入FLASH（目标地址递增）</span></span><br><span class="line">                    <span class="comment">// 目标地址</span></span><br><span class="line">                    <span class="comment">// 数据指针（强制转换为uint32_t*）</span></span><br><span class="line">                    <span class="comment">// 写入长度=1KB</span></span><br><span class="line">					FLASH_Write(FLASH_A_SADDR + i * FLASH_PAGE_SIZE, (<span class="type">uint32_t</span> *)UpDATA_A.UpDataBuff, FLASH_PAGE_SIZE);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 处理剩余不足1KB的数据</span></span><br><span class="line">				<span class="keyword">if</span> (OTA.FireLen[UpDATA_A.W25Q64_BlockNM] % <span class="number">1024</span> != <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">memset</span>(UpDATA_A.UpDataBuff, <span class="number">0</span>, FLASH_PAGE_SIZE);</span><br><span class="line">					<span class="comment">// 读取剩余数据</span></span><br><span class="line">                    <span class="comment">// 剩余数据的起始地址，剩余数据长度</span></span><br><span class="line">					W25Q64_Read(UpDATA_A.UpDataBuff, i * FLASH_PAGE_SIZE + <span class="number">64</span> * <span class="number">1024</span> * UpDATA_A.W25Q64_BlockNM,</span><br><span class="line">					OTA.FireLen[UpDATA_A.W25Q64_BlockNM] % <span class="number">1024</span>);</span><br><span class="line">                    </span><br><span class="line">					<span class="comment">// 写入剩余数据到FLASH</span></span><br><span class="line">					FLASH_Write(FLASH_A_SADDR + i * FLASH_PAGE_SIZE, (<span class="type">uint32_t</span> *)UpDATA_A.UpDataBuff, OTA.FireLen[UpDATA_A.W25Q64_BlockNM] % <span class="number">1024</span>);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// OTA更新后，UpDATA_A.W25Q64_BlockNM == 0</span></span><br><span class="line">				<span class="keyword">if</span> (UpDATA_A.W25Q64_BlockNM == <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					OTA.OTA_flag = <span class="number">0</span>;				<span class="comment">// 清除OTA标志</span></span><br><span class="line">					AT24C02_WriteOTA(); 			<span class="comment">// 更新后写入AT24C02（持久化存储）</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 重启</span></span><br><span class="line">				uprintf(<span class="string">&quot; \r\nA区更新完毕 \r\n&quot;</span>);</span><br><span class="line">				__set_FAULTMASK(<span class="number">1</span>); <span class="comment">// 屏蔽所有异常</span></span><br><span class="line">				Delay_ms(<span class="number">100</span>);</span><br><span class="line">				NVIC_SystemReset(); <span class="comment">// 系统复位</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				uprintf(<span class="string">&quot;长度错误\r\n&quot;</span>);	 <span class="comment">// 数据长度未对齐</span></span><br><span class="line">				BootState &amp;= ~UPDATA_A_FLAG; <span class="comment">// 清除更新标志</span></span><br><span class="line">				BootLoader_Info();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="xmodem协议"><a class="markdownIt-Anchor" href="#xmodem协议"></a> Xmodem协议</h1>
<p><strong>Xmodem使用SecureCRTP</strong>软件配置连接串口通信，它相较于Ymodem的区别是具有更小的Package长度</p>
<h2 id="格式"><a class="markdownIt-Anchor" href="#格式"></a> 格式</h2>
<table>
<thead>
<tr>
<th style="text-align:center">Byte1</th>
<th style="text-align:center">Byte2</th>
<th style="text-align:center">Byte3</th>
<th style="text-align:center">Byte4 ~ Byte131</th>
<th style="text-align:center">Byte132 ~ Byte133</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Start of Header(SOH)</td>
<td style="text-align:center">Packet Number</td>
<td style="text-align:center">~(Packet Number)</td>
<td style="text-align:center">Pcacket Data</td>
<td style="text-align:center">CRC16 Check</td>
</tr>
</tbody>
</table>
<h2 id="指令"><a class="markdownIt-Anchor" href="#指令"></a> 指令</h2>
<table>
<thead>
<tr>
<th style="text-align:center">位</th>
<th style="text-align:center">指令</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SOH</td>
<td style="text-align:center">0x01</td>
<td style="text-align:center">128字节数据包帧头</td>
</tr>
<tr>
<td style="text-align:center">STX</td>
<td style="text-align:center">0x02</td>
<td style="text-align:center">1024字节数据包帧头</td>
</tr>
<tr>
<td style="text-align:center">EOT</td>
<td style="text-align:center">0x04</td>
<td style="text-align:center">结束传输</td>
</tr>
<tr>
<td style="text-align:center">ACK</td>
<td style="text-align:center">0x06</td>
<td style="text-align:center">正确应答</td>
</tr>
<tr>
<td style="text-align:center">NAK</td>
<td style="text-align:center">0x15</td>
<td style="text-align:center">错误应答，重传数据</td>
</tr>
<tr>
<td style="text-align:center">CAN</td>
<td style="text-align:center">0x18</td>
<td style="text-align:center">取消传输</td>
</tr>
<tr>
<td style="text-align:center">CTRLZ</td>
<td style="text-align:center">0x1A</td>
<td style="text-align:center">数据填充</td>
</tr>
<tr>
<td style="text-align:center">HSC</td>
<td style="text-align:center">0x43</td>
<td style="text-align:center">握手</td>
</tr>
</tbody>
</table>
<h2 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">‘C’											<span class="comment">// 发送一个C等待数据包</span></span><br><span class="line">											<span class="comment">// (3s一次，等待应答)</span></span><br><span class="line">SOH | <span class="number">0x01</span> | <span class="number">0xFE</span> | Data[<span class="number">0</span>~<span class="number">127</span>] | CRC16		<span class="comment">// 第一条指令</span></span><br><span class="line">ACK（正确应答）</span><br><span class="line">SOH | <span class="number">0x02</span> | <span class="number">0xFD</span> | Data[<span class="number">0</span>~<span class="number">127</span>] | CRC16		<span class="comment">// 第二条指令</span></span><br><span class="line">NAK（错误应答）</span><br><span class="line">SOH | <span class="number">0x02</span> | <span class="number">0xFD</span> | Data[<span class="number">0</span>~<span class="number">127</span>] | CRC16		<span class="comment">// 第二条指令</span></span><br><span class="line">ACK</span><br><span class="line">SOH | <span class="number">0x03</span> | <span class="number">0xFC</span> | Data[<span class="number">0</span>~<span class="number">127</span>] | CRC16		<span class="comment">// 第三条指令</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h2 id="crc16程序"><a class="markdownIt-Anchor" href="#crc16程序"></a> CRC16程序</h2>
<p>STM32支持CRC32，不支持CRC16，需要自己写</p>
<p>多项式p(x) = <strong>x^16 + x^12 + x^5 + 1</strong>，借助多项式将输入的数值进行<strong>模2除法</strong>，在C语言中是进行<strong>异或运算</strong>^。</p>
<p><img src="https://s2.loli.net/2025/05/09/V1B2YkysPQZipdg.png" alt="" /></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文字说明</span></span><br><span class="line">寄存器清零</span><br><span class="line">数据最右边补齐W位<span class="number">0</span> 							<span class="comment">// W是CRC校验值的位数</span></span><br><span class="line">when(还有数据)&#123;</span><br><span class="line">    左移寄存器<span class="number">1</span>位，读取数据的下一位到寄存器的bit <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (左移寄存器时出现溢出)&#123;</span><br><span class="line">        寄存器 ^= poly;    				<span class="comment">// 这里的poly=0011，按照上面的例子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">寄存器的值就是校验值</span><br><span class="line">    </span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">Xmodem_CRC16</span><span class="params">(<span class="type">uint8_t</span> *data, <span class="type">uint16_t</span> datalen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> i;</span><br><span class="line">	<span class="type">uint16_t</span> Crcinit = <span class="number">0x0000</span>; 	<span class="comment">// 初始化为0</span></span><br><span class="line">	<span class="type">uint16_t</span> Poly = <span class="number">0x1021</span>;	   	<span class="comment">// XMODEM 使用的多项式：x^16 + x^12 + x^5 + 1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (datalen--)</span><br><span class="line">	&#123;</span><br><span class="line">		Crcinit = (*data &lt;&lt; <span class="number">8</span>) ^ Crcinit;</span><br><span class="line">		<span class="comment">// 左移八位是因为CRC是高位优先计算，异或是为了改变当前CRC的值</span></span><br><span class="line">		<span class="comment">// 异或将新数据“混合”进当前的CRC值，使CRC计算能覆盖所有输入数据</span></span><br><span class="line">		<span class="comment">// 若直接赋值会丢失之前计算的CRC值</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) <span class="comment">// 每个bit都要影响CRC计算，所以必须循环 8 次</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (Crcinit &amp; <span class="number">0x8000</span>) 	<span class="comment">// 检查最高位是否为1</span></span><br><span class="line">				Crcinit = (Crcinit &lt;&lt; <span class="number">1</span>) ^ Poly;</span><br><span class="line">			<span class="comment">// 如果最高位是1，说明当前的CRC值已经达到或超过多项式的最高位(Poly最高位为0x1000)</span></span><br><span class="line">			<span class="comment">// 必须减去多项(即^Poly)否则CRC值会越来越大</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				Crcinit = (Crcinit &lt;&lt; <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		data++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Crcinit;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<p><a href="https://github.com/havenxie/stm32-iap-uart-boot">havenxie/stm32-iap-uart-boot: STM32 IAP(UART模式)的BOOT部分</a></p>
<p><a href="https://www.bilibili.com/video/BV1SatHeBEVG/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click">【手把手教程 4G通信物联网 OTA远程升级 BootLoader程序设计】GD32F103C8T6单片机【上篇章】_哔哩哔哩_bilibili</a></p>
<h1 id="补充724"><a class="markdownIt-Anchor" href="#补充724"></a> 补充（7.24）</h1>
<h2 id="bootloader执行流程"><a class="markdownIt-Anchor" href="#bootloader执行流程"></a> Bootloader执行流程</h2>
<ol>
<li>
<p><strong>上电或复位</strong></p>
<ul>
<li>当系统上电或复位时，处理器从一个固定的地址开始执行，这个地址称为 <strong>向量表（Vector Table）</strong> 的起始地址。</li>
</ul>
</li>
<li>
<p><strong>读取向量表地址（比如 Flash 起始地址）</strong></p>
<ul>
<li>默认情况下，ARM Cortex-M 处理器会从地址 <strong>0x08000000</strong>（即 Flash 起始地址）读取：
<ul>
<li><code>0x08000000</code>：初始 <strong>MSP（Main Stack Pointer）</strong></li>
<li><code>0x08000004</code>：<strong>Reset Handler 的地址</strong>，也就是主程序的入口点</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>设置 MSP</strong></p>
</li>
</ol>
<ul>
<li>处理器将 <code>0x08000000</code> 处的值加载到 MSP（Main Stack Pointer），为堆栈初始化。</li>
</ul>
<ol start="4">
<li><strong>跳转到 Reset Handler</strong>
<ul>
<li>处理器将 <code>0x08000004</code> 处的值作为程序计数器 PC，开始执行实际程序。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置主栈指针</span></span><br><span class="line">__ASM <span class="type">void</span> <span class="title function_">MSR_SP</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	MSR MSP, r0;</span><br><span class="line">	BX r14;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转到A区应用程序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LOAD_A</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>((*(<span class="type">uint32_t</span> *)addr &gt;= <span class="number">0x20000000</span>) &amp;&amp; (*(<span class="type">uint32_t</span> *)addr &lt;= <span class="number">0x20004FFF</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		MSR_SP(*(<span class="type">uint32_t</span> *)addr);</span><br><span class="line">		load_A = (load_a)*(<span class="type">uint32_t</span> *)(addr + <span class="number">4</span>);</span><br><span class="line">		load_A();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		uprintf(<span class="string">&quot;Failed to jump to Area A \r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sram在此的意义"><a class="markdownIt-Anchor" href="#sram在此的意义"></a> SRAM在此的意义</h2>
<ul>
<li>
<p>SRAM（Static RAM）是 MCU 的运行内存（RAM），栈、全局变量、局部变量都存放在这里。</p>
</li>
<li>
<p>MSP 指针一般会指向 SRAM 的顶端（例如 <code>0x20000000</code>），向下增长。</p>
</li>
<li>
<p>应用程序运行期间所有动态数据、堆栈帧等都存在于 SRAM 中。</p>
</li>
</ul>
<h2 id="app程序配置"><a class="markdownIt-Anchor" href="#app程序配置"></a> APP程序配置</h2>
<ol>
<li>
<p>system_stm32f10x.c文件中的VECT_TAB_OFFSET，设置0x5000</p>
</li>
<li>
<p>配置Target</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2025/07/24/r9UhFepacuX4bDy.png" alt="" /></p>
<h2 id="dma配置rx_buffer-1配合idle实现接收不定长数据"><a class="markdownIt-Anchor" href="#dma配置rx_buffer-1配合idle实现接收不定长数据"></a> DMA配置RX_BUFFER + 1配合IDLE实现接收不定长数据</h2>
<ol>
<li>
<p><strong>DMA设置</strong>：传输计数为RX_BUFFER + 1</p>
</li>
<li>
<p><strong>IDLE触发</strong>：当接收数据长度小于设置计数时触发</p>
</li>
<li>
<p><strong>长度计算</strong>：通过剩余计数计算实际接收长度</p>
</li>
<li>
<p><strong>重新配置</strong>：每次IDLE中断后重新配置DMA</p>
</li>
</ol>
<h2 id="为什么dma不使用循环模式而是普通模式"><a class="markdownIt-Anchor" href="#为什么dma不使用循环模式而是普通模式"></a> 为什么DMA不使用循环模式，而是普通模式</h2>
<p>DMA如果<strong>使用循环模式</strong>，会自动循环使用同一个缓冲区，<strong>无法区分不同数据包的边界</strong>，数据会覆盖，无法实现数据包管理；而使用<strong>普通模式+IDLE</strong>，可以<strong>准确计算每个数据包的长度</strong>。</p>
<ul>
<li>
<p>数据包边界识别</p>
</li>
<li>
<p>内存管理灵活性</p>
</li>
<li>
<p>数据长度计算</p>
</li>
<li>
<p>数据包队列</p>
</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>ESP32S3学习笔记</title>
    <url>/2025/01/12/ESP32S3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>主要学习立创<strong>ESP32S3 N16R8</strong>的基本配置以及其各部件组成</p>
<h1 id="组成结构"><a class="markdownIt-Anchor" href="#组成结构"></a> 组成结构</h1>
<img src="https://s2.loli.net/2025/05/08/1dog3h8nKRCOMPW.png" style="zoom: 50%;" />
<img src="https://s2.loli.net/2025/05/08/DCTorxL4l6cPMYz.png" style="zoom:50%;" />
<table>
<thead>
<tr>
<th style="text-align:center">类别</th>
<th style="text-align:center">型号</th>
<th style="text-align:center">参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">模组</td>
<td style="text-align:center"><strong>ESP32-S3-WROOM-1-N16R8</strong></td>
<td style="text-align:center">搭载 Xtensa® 32 位 LX7 双核处理器，主频高达 <strong>240 MHz</strong>，内置<strong>SRAM 512kB</strong>，外置<strong>PSRAM 8MB</strong>，外置<strong>FLASH 16MB</strong>，2.4 GHz Wi-Fi (802.11 b/g/n) 40MHz带宽，Bluetooth 5 (LE) 和 Bluetooth Mesh，集成AI向量指令，加速神经网络计算和信号处理</td>
</tr>
<tr>
<td style="text-align:center">显示屏</td>
<td style="text-align:center"><strong>ST7789</strong></td>
<td style="text-align:center">2.0寸、IPS全视角、分辨率320*240、<strong>SPI接口</strong></td>
</tr>
<tr>
<td style="text-align:center">触摸屏</td>
<td style="text-align:center"><strong>FT6336</strong></td>
<td style="text-align:center">电容触摸、<strong>I2C接口</strong></td>
</tr>
<tr>
<td style="text-align:center">姿态传感器</td>
<td style="text-align:center"><strong>QMI8658</strong></td>
<td style="text-align:center">三轴加速度+三轴陀螺仪、<strong>I2C接口</strong></td>
</tr>
<tr>
<td style="text-align:center">音频DAC</td>
<td style="text-align:center"><strong>ES8311</strong></td>
<td style="text-align:center">单通道、<strong>I2C接口</strong></td>
</tr>
<tr>
<td style="text-align:center">音频ADC</td>
<td style="text-align:center"><strong>ES7210</strong></td>
<td style="text-align:center">四通道(开发板用三个通道)、<strong>I2C接口</strong></td>
</tr>
<tr>
<td style="text-align:center">音频功放</td>
<td style="text-align:center">NS4150B</td>
<td style="text-align:center">单声道D类音频放大器</td>
</tr>
<tr>
<td style="text-align:center">麦克风</td>
<td style="text-align:center">ZTS6216</td>
<td style="text-align:center">配套双路麦克风、模拟输出</td>
</tr>
<tr>
<td style="text-align:center">喇叭</td>
<td style="text-align:center">DB1811AB50</td>
<td style="text-align:center">1811音腔喇叭、1W</td>
</tr>
<tr>
<td style="text-align:center">USB HUB</td>
<td style="text-align:center">CH334F</td>
<td style="text-align:center">USB2.0 HUB</td>
</tr>
<tr>
<td style="text-align:center">USB转串口</td>
<td style="text-align:center">CH340K</td>
<td style="text-align:center">波特率最大2Mbps</td>
</tr>
<tr>
<td style="text-align:center">电源芯片</td>
<td style="text-align:center">SY8088AAC</td>
<td style="text-align:center">提供双路、每路1A</td>
</tr>
<tr>
<td style="text-align:center">GH1.25接口</td>
<td style="text-align:center"></td>
<td style="text-align:center">两路外拓传感器接口，可以给外部传感器供电5V和3.3V，可以作为GPIO、CAN、I2C、UART、PWM等接口</td>
</tr>
<tr>
<td style="text-align:center">TF卡接口</td>
<td style="text-align:center"></td>
<td style="text-align:center">采用1-SD模式与ESP32连接</td>
</tr>
<tr>
<td style="text-align:center">Type-C接口</td>
<td style="text-align:center"></td>
<td style="text-align:center">用于供电、程序下载、程序调试，以及USB数据通信</td>
</tr>
<tr>
<td style="text-align:center">按键</td>
<td style="text-align:center"></td>
<td style="text-align:center">一个复位按键、一个用户自定义按键</td>
</tr>
</tbody>
</table>
<h1 id="基础外设"><a class="markdownIt-Anchor" href="#基础外设"></a> 基础外设</h1>
<h2 id="按键key"><a class="markdownIt-Anchor" href="#按键key"></a> 按键Key</h2>
<h3 id="样例"><a class="markdownIt-Anchor" href="#样例"></a> 样例</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;inttypes.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/FreeRTOS.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/task.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;freertos/queue.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;driver/gpio.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> QueueHandle_t gpio_evt_queue = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> IRAM_ATTR <span class="title function_">gpio_isr_handler</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> gpio_num = (<span class="type">uint32_t</span>) arg;</span><br><span class="line">    xQueueSendFromISR(gpio_evt_queue, &amp;gpio_num, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">gpio_task_example</span><span class="params">(<span class="type">void</span>* arg)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> io_num;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        <span class="keyword">if</span>(xQueueReceive(gpio_evt_queue, &amp;io_num, portMAX_DELAY)) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;GPIO[%&quot;</span>PRIu32<span class="string">&quot;] intr, val: %d\n&quot;</span>, io_num, gpio_get_level(io_num));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">gpio_config_t</span> io_conf = &#123;</span><br><span class="line">        .intr_type = GPIO_INTR_NEGEDGE, <span class="comment">//falling edge interrupt</span></span><br><span class="line">        .mode = GPIO_MODE_INPUT, <span class="comment">//set as input mode</span></span><br><span class="line">        .pin_bit_mask = <span class="number">1</span>&lt;&lt;GPIO_NUM_0, <span class="comment">//bit mask of the pins GPIO0</span></span><br><span class="line">        .pull_down_en = <span class="number">0</span>, <span class="comment">//disable pull-down mode</span></span><br><span class="line">        .pull_up_en = <span class="number">1</span> <span class="comment">//enable pull-up mode</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//configure GPIO with the given settings</span></span><br><span class="line">    gpio_config(&amp;io_conf);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//create a queue to handle gpio event from isr</span></span><br><span class="line">    gpio_evt_queue = xQueueCreate(<span class="number">10</span>, <span class="keyword">sizeof</span>(<span class="type">uint32_t</span>));</span><br><span class="line">    <span class="comment">//start gpio task</span></span><br><span class="line">    xTaskCreate(gpio_task_example, <span class="string">&quot;gpio_task_example&quot;</span>, <span class="number">2048</span>, <span class="literal">NULL</span>, <span class="number">10</span>, <span class="literal">NULL</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//install gpio isr service</span></span><br><span class="line">    gpio_install_isr_service(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//hook isr handler for specific gpio pin</span></span><br><span class="line">    gpio_isr_handler_add(GPIO_NUM_0, gpio_isr_handler, (<span class="type">void</span>*) GPIO_NUM_0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="姿态传感器qmi8658"><a class="markdownIt-Anchor" href="#姿态传感器qmi8658"></a> 姿态传感器（QMI8658）</h2>
<p>I2C控制，地址<strong>QMI8658_SENSOR_ADDR= 0x6A</strong></p>
<p>内部集成 3 轴加速度传感器和 3 轴陀螺仪传感器，支持 <strong>SPI 和 I2C</strong> 通信</p>
<p><strong>I2C的频率</strong>为<strong>100000</strong></p>
<p>BSP_I2C_NUM为0</p>
<table>
<thead>
<tr>
<th style="text-align:center">说明</th>
<th style="text-align:center">PIN</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">I2C_SCL</td>
<td style="text-align:center">GPIO_NUM_1</td>
</tr>
<tr>
<td style="text-align:center">I2C_SDA</td>
<td style="text-align:center">GPIO_NUM_2</td>
</tr>
</tbody>
</table>
<p><strong>计算倾斜角度</strong>（四元法）</p>
<p><img src="https://s2.loli.net/2025/05/08/lGz1Uq5tER89fs4.png" alt="" /></p>
<p><strong>配置qmi8658</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>  QMI8658_SENSOR_ADDR       0x6A</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">qmi8658_reg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QMI8658_WHO_AM_I,</span><br><span class="line">    ......</span><br><span class="line">    QMI8658_I2CM_STATUS = <span class="number">44</span>,</span><br><span class="line">    ......</span><br><span class="line">    QMI8658_dQW_L = <span class="number">73</span>,</span><br><span class="line">    ......</span><br><span class="line">    QMI8658_RESET = <span class="number">96</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line"><span class="type">void</span> qmi8658_init(<span class="type">void</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> id = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    qmi8658_register_read(QMI8658_WHO_AM_I, &amp;id ,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (id != <span class="number">0x05</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        vTaskDelay(<span class="number">1000</span> / portTICK_PERIOD_MS);</span><br><span class="line">        qmi8658_register_read(QMI8658_WHO_AM_I, &amp;id ,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;QMI8658 OK!&quot;</span>);</span><br><span class="line"></span><br><span class="line">    qmi8658_register_write_byte(QMI8658_RESET, <span class="number">0xb0</span>);  <span class="comment">// 复位</span></span><br><span class="line">    vTaskDelay(<span class="number">10</span> / portTICK_PERIOD_MS);</span><br><span class="line">    qmi8658_register_write_byte(QMI8658_CTRL1, <span class="number">0x40</span>); <span class="comment">// CTRL1 设置地址自动增加</span></span><br><span class="line">    qmi8658_register_write_byte(QMI8658_CTRL7, <span class="number">0x03</span>); <span class="comment">// CTRL7 允许加速度和陀螺仪</span></span><br><span class="line">    qmi8658_register_write_byte(QMI8658_CTRL2, <span class="number">0x95</span>); <span class="comment">// CTRL2 设置ACC 4g 250Hz</span></span><br><span class="line">    qmi8658_register_write_byte(QMI8658_CTRL3, <span class="number">0xd5</span>); <span class="comment">// CTRL3 设置GRY 512dps 250Hz</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读操作</span></span><br><span class="line"><span class="type">esp_err_t</span> <span class="title function_">qmi8658_register_read</span><span class="params">(<span class="type">uint8_t</span> reg_addr, <span class="type">uint8_t</span> *data, <span class="type">size_t</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> i2c_master_write_read_device(BSP_I2C_NUM, QMI8658_SENSOR_ADDR,  &amp;reg_addr, <span class="number">1</span>, data, len, <span class="number">1000</span> / portTICK_PERIOD_MS);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写操作</span></span><br><span class="line"><span class="type">esp_err_t</span> <span class="title function_">qmi8658_register_write_byte</span><span class="params">(<span class="type">uint8_t</span> reg_addr, <span class="type">uint8_t</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> write_buf[<span class="number">2</span>] = &#123;reg_addr, data&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> i2c_master_write_to_device(BSP_I2C_NUM, QMI8658_SENSOR_ADDR, write_buf, <span class="keyword">sizeof</span>(write_buf), <span class="number">1000</span> / portTICK_PERIOD_MS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>求取姿态数值</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">int16_t</span> acc_y;</span><br><span class="line">    <span class="type">int16_t</span> acc_x;</span><br><span class="line">    <span class="type">int16_t</span> acc_z;</span><br><span class="line">    <span class="type">int16_t</span> gyr_y;</span><br><span class="line">    <span class="type">int16_t</span> gyr_x;</span><br><span class="line">    <span class="type">int16_t</span> gyr_z;</span><br><span class="line">    <span class="type">float</span> AngleX;</span><br><span class="line">    <span class="type">float</span> AngleY;</span><br><span class="line">    <span class="type">float</span> AngleZ;</span><br><span class="line">&#125;t_sQMI8658;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取加速度和陀螺仪寄存器值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">qmi8658_Read_AccAndGry</span><span class="params">(t_sQMI8658 *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> status, data_ready=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int16_t</span> buf[<span class="number">6</span>];</span><br><span class="line"></span><br><span class="line">    qmi8658_register_read(QMI8658_STATUS0, &amp;status, <span class="number">1</span>); <span class="comment">// 读状态寄存器</span></span><br><span class="line">    <span class="keyword">if</span> (status &amp; <span class="number">0x03</span>) 					<span class="comment">// 判断加速度和陀螺仪数据是否可读</span></span><br><span class="line">        data_ready = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (data_ready == <span class="number">1</span>)&#123;  				<span class="comment">// 如果数据可读</span></span><br><span class="line">        data_ready = <span class="number">0</span>;</span><br><span class="line">        qmi8658_register_read(QMI8658_AX_L, (<span class="type">uint8_t</span> *)buf, <span class="number">12</span>); <span class="comment">// 读加速度和陀螺仪值</span></span><br><span class="line">        p-&gt;acc_x = buf[<span class="number">0</span>];</span><br><span class="line">        p-&gt;acc_y = buf[<span class="number">1</span>];</span><br><span class="line">        p-&gt;acc_z = buf[<span class="number">2</span>];</span><br><span class="line">        p-&gt;gyr_x = buf[<span class="number">3</span>];</span><br><span class="line">        p-&gt;gyr_y = buf[<span class="number">4</span>];</span><br><span class="line">        p-&gt;gyr_z = buf[<span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取XYZ轴的倾角值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">qmi8658_fetch_angleFromAcc</span><span class="params">(t_sQMI8658 *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> temp;</span><br><span class="line"></span><br><span class="line">    qmi8658_Read_AccAndGry(p); <span class="comment">// 读取加速度和陀螺仪的寄存器值</span></span><br><span class="line">    <span class="comment">// 根据寄存器值 计算倾角值 并把弧度转换成角度</span></span><br><span class="line">    temp = (<span class="type">float</span>)p-&gt;acc_x / <span class="built_in">sqrt</span>( ((<span class="type">float</span>)p-&gt;acc_y * (<span class="type">float</span>)p-&gt;acc_y + (<span class="type">float</span>)p-&gt;acc_z * (<span class="type">float</span>)p-&gt;acc_z) );</span><br><span class="line">    p-&gt;AngleX = <span class="built_in">atan</span>(temp)*<span class="number">57.29578f</span>; <span class="comment">// 180/π=57.29578</span></span><br><span class="line">    temp = (<span class="type">float</span>)p-&gt;acc_y / <span class="built_in">sqrt</span>( ((<span class="type">float</span>)p-&gt;acc_x * (<span class="type">float</span>)p-&gt;acc_x + (<span class="type">float</span>)p-&gt;acc_z * (<span class="type">float</span>)p-&gt;acc_z) );</span><br><span class="line">    p-&gt;AngleY = <span class="built_in">atan</span>(temp)*<span class="number">57.29578f</span>; <span class="comment">// 180/π=57.29578</span></span><br><span class="line">    temp = <span class="built_in">sqrt</span>( ((<span class="type">float</span>)p-&gt;acc_x * (<span class="type">float</span>)p-&gt;acc_x + (<span class="type">float</span>)p-&gt;acc_y * (<span class="type">float</span>)p-&gt;acc_y) ) / (<span class="type">float</span>)p-&gt;acc_z;</span><br><span class="line">    p-&gt;AngleZ = <span class="built_in">atan</span>(temp)*<span class="number">57.29578f</span>; <span class="comment">// 180/π=57.29578</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="io拓展pac9557"><a class="markdownIt-Anchor" href="#io拓展pac9557"></a> IO拓展（PAC9557）</h2>
<p>外设拓展口，由<strong>I2C控制</strong>，地址<strong>PCA9557_SENSOR_ADDR = 0x19</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//LCD_CS 对应 PCA9557 的 IO0 引脚，PA_EN 对应 IO1 引脚，DVP_PWDN 对应 IO2 引脚</span></span><br></pre></td></tr></table></figure>
<h2 id="音频输入es7210"><a class="markdownIt-Anchor" href="#音频输入es7210"></a> 音频输入（ES7210）</h2>
<p>AD0接高电平，AD1接低电平，<strong>I2C地址为0x41</strong></p>
<p><strong>ES7210</strong> 连接 MIC <strong>负责音频输入</strong>，<strong>ES8311</strong> 只负责<strong>音频输出</strong></p>
<p><strong>ES7210 可以连接 4 个 MIC</strong>，开发板上连接了 3 个 MIC，<strong>MIC1 和 MIC2 接收人说话的声音</strong>， <strong>MIC3 连接了 ES8311 的输出</strong>，用于回声消除。</p>
<p>S3芯片会做回声消除，<strong>音响在播放声音的时候，可以说话打断它</strong>。</p>
<p>这个原理就是 ES8311 输出的信号，不仅给了喇叭，还给了 ES7210 的 MIC3 输入，ESP32 在接收到 MIC1 MIC2 和 MIC3 的声音后，可以分离出 MIC3，从而进行识别。</p>
<p><strong>本部分例程</strong></p>
<ol>
<li>
<p>初始化I2S总线</p>
</li>
<li>
<p>初始化ES7120芯片</p>
</li>
<li>
<p>加载SD卡</p>
</li>
<li>
<p>录制声音</p>
</li>
</ol>
<h3 id="i2s的io和寄存器配置"><a class="markdownIt-Anchor" href="#i2s的io和寄存器配置"></a> I2S的IO和寄存器配置</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_ES7210_I2C_ADDR    (0x41)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* I2C port and GPIOs */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_I2C_NUM            (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_I2C_SDA_IO         (1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_I2C_SCL_IO         (2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* I2S port and GPIOs */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_I2S_NUM            (0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_I2S_MCK_IO         (38)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_I2S_BCK_IO         (14)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_I2S_WS_IO          (13)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_I2S_DI_IO          (12)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* I2S configurations */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_I2S_TDM_FORMAT     (ES7210_I2S_FMT_I2S)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_I2S_CHAN_NUM       (2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_I2S_SAMPLE_RATE    (48000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_I2S_MCLK_MULTIPLE  (I2S_MCLK_MULTIPLE_256)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_I2S_SAMPLE_BITS    (I2S_DATA_BIT_WIDTH_16BIT)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EXAMPLE_I2S_TDM_SLOT_MASK  (I2S_TDM_SLOT0 | I2S_TDM_SLOT1)</span></span><br></pre></td></tr></table></figure>
<h3 id="标准i2s和tdm_i2s模式"><a class="markdownIt-Anchor" href="#标准i2s和tdm_i2s模式"></a> 标准I2S和TDM_I2S模式</h3>
<p>I2S模式</p>
<img src="https://s2.loli.net/2025/05/08/ejG41dOuWKL8rUX.png" style="zoom: 67%;" />
<p><strong>TDM_I2S模式</strong></p>
<img src="https://s2.loli.net/2025/05/08/oLIKBUTzCDepwHG.png" style="zoom:67%;" />
<p>ES7210工作在<strong>I2S模式</strong>时，只能<strong>采集2个通道</strong>，而工作在<strong>TDM_I2S</strong>模式时，可以<strong>采集4个通道</strong></p>
<h2 id="音频输出es8311"><a class="markdownIt-Anchor" href="#音频输出es8311"></a> 音频输出（ES8311）</h2>
<p>主函数包括：</p>
<ol>
<li><code>i2s_driver_init()</code> 函数初始化 i2s 接口</li>
<li><code>es8311_codec_init()</code> 函数初始化 <strong>i2c 接口并初始化 es8311 芯片</strong></li>
<li><code>pca9557_init()</code> 函数初始化 IO 扩展芯片 pca9557</li>
<li><code>pa_en()</code> 函数用于控制音频功放的打开和关闭，IO1引脚</li>
<li><code>i2s_music()</code> 函数是创建的任务函数，用于播放音乐</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PCA9557_INPUT_PORT              0x00</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCA9557_OUTPUT_PORT             0x01</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCA9557_POLARITY_INVERSION_PORT 0x02</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCA9557_CONFIGURATION_PORT      0x03</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_CS_GPIO                 BIT(0)    <span class="comment">// PCA9557_GPIO_NUM_1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PA_EN_GPIO                  BIT(1)    <span class="comment">// PCA9557_GPIO_NUM_2</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DVP_PWDN_GPIO               BIT(2)    <span class="comment">// PCA9557_GPIO_NUM_3</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCA9557_SENSOR_ADDR   0x19        <span class="comment">/*!&lt; Slave address of the MPU9250 sensor */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_BITS(_m, _s, _v)  ((_v) ? (_m)|((_s)) : (_m)&amp;~((_s)))</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">pca9557_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">lcd_cs</span><span class="params">(<span class="type">uint8_t</span> level)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pa_en</span><span class="params">(<span class="type">uint8_t</span> level)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">dvp_pwdn</span><span class="params">(<span class="type">uint8_t</span> level)</span>;</span><br><span class="line"><span class="comment">// 初始化PCA9557 IO扩展芯片</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">pca9557_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 写入控制引脚默认值 DVP_PWDN=1  PA_EN = 0  LCD_CS = 1</span></span><br><span class="line">    pca9557_register_write_byte(PCA9557_OUTPUT_PORT, <span class="number">0x05</span>);</span><br><span class="line">    <span class="comment">// 把PCA9557芯片的IO1 IO1 IO2设置为输出(0) 其它引脚保持默认的输入(1)</span></span><br><span class="line">    pca9557_register_write_byte(PCA9557_CONFIGURATION_PORT, <span class="number">0xf8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="液晶显示st7789ft6557"><a class="markdownIt-Anchor" href="#液晶显示st7789ft6557"></a> 液晶显示（ST7789+FT6557）</h2>
<p><strong>使用SPI驱动</strong>，存储到SPIRAM中</p>
<p>液晶屏显示的开关有两个，一个是 <code>esp_lcd_panel_disp_on_off()</code>，一个是 <code>bsp_display_backlight_on()</code></p>
<p>区别：</p>
<p><code>esp_lcd_panel_disp_on_off()</code> 用来控制的是液晶屏的驱动芯片 ST7789 中的寄存器，这个寄存器<strong>控制液晶屏显示</strong>与否。</p>
<p><code>bsp_display_backlight_on()</code> 用来控制液晶屏 LED 背光，通过<strong>调节 PWM 占空比调节亮度</strong>，使用的是 LEDC 外设产生的 PWM 信号。</p>
<p><code>esp_lcd_panel_swap_xy()</code> 函数控制 xy 坐标翻转，第 2 个参数，true 表示翻转，false 表示不翻转。</p>
<p><code>esp_lcd_panel_mirror()</code> 函数控制 xy 方向是否镜像。第 2 个参数控制 x 方向，第 3 个参数控制 y 方向，true 表示镜像，false 表示不镜像。</p>
<h3 id="实验"><a class="markdownIt-Anchor" href="#实验"></a> 实验</h3>
<p>IO42 引脚控制液晶屏的背光，<strong>低电平亮</strong>，如果 <strong>IO42 引脚输出 PWM 信号</strong>，就可以通过调节占空比，均匀的<strong>控制液晶屏的背光亮度</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_LCD_BACKLIGHT     (GPIO_NUM_42)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_LEDC_CH          LEDC_CHANNEL_0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_LCD_PIXEL_CLOCK_HZ     (80 * 1000 * 1000)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_LCD_SPI_NUM            (SPI3_HOST)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_CMD_BITS               (8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LCD_PARAM_BITS             (8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_LCD_BITS_PER_PIXEL     (16)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_LCD_SPI_MOSI      (GPIO_NUM_40)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_LCD_SPI_CLK       (GPIO_NUM_41)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_LCD_SPI_CS        (GPIO_NUM_NC)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_LCD_DC            (GPIO_NUM_39)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BSP_LCD_RST           (GPIO_NUM_NC)</span></span><br></pre></td></tr></table></figure>
<p><strong>亮度调节函数</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">esp_err_t</span> <span class="title function_">bsp_display_brightness_set</span><span class="params">(<span class="type">int</span> brightness_percent)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (brightness_percent &gt; <span class="number">100</span>) &#123;</span><br><span class="line">        brightness_percent = <span class="number">100</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (brightness_percent &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        brightness_percent = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ESP_LOGI(TAG, <span class="string">&quot;Setting LCD backlight: %d%%&quot;</span>, brightness_percent);</span><br><span class="line">    <span class="comment">// LEDC resolution set to 10bits, thus: 100% = 1023</span></span><br><span class="line">    <span class="type">uint32_t</span> duty_cycle = (<span class="number">1023</span> * brightness_percent) / <span class="number">100</span>;</span><br><span class="line">    BSP_ERROR_CHECK_RETURN_ERR(ledc_set_duty(LEDC_LOW_SPEED_MODE, LCD_LEDC_CH, duty_cycle));</span><br><span class="line">    BSP_ERROR_CHECK_RETURN_ERR(ledc_update_duty(LEDC_LOW_SPEED_MODE, LCD_LEDC_CH));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ESP_OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="摄像头gc0308"><a class="markdownIt-Anchor" href="#摄像头gc0308"></a> 摄像头（GC0308）</h2>
<p>一般 <strong>500W 像素以下</strong>的摄像头模块，使用 <strong>DVP 接口</strong>，<strong>以上的使用 MIPI 接口</strong>。MIPI 接口速度要高于 DVP 接口。</p>
<p>GC0308 摄像头最大分辨率 640 * 480，30W 像素，工作在 24MHz 频率下，输出 240 *320 分辨率时，可达 30 帧。</p>
<h3 id="实验-2"><a class="markdownIt-Anchor" href="#实验-2"></a> 实验</h3>
<p>PWDN 引脚控制摄像头进入待机模式和工作模式，<strong>高电平进入待机模式</strong>，<strong>低电平进入工作模式</strong></p>
<p><code>.ledc_channel</code> 和 <code>.ledc_timer</code>中，LEDC 外设用来给某个引脚产生 PWM 信号，这里可以用来产生时钟信号给摄像头的 XCLK 引脚。但是 <strong>S3 芯片用不着</strong>，因为 S3 芯片的 CAM 外设会产生 XCLK 信号。关于这一点，看 ESP32-S3 的技术参考手册可以了解到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 让摄像头显示到LCD</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_camera_lcd</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    xQueueLCDFrame = xQueueCreate(<span class="number">2</span>, <span class="keyword">sizeof</span>(<span class="type">camera_fb_t</span> *));</span><br><span class="line">    xTaskCreatePinnedToCore(task_process_camera, <span class="string">&quot;task_process_camera&quot;</span>, <span class="number">3</span> * <span class="number">1024</span>, <span class="literal">NULL</span>, <span class="number">5</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">    xTaskCreatePinnedToCore(task_process_lcd, <span class="string">&quot;task_process_lcd&quot;</span>, <span class="number">4</span> * <span class="number">1024</span>, <span class="literal">NULL</span>, <span class="number">5</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建了两个任务，一个任务是摄像头获取画面的任务，一个是液晶屏显示画面的任务。其中，还创建了一个队列信号，摄像头获取到画面，发送队列信号通知 LCD 显示。<strong>ESP32S3 是双核处理器</strong>，这两个任务，一个定义在 CPU0 上运行，一个定义在 CPU1 上运行，这样可以提高运行速度。xTaskCreatePinnedToCore()函数的最后一个参数，用来定义在哪个 CPU 上运行。</p>
<p><strong>esp_camera_fb_get()函数</strong>用来获取一帧摄像头图像，并把获取到的一帧信息返回</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_PIN_PWDN -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_PIN_RESET -1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_PIN_XCLK 5</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_PIN_SIOD 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_PIN_SIOC 2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_PIN_D7 9</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_PIN_D6 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_PIN_D5 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_PIN_D4 15</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_PIN_D3 17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_PIN_D2 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_PIN_D1 18</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_PIN_D0 16</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_PIN_VSYNC 3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_PIN_HREF 46</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CAMERA_PIN_PCLK 7</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> XCLK_FREQ_HZ 24000000</span></span><br></pre></td></tr></table></figure>
<h2 id="lvgl"><a class="markdownIt-Anchor" href="#lvgl"></a> LVGL</h2>
<p>LVGL（Light and Versatile Graphics Library）是一个开源的图形用户界面库，旨在为嵌入式系统提供轻量级、可移植、灵活且易于使用的图形用户界面解决方案</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开发板显示初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">bsp_lvgl_start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 初始化LVGL */</span></span><br><span class="line">    <span class="type">lvgl_port_cfg_t</span> lvgl_cfg = ESP_LVGL_PORT_INIT_CONFIG();</span><br><span class="line">    lvgl_port_init(&amp;lvgl_cfg);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化液晶屏 并添加LVGL接口，自己写 */</span></span><br><span class="line">    disp = bsp_display_lcd_init();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 初始化触摸屏 并添加LVGL接口，自己写 */</span></span><br><span class="line">    disp_indev = bsp_display_indev_init(disp);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 打开液晶屏背光 */</span></span><br><span class="line">    bsp_display_backlight_on();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">app_main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    bsp_i2c_init();  		<span class="comment">// I2C初始化</span></span><br><span class="line">    pca9557_init();  		<span class="comment">// IO扩展芯片初始化</span></span><br><span class="line"></span><br><span class="line">    bsp_lvgl_start(); 		<span class="comment">// 初始化lvgl显示</span></span><br><span class="line">    lv_demo_benchmark(); 	<span class="comment">// 调用lvgl demo</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="配置"><a class="markdownIt-Anchor" href="#配置"></a> 配置</h1>
<h2 id="基础配置"><a class="markdownIt-Anchor" href="#基础配置"></a> 基础配置</h2>
<ul>
<li>
<p><strong>Flash = 16MB</strong></p>
</li>
<li>
<p>要存储MP3文件，需要设置FAT文件系统，<strong>Default block size = 4096</strong></p>
</li>
<li>
<p>使用SPI，需要设置SPIRAM，<strong>应用外存，Octal（8线SPI） Mode PSRAM，80MHz clock speed</strong></p>
</li>
<li>
<p>调用摄像头，设置<strong>CPU频率为240MHz</strong>，还有如下</p>
<img src="https://s2.loli.net/2025/05/09/zKmQhEqObg7tDY4.png" style="zoom:67%;" />
</li>
<li>
<p>使用LVGL，需要<strong>设置反转颜色</strong>，Color settings下的Swap the 2 bytes of…<strong>打勾</strong></p>
</li>
<li>
<p>设置其他字体，Font usage可以开启 <strong>Enable Monserrat 24</strong>等</p>
</li>
</ul>
<h2 id="yml文件"><a class="markdownIt-Anchor" href="#yml文件"></a> yml文件</h2>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">dependencies:</span></span><br><span class="line">  <span class="attr">lvgl/lvgl:</span> <span class="string">~8.3.0</span></span><br><span class="line">  <span class="attr">espressif/esp_lvgl_port:</span> <span class="string">~1.4.0</span>             <span class="comment"># LVGL接口</span></span><br><span class="line">  <span class="attr">espressif/esp_lcd_touch_ft5x06:</span> <span class="string">~1.0.6</span>      <span class="comment"># 触摸屏驱动</span></span><br><span class="line">  <span class="attr">chmorgan/esp-audio-player:</span> <span class="string">~1.0.7</span>           <span class="comment"># 音频播放</span></span><br><span class="line">  <span class="attr">chmorgan/esp-file-iterator:</span> <span class="number">1.0</span><span class="number">.0</span>           <span class="comment"># 获取文件</span></span><br><span class="line">  <span class="attr">espressif/esp_codec_dev:</span> <span class="string">~1.3.0</span>             <span class="comment"># 音频驱动</span></span><br><span class="line">  <span class="attr">espressif/esp-sr:</span> <span class="string">~1.6.0</span>                    <span class="comment"># 语音识别</span></span><br><span class="line">  <span class="attr">espressif/zlib:</span> <span class="string">^1.3.0</span></span><br><span class="line">  <span class="attr">espressif/esp32-camera:</span> <span class="string">&#x27;*&#x27;</span></span><br><span class="line">    <span class="comment">## Required IDF version</span></span><br><span class="line">  <span class="attr">idf:</span></span><br><span class="line">    <span class="attr">version:</span> <span class="string">~5.2.5</span></span><br></pre></td></tr></table></figure>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<p><a href="https://wiki.lckfb.com/zh-hans/szpi-esp32s3/download-center.html">【下载中心】实战派 | 立创开发板技术文档中心</a></p>
<p><a href="https://blog.csdn.net/MJiarong_personal/article/details/121726585">【ESP32-S3的开发】| 1.初识 ESP32-S3_esp32s3引脚图详细解释-CSDN博客</a></p>
<p><a href="https://gitee.com/gsm-wheather-project/gsm-weather-esp32s3-esp-idf5.0/tree/master/components">components · GSM-Weather-project/gsm-weather-esp32s3-esp-idf5.0 - 码云 - 开源中国</a></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>ESP</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux学习笔记</title>
    <url>/2025/08/26/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="linux学习笔记学习ing"><a class="markdownIt-Anchor" href="#linux学习笔记学习ing"></a> Linux学习笔记(学习ing…)</h1>
<p><s>FOC、CANOpen和AutoSAR是什么，真不熟。</s></p>
<p>抽空还是再看看Linux吧。（未完待续）</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MQTT协议</title>
    <url>/2025/08/04/MQTT%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<h1 id="mqtt协议"><a class="markdownIt-Anchor" href="#mqtt协议"></a> MQTT协议</h1>
<p>MQTT是<strong>应用层协议</strong>，基于传输层的<strong>TCP发送</strong>。</p>
<p><strong>通常端口：1883</strong></p>
<p><strong>客户端给服务端发送</strong>，表示<strong>发布</strong></p>
<p><strong>服务端给客户端发送</strong>，表示<strong>推送</strong></p>
<p><strong>ClientID是用户名Username和密码Password相同下之下的多个角色，有记忆</strong></p>
<h2 id="配置环境"><a class="markdownIt-Anchor" href="#配置环境"></a> 配置环境</h2>
<p>下载安装包<br />
资料下载地址: <a href="https://pan.baidu.com/s/1qFuCzYW-lj1JnuUBcbiJxg">https://pan.baidu.com/s/1qFuCzYW-lj1JnuUBcbiJxg</a> 提取码: n25a<br />
安装<strong>emqx作为服务端</strong>，打开PowerShell</p>
<p><img src="https://s2.loli.net/2025/07/25/k7BpLfqRMID9568.png" alt="" /></p>
<p>输入bin/emqx start，接着在浏览器打开<strong>127.0.0.1:18083</strong>，网页默认用户名和密码是<strong>admin/public</strong></p>
<p>使用<strong>网络调试助手和mqttx作为客户端</strong></p>
<h2 id="mqtt报文"><a class="markdownIt-Anchor" href="#mqtt报文"></a> MQTT报文</h2>
<img src="https://s2.loli.net/2025/08/04/cMoPVbNeAg2YsJ3.png" style="zoom:80%;" />
<h3 id="剩余长度"><a class="markdownIt-Anchor" href="#剩余长度"></a> 剩余长度</h3>
<p>剩余长度 = 可变报头长度 + 负载长度</p>
<p>可变长编码（1-4个字节）（<strong>128进制</strong>-----只要每个Byte的最高位为1，就继续往下读）</p>
<p><img src="https://s2.loli.net/2025/08/04/tZIql9ObwxrsAiN.png" alt="" /></p>
<h3 id="服务质量等级"><a class="markdownIt-Anchor" href="#服务质量等级"></a> 服务质量等级</h3>
<p><img src="https://s2.loli.net/2025/08/04/2CeHJXMjp5imrYa.png" alt="" /></p>
<ul>
<li>0：不需要签收，开销小</li>
<li>1：需要1次签收</li>
<li>2：需要一次签收，并且需要一次回访</li>
</ul>
<h3 id="connect"><a class="markdownIt-Anchor" href="#connect"></a> CONNECT</h3>
<p><img src="https://s2.loli.net/2025/08/04/TUD2fN1JXtlaOup.png" alt="" /></p>
<p><img src="https://s2.loli.net/2025/08/04/MvnPiY3xOaLA276.png" alt="" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//输入：</span><br><span class="line">//固定报头（MQTT报文类型 + Reserved保留位） 剩余长度37 Byte</span><br><span class="line"></span><br><span class="line">//可变报头00 04 + ‘M’+&#x27;Q&#x27;+&#x27;T&#x27;+&#x27;T&#x27; + 协议级别04 </span><br><span class="line">//+ 连接标志C2）+ 保持连接（10 64 --- 4196s，实际上是1.5倍）</span><br><span class="line"></span><br><span class="line">//ClientID</span><br><span class="line">//Username</span><br><span class="line">//Password</span><br><span class="line"></span><br><span class="line">10 25</span><br><span class="line"></span><br><span class="line">00 04 4D 51 54 54 04 C2 10 64 </span><br><span class="line"></span><br><span class="line">00 07 55 53 45 52 30 30 31 </span><br><span class="line">00 07 55 53 45 52 30 30 31 </span><br><span class="line">00 07 55 53 45 52 30 30 31 </span><br><span class="line"></span><br><span class="line">//返回：</span><br><span class="line">20 02 00 00</span><br></pre></td></tr></table></figure>
<h3 id="connack"><a class="markdownIt-Anchor" href="#connack"></a> CONNACK</h3>
<p><img src="https://s2.loli.net/2025/08/04/Of9k5MEBLCY6naX.png" alt="" /></p>
<p><img src="https://s2.loli.net/2025/08/04/EAHqJh1gS5luxbi.png" alt="" /></p>
<p>第1个字节是 连接确认标志，<strong>位7-1是保留位且必须设置为0</strong>。</p>
<p>第0 (SP)位 是当前会话（Session Present）标志，即CONNECT的Clean Session。</p>
<p><img src="https://s2.loli.net/2025/08/04/dxnjYzrkKDLAcyo.png" alt="" /></p>
<p><img src="https://s2.loli.net/2025/08/04/OTWLvEsuRAZYwze.png" alt="" /></p>
<h3 id="disconnect"><a class="markdownIt-Anchor" href="#disconnect"></a> DISCONNECT</h3>
<p><img src="https://s2.loli.net/2025/08/04/MlnWYhd5LNiZFwC.png" alt="" /></p>
<p><strong>DISCONNECT</strong>报文<strong>没有可变报头和有效载荷</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">E0 00</span><br></pre></td></tr></table></figure>
<h3 id="subscribe"><a class="markdownIt-Anchor" href="#subscribe"></a> SUBSCRIBE</h3>
<p><img src="https://s2.loli.net/2025/08/04/UTPOYEXuR17ay9x.png" alt="" /></p>
<p><strong>剩余长度</strong>等于<strong>可变报头的长度</strong>（2字节）<strong>加上有效载荷的长度</strong>。</p>
<p><img src="https://s2.loli.net/2025/08/04/kBJQqtMxLRNF7TY.png" alt="" /></p>
<p><strong>报文标识符，需要订阅和确认反馈一致，具体可以自己定义。</strong></p>
<h3 id="suback"><a class="markdownIt-Anchor" href="#suback"></a> SUBACK</h3>
<p><img src="https://s2.loli.net/2025/08/05/omYZWrDNzCEOLQ3.png" alt="" /></p>
<p><strong>剩余长度</strong>等于<strong>可变报头的长度加上有效载荷的长度</strong>。</p>
<p><img src="https://s2.loli.net/2025/08/05/PeAOYRljWvhLyoS.png" alt="" /></p>
<p><img src="https://s2.loli.net/2025/08/05/NvfWYeH75nh3Xug.png" alt="" /></p>
<p><strong>0x80 - Failure（失败）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//发送：</span><br><span class="line">//固定报头82 + 剩余长度0C</span><br><span class="line">//报文标识符00 0A</span><br><span class="line">//USER002长7字节，后续跟随USER002（Topic） + Qos（02）</span><br><span class="line">82 0C</span><br><span class="line">00 0A</span><br><span class="line">00 07 55 53 45 52 30 30 32 02</span><br><span class="line"></span><br><span class="line">//接收：</span><br><span class="line">//固定报头90 + 剩余长度03 + 报文标识符00 0A +有效载荷 Qos（02）</span><br><span class="line">90 03 00 0A 02</span><br></pre></td></tr></table></figure>
<h3 id="unsubscribe"><a class="markdownIt-Anchor" href="#unsubscribe"></a> UNSUBSCRIBE</h3>
<p><img src="https://s2.loli.net/2025/08/05/ola4T9fxmytOVQI.png" alt="" /></p>
<p><strong>剩余长度</strong>等于<strong>可变报头的长度加上有效载荷的长度</strong>。</p>
<p><img src="https://s2.loli.net/2025/08/05/UZGarJh2dvANDkH.png" alt="" /></p>
<p><img src="https://s2.loli.net/2025/08/05/kNPSDjy12W8EvVc.png" alt="" /></p>
<h3 id="unsuback"><a class="markdownIt-Anchor" href="#unsuback"></a> UNSUBACK</h3>
<p><img src="https://s2.loli.net/2025/08/05/oOmBWwF1hCrXxzd.png" alt="" /></p>
<p><strong>剩余长度 = 0x02</strong></p>
<p><img src="https://s2.loli.net/2025/08/05/mus69ZdDpz4FCHi.png" alt="" /></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 发送：</span><br><span class="line">// 固定报头A2 + 剩余长度</span><br><span class="line">// 报文标识符12 34</span><br><span class="line">// 长度表示00 07 + USER002（Topic）</span><br><span class="line">A2 0B</span><br><span class="line">12 34</span><br><span class="line">00 07 55 53 45 52 30 30 32</span><br><span class="line"></span><br><span class="line">// 接收：</span><br><span class="line">// 固定报头 + 剩余长度 + 报文标识符</span><br><span class="line">B0 02 12 34</span><br></pre></td></tr></table></figure>
<h3 id="ping"><a class="markdownIt-Anchor" href="#ping"></a> PING</h3>
<p><img src="https://s2.loli.net/2025/08/04/KqGWmaBygMDn85l.png" alt="" /></p>
<p><img src="https://s2.loli.net/2025/08/04/1LGOa6KteHkgWjd.png" alt="" /></p>
<p><strong>PING</strong>报文<strong>没有可变报头和有效载荷</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C0 00</span><br></pre></td></tr></table></figure>
<h3 id="pingrsp"><a class="markdownIt-Anchor" href="#pingrsp"></a> PINGRSP</h3>
<p><img src="https://s2.loli.net/2025/08/04/uo9azSLckJDfBxn.png" alt="" /></p>
<p><strong>PINGRSP</strong>报文<strong>没有可变报头和有效载荷</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">D0 00</span><br></pre></td></tr></table></figure>
<h3 id="报文分类"><a class="markdownIt-Anchor" href="#报文分类"></a> 报文分类</h3>
<ul>
<li>
<p>Qos=0的PUBLISH：<strong>发送方</strong>用到<strong>PUBLISH</strong>报文，没有接收方的事</p>
</li>
<li>
<p>Qos=1的PUBLISH：<strong>发送方</strong>用到<strong>PUBLISH</strong>报文，<strong>接收方</strong>用<strong>PUBACK</strong>报文表示签收</p>
</li>
<li>
<p>Qos=2的PUBLISH：发送方先用到<strong>PUBLISH</strong>报文，<strong>接收方</strong>用<strong>PUBREC</strong>报文表示签收；发送方再用<strong>PUBREL</strong>报文开启回访，<strong>接收方</strong>用<strong>PUBCOMP</strong>报文表示回访确认</p>
</li>
</ul>
<h3 id="publish"><a class="markdownIt-Anchor" href="#publish"></a> PUBLISH</h3>
<p><img src="https://s2.loli.net/2025/08/05/8phjXnc3r2b1Baw.png" alt="" /></p>
<p>在Qos=0时，<strong>DUP设置为0，即不重发</strong>；</p>
<p><strong>RETAIN = 1</strong>，Qos=0的带<strong>保留功能</strong>，即<strong>保留本条PUBLISH报文</strong>（最重要的，只有一条，后面关注的都会立即看到）。</p>
<p><img src="https://s2.loli.net/2025/08/05/3wVzHdkasA9BLhb.png" alt="" /></p>
<p><strong>有效负载就是需要发送的数据</strong></p>
<p>有效载荷的长度计算：用固定报头中的剩余长度字段的值减去可变报头的长度。</p>
<h4 id="qos0"><a class="markdownIt-Anchor" href="#qos0"></a> Qos=0</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//固定报头 + 剩余长度</span><br><span class="line">//长度00 07 + 自己的topic（USER001）</span><br><span class="line">//发送的字符串123</span><br><span class="line">30 0C</span><br><span class="line">00 07 55 53 45 52 30 30 31</span><br><span class="line">31 32 33</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2025/08/05/YIZQ7fyzCRopPeX.png" alt="" /></p>
<h4 id="qos1"><a class="markdownIt-Anchor" href="#qos1"></a> Qos=1</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//第一次发送，不带保留：</span><br><span class="line">//固定报头 + 剩余长度</span><br><span class="line">//长度 + USER001</span><br><span class="line">//字符串123</span><br><span class="line">32 0E</span><br><span class="line">00 07 55 53 45 52 30 30 31 12 34 </span><br><span class="line">31 32 33</span><br><span class="line"></span><br><span class="line">//接收方第一次没有签收，发送方后续重发，不带保留：</span><br><span class="line">3A 0E</span><br><span class="line">00 07 55 53 45 52 30 30 31 12 34</span><br><span class="line">31 32 33</span><br><span class="line"></span><br><span class="line">//User001显示</span><br><span class="line">//40表示4号报文，接收成功；12 34是报文标识符</span><br><span class="line">40 02 12 34</span><br><span class="line"></span><br><span class="line">//User001签收（4号报文+长度+Qos=1）</span><br><span class="line">40 02 00 01</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2025/08/05/GfPpSMkRETasHQ4.png" alt="" /></p>
<p>没有签收，会一直发送请求，<strong>签收后就不会再发</strong>。</p>
<p><img src="https://s2.loli.net/2025/08/05/lATZgwSN7mUJVkv.png" alt="" /></p>
<h4 id="qos2"><a class="markdownIt-Anchor" href="#qos2"></a> Qos=2</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//第一次发送，不带保留：</span><br><span class="line">// 3号PUBLISH报文</span><br><span class="line">34 0E</span><br><span class="line">00 07 55 53 45 52 30 30 31 11 22</span><br><span class="line">31 32 33</span><br><span class="line"></span><br><span class="line">// 返回5号报文</span><br><span class="line">(5)PUBREC: 50 02 00 01</span><br><span class="line"></span><br><span class="line">//需要回访，否则再输入,USER002也不显示</span><br><span class="line">(6)PUBREL:  62 02 11 22</span><br><span class="line"></span><br><span class="line">//返回7号报文</span><br><span class="line">(7)PUBCOMP :  70 02 00 01</span><br><span class="line"></span><br><span class="line">//接收方第一次没有签收，发送方后续重发，不带保留：(如果是7号没有回访确认，不重发3号，而是重发6号报文)</span><br><span class="line"></span><br><span class="line">3C 0E</span><br><span class="line">00 07 55 53 45 52 30 30 31 11 22</span><br><span class="line">31 32 33</span><br><span class="line"></span><br><span class="line">(6)PUBREL:  62 02 11 22</span><br><span class="line"></span><br><span class="line">(5)PUBREC: 50 02 00 01</span><br><span class="line"></span><br><span class="line">(7)PUBCOMP :  70 02 00 01</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="会话清理与保留"><a class="markdownIt-Anchor" href="#会话清理与保留"></a> 会话清理与保留</h3>
<p><img src="https://s2.loli.net/2025/08/05/TEeWHVBtuF23p7v.png" alt="" /></p>
<ul>
<li>
<p>1：清理会话：<strong>没有记忆</strong>，不保留订阅。<strong>每次登陆后需要重新订阅需要的TOPIC</strong>。<strong>收不到离线消息</strong>。</p>
</li>
<li>
<p>0：保留会话：<strong>有记忆，不用重新订阅TOPIC</strong>。<strong>离线期间的消息</strong>（PUBLISH）我们可以<strong>收到</strong>。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//1，清理</span><br><span class="line">10 25 </span><br><span class="line">00 04 4D 51 54 54 04 C2 00 64 </span><br><span class="line">00 07 55 53 45 52 30 30 31 </span><br><span class="line">00 07 55 53 45 52 30 30 31 </span><br><span class="line">00 07 55 53 45 52 30 30 31</span><br><span class="line">//0，保留</span><br><span class="line">10 25 </span><br><span class="line">00 04 4D 51 54 54 04 C0 00 64 </span><br><span class="line">00 07 55 53 45 52 30 30 31 </span><br><span class="line">00 07 55 53 45 52 30 30 31 </span><br><span class="line">00 07 55 53 45 52 30 30 31</span><br></pre></td></tr></table></figure>
<h4 id="connect的sp"><a class="markdownIt-Anchor" href="#connect的sp"></a> CONNECT的SP</h4>
<p><strong>Clean Session = 1 — SP= 0</strong></p>
<p><strong>Clean Session = 0，不一定</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">C2</th>
<th style="text-align:center">C0</th>
<th style="text-align:center">C0</th>
<th style="text-align:center">C0</th>
<th style="text-align:center">C0</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
<h3 id="遗嘱"><a class="markdownIt-Anchor" href="#遗嘱"></a> 遗嘱</h3>
<p><s>很好，我选择跟它一起G了</s></p>
<p>报警功能，非正常断线（<strong>正常断线用14号报文，这里是直接断开TCP/被踢下线</strong>）</p>
<p><strong>服务器会向订阅了遗嘱TOPIC的客户端推送遗嘱PUBLISH报文</strong></p>
<p>大白话：B订阅了A，A非正常断线，则B会收到A的遗嘱报文</p>
<p><img src="https://s2.loli.net/2025/08/05/SviHJRZtYVhsMb2.png" alt="" /></p>
<p><strong>USER002需要再订阅WILL001的遗嘱TOPIC</strong></p>
<p><strong>WILL001（遗嘱TOPIC）</strong></p>
<p><strong>WILL001（PUBLISH报文数据）</strong></p>
<p>(可以不一样，设置一样是为了方便)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 固定报头 + 剩余长度</span><br><span class="line">// 可变报头00 04 + ‘M’+&#x27;Q&#x27;+&#x27;T&#x27;+&#x27;T&#x27; + 协议级别04 </span><br><span class="line">// + 连接标志位C6）+ 保持连接（10 64 --- 4196s，实际上是1.5倍）</span><br><span class="line">// Client_ID --- USER001</span><br><span class="line">// WILL001 遗嘱TOPIC</span><br><span class="line">// WILL001 PUBLISH报文数据</span><br><span class="line">// Username --- USER001</span><br><span class="line">// Password --- USER001</span><br><span class="line">10 37</span><br><span class="line">00 04 4D 51 54 54 04 C6 10 64 </span><br><span class="line"></span><br><span class="line">00 07 55 53 45 52 30 30 31</span><br><span class="line">00 07 57 49 4C 4C 30 30 31 </span><br><span class="line">00 07 57 49 4C 4C 30 30 31 </span><br><span class="line">00 07 55 53 45 52 30 30 31</span><br><span class="line">00 07 55 53 45 52 30 30 31</span><br><span class="line"></span><br><span class="line">// 订阅USER002，然后再强制关闭USER001，可以看到遗嘱效果</span><br><span class="line">82 0C</span><br><span class="line">00 0A</span><br><span class="line">00 07 57 49 4C 4C 30 30 32 02</span><br></pre></td></tr></table></figure>
<h2 id="资料"><a class="markdownIt-Anchor" href="#资料"></a> 资料</h2>
<p><a href="https://www.bilibili.com/video/BV1VDdoYhEYh/?spm_id_from=333.337.search-card.all.click&amp;vd_source=2686d8279192347a7d56afcb53bb00d9">【2025新版】MQTT协议手把手详解 EMQX自建服务器 所有报文功能 逐个字节构建分析与测试_哔哩哔哩_bilibili</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/421109780">(11 封私信) MQTT协议，终于有人讲清楚了 - 知乎</a></p>
<p><a href="https://blog.csdn.net/jackwmj12/article/details/129163012">MQTT协议详解(完整版)-CSDN博客</a></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>MQTT</tag>
      </tags>
  </entry>
  <entry>
    <title>FreeRTOS学习笔记</title>
    <url>/2024/12/20/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>主要学习韦东山FreeRTOS的操作。</p>
<h1 id="freertos概述与体验"><a class="markdownIt-Anchor" href="#freertos概述与体验"></a> FreeRTOS概述与体验</h1>
<h2 id="freertos主要内容"><a class="markdownIt-Anchor" href="#freertos主要内容"></a> FreeRTOS主要内容</h2>
<table>
<thead>
<tr>
<th style="text-align:center">FreeRTOS/Source下的文件</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">task.c</td>
<td style="text-align:center">任务操作</td>
</tr>
<tr>
<td style="text-align:center">list.c</td>
<td style="text-align:center">列表</td>
</tr>
<tr>
<td style="text-align:center">queue.c</td>
<td style="text-align:center">提供队列操作、信号量操作</td>
</tr>
<tr>
<td style="text-align:center">timer.c</td>
<td style="text-align:center">软件定时功能</td>
</tr>
<tr>
<td style="text-align:center">event_groups.c</td>
<td style="text-align:center">通过事件组功能</td>
</tr>
</tbody>
</table>
<h2 id="数据类型"><a class="markdownIt-Anchor" href="#数据类型"></a> 数据类型</h2>
<ul>
<li>TickType_t：
<ul>
<li><strong>FreeRTOS配置了一个周期性的时钟中断</strong>：Tick Interrupt</li>
<li>每发生一次中断，中断次数累加，这被称为tick count</li>
<li>tick count<strong>这个变量的类型就是TickType_t</strong></li>
<li>TickType_t可以是16位的，也可以是32位的</li>
<li>FreeRTOSConfig.h中定义configUSE_16_BIT_TICKS时，TickType_t就是uint16_t</li>
<li>否则TickType_t就是uint32_t</li>
</ul>
</li>
<li>BaseType_t：
<ul>
<li><strong>这是该架构最高效的数据类型</strong></li>
<li>32位架构中，它就是uint32_t</li>
<li>16位架构中，它就是uint16_t</li>
<li>8位架构中，它就是uint8_t</li>
<li>BaseType_t通常用作简单的返回值的类型，还有逻辑值，比如<code>pdTRUE/pdFALSE</code></li>
</ul>
</li>
</ul>
<h2 id="变量名"><a class="markdownIt-Anchor" href="#变量名"></a> 变量名</h2>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>变量名前缀</strong></th>
<th style="text-align:center"><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:center">char</td>
</tr>
<tr>
<td style="text-align:center">s</td>
<td style="text-align:center">int16_t, short</td>
</tr>
<tr>
<td style="text-align:center">l</td>
<td style="text-align:center">int32_t, long</td>
</tr>
<tr>
<td style="text-align:center">x</td>
<td style="text-align:center">BaseType_t，结构体等</td>
</tr>
<tr>
<td style="text-align:center">u</td>
<td style="text-align:center">unsigned</td>
</tr>
<tr>
<td style="text-align:center">p</td>
<td style="text-align:center">指针</td>
</tr>
<tr>
<td style="text-align:center">uc</td>
<td style="text-align:center">uint8_t，unsigned char</td>
</tr>
<tr>
<td style="text-align:center">pc</td>
<td style="text-align:center">char指针</td>
</tr>
</tbody>
</table>
<h2 id="函数名"><a class="markdownIt-Anchor" href="#函数名"></a> 函数名</h2>
<table>
<thead>
<tr>
<th style="text-align:center"><strong>函数名前缀</strong></th>
<th style="text-align:center"><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">v<strong>Task</strong>PrioritySet</td>
<td style="text-align:center">返回值类型：void，在<strong>task.c</strong>中定义</td>
</tr>
<tr>
<td style="text-align:center">x<strong>Queue</strong>Receive</td>
<td style="text-align:center">返回值类型：BaseType_t，在<strong>queue.c</strong>中定义</td>
</tr>
<tr>
<td style="text-align:center">pv<strong>Timer</strong>GetTimerID</td>
<td style="text-align:center">返回值类型：pointer to void，在<strong>timer.c</strong>中定义</td>
</tr>
</tbody>
</table>
<h2 id="宏名"><a class="markdownIt-Anchor" href="#宏名"></a> 宏名</h2>
<table>
<thead>
<tr>
<th style="text-align:center">宏的前缀</th>
<th style="text-align:center">在哪个文件定义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">port (比如portMAX_DELAY)</td>
<td style="text-align:center">portable.h或portmacro.h</td>
</tr>
<tr>
<td style="text-align:center">task (比如taskENTER_CRITICAL())</td>
<td style="text-align:center">task.h</td>
</tr>
<tr>
<td style="text-align:center">pd (比如pdTRUE)</td>
<td style="text-align:center">projdefs.h</td>
</tr>
<tr>
<td style="text-align:center">config (比如configUSE_PREEMPTION)</td>
<td style="text-align:center">FreeRTOSConfig.h</td>
</tr>
<tr>
<td style="text-align:center">err (比如errQUEUE_FULL)</td>
<td style="text-align:center">projdefs.h</td>
</tr>
</tbody>
</table>
<p>一般的宏定义</p>
<table>
<thead>
<tr>
<th style="text-align:center">宏</th>
<th style="text-align:center">值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">pdTRUE</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">pdFALSE</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">pdPASS</td>
<td style="text-align:center">1</td>
</tr>
<tr>
<td style="text-align:center">pdFAIL</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<h1 id="内存管理"><a class="markdownIt-Anchor" href="#内存管理"></a> 内存管理</h1>
<ul>
<li>堆：heap，由程序员自己malloc一块空间，用完后free标记为&quot;空闲&quot;</li>
<li>栈：stack，函数调用时局部变量保存在栈中，当前程序环境也是保存在栈中。</li>
</ul>
<h2 id="五种内存管理方法"><a class="markdownIt-Anchor" href="#五种内存管理方法"></a> 五种内存管理方法</h2>
<table>
<thead>
<tr>
<th style="text-align:center">文件</th>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">heap_1.c</td>
<td style="text-align:center">分配简单，时间确定，没有碎片</td>
<td style="text-align:center">只分配，不回收</td>
</tr>
<tr>
<td style="text-align:center">heap_2.c</td>
<td style="text-align:center">动态分配，最佳匹配</td>
<td style="text-align:center">有碎片、时间不懂</td>
</tr>
<tr>
<td style="text-align:center">heap_3.c</td>
<td style="text-align:center">调用标准库函数</td>
<td style="text-align:center">速度慢、时间不定</td>
</tr>
<tr>
<td style="text-align:center">heap_4.c</td>
<td style="text-align:center">相邻的空闲碎片可合并</td>
<td style="text-align:center">时间不定</td>
</tr>
<tr>
<td style="text-align:center">heap_5.c</td>
<td style="text-align:center">在heap_4.c基础上支持分隔的内存块</td>
<td style="text-align:center">时间不定</td>
</tr>
</tbody>
</table>
<p>FreeRTOS在创建任务时，需要2个内核对象：<strong>task control block(TCB)、stack</strong>。</p>
<h3 id="heap_1"><a class="markdownIt-Anchor" href="#heap_1"></a> heap_1</h3>
<ul>
<li>
<p>只<strong>实现了pvPortMalloc</strong>，并<strong>没有实现vPortFree</strong>。</p>
</li>
<li>
<p>如果程序<strong>不需要删除内核对象</strong>，可以使用它</p>
</li>
</ul>
<h3 id="heap_2"><a class="markdownIt-Anchor" href="#heap_2"></a> heap_2</h3>
<p>相较于heap_1</p>
<ul>
<li>Heap_2使用<strong>最佳匹配算法</strong>(best fit)来分配内存</li>
<li>它<strong>支持vPortFree</strong></li>
</ul>
<h4 id="q这里的最佳匹配是怎么操作的"><a class="markdownIt-Anchor" href="#q这里的最佳匹配是怎么操作的"></a> Q：这里的最佳匹配是怎么操作的？</h4>
<p>举例，一个5 10 15内存的空间，此时需要存入一个6大小的数据，那么就存放在10里面，变成5 4 15；后续又需要存放一个4大小的数据，就变成5 0 15。</p>
<h3 id="heap_3"><a class="markdownIt-Anchor" href="#heap_3"></a> heap_3</h3>
<ul>
<li>使用标准C库里的malloc、free函数</li>
</ul>
<h4 id="q-heap_3线程安全吗"><a class="markdownIt-Anchor" href="#q-heap_3线程安全吗"></a> Q： heap_3线程安全吗?</h4>
<p>C库里的malloc、free函数并非线程安全的，Heap_3中先暂停FreeRTOS的调度器，再去调用这些函数，使用<strong>这种方法实现了线程安全</strong>。</p>
<h3 id="heap_4"><a class="markdownIt-Anchor" href="#heap_4"></a> heap_4</h3>
<ul>
<li>Heap_4使用<strong>首次适应算法</strong>(first fit)来分配内存。它还会把相邻的空闲内存合并为一个更大的空闲内存，这有助于较少内存的碎片问题。</li>
</ul>
<h4 id="q这里的首次匹配是怎么操作的"><a class="markdownIt-Anchor" href="#q这里的首次匹配是怎么操作的"></a> Q：这里的首次匹配是怎么操作的？</h4>
<p>举例，一个10 5 3内存的空间，此时需要存入一个6大小的数据，那么就存放在10里面，变成4 5 3；后续又需要存放一个3大小的数据，就变成1 5 3。</p>
<h3 id="heap_5"><a class="markdownIt-Anchor" href="#heap_5"></a> heap_5</h3>
<ul>
<li>相比于Heap_4，Heap_5并不局限于管理一个大数组：<strong>它可以管理多块、分隔开的内存</strong>。</li>
</ul>
<h2 id="heap相关的函数"><a class="markdownIt-Anchor" href="#heap相关的函数"></a> heap相关的函数</h2>
<h3 id="pvportmallocvportfree"><a class="markdownIt-Anchor" href="#pvportmallocvportfree"></a> pvPortMalloc/vPortFree</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> * <span class="title function_">pvPortMalloc</span><span class="params">( <span class="type">size_t</span> xWantedSize )</span>;	<span class="comment">// 分配内存，如果分配内存不成功，则返回值为NULL。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vPortFree</span><span class="params">( <span class="type">void</span> * pv )</span>;	<span class="comment">// 释放内存</span></span><br></pre></td></tr></table></figure>
<p>作用：<strong>分配内存、释放内存</strong>。</p>
<p>如果分配内存不成功，则返回值为NULL。</p>
<h3 id="xportgetfreeheapsize"><a class="markdownIt-Anchor" href="#xportgetfreeheapsize"></a> xPortGetFreeHeapSize</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">xPortGetFreeHeapSize</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure>
<p>作用：<strong>当前还有多少空闲内存</strong>，heap_3中无法使用。</p>
<h3 id="xportgetminimumeverfreeheapsize"><a class="markdownIt-Anchor" href="#xportgetminimumeverfreeheapsize"></a> xPortGetMinimumEverFreeHeapSize</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">size_t</span> <span class="title function_">xPortGetMinimumEverFreeHeapSize</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure>
<p>作用：空闲内存容量的最小值。</p>
<p>注意：只有heap_4、heap_5支持此函数</p>
<h1 id="任务管理"><a class="markdownIt-Anchor" href="#任务管理"></a> 任务管理</h1>
<p><strong>任务状态</strong>：就绪态、阻塞态、挂起态</p>
<h2 id="任务创建"><a class="markdownIt-Anchor" href="#任务创建"></a> 任务创建</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BaseType_t <span class="title function_">xTaskCreate</span><span class="params">( TaskFunction_t pxTaskCode, <span class="comment">// 函数指针, 任务函数</span></span></span><br><span class="line"><span class="params">                        <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcName, <span class="comment">// 任务的名字，不用太在意</span></span></span><br><span class="line"><span class="params">                        <span class="type">const</span> configSTACK_DEPTH_TYPE usStackDepth, <span class="comment">// 栈大小,单位为word,10表示40字节</span></span></span><br><span class="line"><span class="params">                        <span class="type">void</span> * <span class="type">const</span> pvParameters, <span class="comment">// 调用任务函数时传入的参数</span></span></span><br><span class="line"><span class="params">                        UBaseType_t uxPriority,    <span class="comment">// 优先级</span></span></span><br><span class="line"><span class="params">                        TaskHandle_t * <span class="type">const</span> pxCreatedTask )</span>; <span class="comment">// 任务句柄, 以后使用它来操作这个任务</span></span><br><span class="line"><span class="comment">//	成功：pdPASS；</span></span><br><span class="line"><span class="comment">//	失败：errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY(失败原因只有内存不足)</span></span><br></pre></td></tr></table></figure>
<p><strong>同时创建两个程序，同优先级下，先执行最后创建的。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">xTaskCreate(vTask1, <span class="string">&quot;Task 1&quot;</span>, <span class="number">1000</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">xTaskCreate(vTask2, <span class="string">&quot;Task 2&quot;</span>, <span class="number">1000</span>, <span class="literal">NULL</span>, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">// 在执行程序时，先执行vTask2，再到Task1，任务本质是一种链表结构。</span></span><br></pre></td></tr></table></figure>
<p><strong>多个任务可以使用同一个函数</strong>，怎么体现它们的差别？</p>
<ul>
<li><strong>栈不同</strong></li>
<li>创建任务时可以传入不同的参数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *pcTextForTask1 = <span class="string">&quot;T1 run\r\n&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> *pcTextForTask2 = <span class="string">&quot;T2 run\r\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">	prvSetupHardware();</span><br><span class="line">	</span><br><span class="line">	xTaskCreate(vTaskFunction, <span class="string">&quot;Task 1&quot;</span>, <span class="number">1000</span>, (<span class="type">void</span> *)pcTextForTask1, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">	xTaskCreate(vTaskFunction, <span class="string">&quot;Task 2&quot;</span>, <span class="number">1000</span>, (<span class="type">void</span> *)pcTextForTask2, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 启动调度器 */</span></span><br><span class="line">	vTaskStartScheduler();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 如果程序运行到了这里就表示出错了, 一般是内存不足 */</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="任务删除"><a class="markdownIt-Anchor" href="#任务删除"></a> 任务删除</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelete</span><span class="params">( TaskHandle_t xTaskToDelete )</span>;</span><br></pre></td></tr></table></figure>
<p><strong>Q：怎么删除任务？</strong></p>
<ol>
<li><strong>自杀</strong>：vTaskDelete(NULL)</li>
<li><strong>被杀</strong>：别的任务执行vTaskDelete(pvTaskCode)，pvTaskCode是自己的句柄</li>
<li><strong>杀人</strong>：执行vTaskDelete(pvTaskCode)，pvTaskCode是别的任务的句柄</li>
</ol>
<h2 id="任务优先级与tick"><a class="markdownIt-Anchor" href="#任务优先级与tick"></a> 任务优先级与Tick</h2>
<p><strong>高优先级</strong>的任务<strong>先运行</strong>，可选择<strong>0 ~ (configMAX_PRIORITIES – 1)</strong></p>
<ul>
<li>FreeRTOS会确保<strong>最高优先级</strong>的、可运行的任务立马<strong>执行</strong></li>
<li>对于<strong>相同优先级</strong>的可执行任务，<strong>轮流执行</strong></li>
</ul>
<p>对于<strong>相同优先级</strong>的，通过<strong>Tick（滴答）中断</strong>实现，但<strong>它并不精确</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vTaskDelay(<span class="number">2</span>);  <span class="comment">// 等待2个Tick，假设configTICK_RATE_HZ=100, Tick周期时10ms, 等待20ms</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 还可以使用pdMS_TO_TICKS宏把ms转换为tick</span></span><br><span class="line">vTaskDelay(pdMS_TO_TICKS(<span class="number">100</span>));	 <span class="comment">// 等待100ms</span></span><br></pre></td></tr></table></figure>
<p>可以使用<strong>uxTaskPriorityGet来获得任务的优先级</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxTaskPriorityGet</span><span class="params">( <span class="type">const</span> TaskHandle_t xTask )</span>;</span><br></pre></td></tr></table></figure>
<p>使用<strong>vTaskPrioritySet 来设置任务的优先级</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskPrioritySet</span><span class="params">( TaskHandle_t xTask,				<span class="comment">//具体任务</span></span></span><br><span class="line"><span class="params">                       UBaseType_t uxNewPriority )</span>;		<span class="comment">//新的优先级</span></span><br></pre></td></tr></table></figure>
<h2 id="任务状态"><a class="markdownIt-Anchor" href="#任务状态"></a> 任务状态</h2>
<img src="https://s2.loli.net/2025/05/08/UseZF9RQ5Y1kwAt.png" style="zoom: 60%;" />
<h2 id="delay函数"><a class="markdownIt-Anchor" href="#delay函数"></a> Delay函数</h2>
<ul>
<li><strong>vTaskDelay</strong>：<strong>至少等待指定个数的Tick Interrupt</strong>才能变为就绪状态</li>
<li><strong>vTaskDelayUntil</strong>：<strong>等待到指定的绝对时刻</strong>，才能变为就绪态。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskDelay</span><span class="params">( <span class="type">const</span> TickType_t xTicksToDelay )</span>; <span class="comment">/* xTicksToDelay: 等待多少给Tick */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* pxPreviousWakeTime: 上一次被唤醒的时间</span></span><br><span class="line"><span class="comment"> * xTimeIncrement: 要阻塞到(pxPreviousWakeTime + xTimeIncrement)</span></span><br><span class="line"><span class="comment"> * 单位都是Tick Count</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskDelayUntil</span><span class="params">( TickType_t * <span class="type">const</span> pxPreviousWakeTime,</span></span><br><span class="line"><span class="params">                            <span class="type">const</span> TickType_t xTimeIncrement )</span>;</span><br></pre></td></tr></table></figure>
<h2 id="空闲任务及其钩子函数"><a class="markdownIt-Anchor" href="#空闲任务及其钩子函数"></a> 空闲任务及其钩子函数</h2>
<p><strong>空闲任务</strong>(Idle任务)的作用：<strong>释放被删除的任务的内存</strong></p>
<p>在使用<code>vTaskStartScheduler() </code>函数来创建、启动调度器时，这个函数内部会创建空闲任务：</p>
<ul>
<li>空闲<strong>任务优先级为0</strong>：它不能阻碍用户任务运行</li>
<li>空闲任务要么处于就绪态，要么处于运行态，<strong>永远不会阻塞</strong></li>
</ul>
<p>如果使用<code>vTaskDelete() </code>来删除任务，那么你就要<strong>确保空闲任务有机会执行</strong>，否则就<strong>无法释放被删除任务的内存</strong>。</p>
<p>可以<strong>添加一个空闲任务的钩子函数</strong>(Idle Task Hook Functions)，空闲任务的循环每执行一次，就会调用一次钩子函数。</p>
<p><strong>钩子函数作用</strong></p>
<ul>
<li><strong>执行一些低优先级的、后台的、需要连续执行的函数</strong></li>
<li><strong>测量系统的空闲时间</strong>：空闲任务能被执行就意味着所有的高优先级任务都停止了，所以测量空闲任务占据的时间，就可以算出处理器占用率。</li>
<li><strong>让系统进入省电模式</strong>：空闲任务能被执行就意味着没有重要的事情要做，当然可以进入省电模式了。</li>
</ul>
<p><strong>钩子函数限制</strong></p>
<ul>
<li>不能导致空闲任务进入阻塞状态、暂停状态</li>
<li>如果你会使用<code>vTaskDelete() </code>来删除任务，那么钩子函数要非常高效地执行。如果空闲任务移植卡在钩子函数里的话，它就无法释放内存。</li>
</ul>
<p><strong>如何使用钩子函数</strong></p>
<p><code>FreeRTOS\Source\tasks.c</code>中设置<strong>configUSE_IDLE_HOOK = 1</strong>，实现<code>vApplicationIdleHook</code>函数。</p>
<h2 id="调度算法"><a class="markdownIt-Anchor" href="#调度算法"></a> 调度算法</h2>
<table>
<thead>
<tr>
<th style="text-align:center">配置项</th>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">C</th>
<th style="text-align:center">D</th>
<th style="text-align:center">E</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">configUSE_PREEMPTION</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">configUSE_TIME_SLICING</td>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">x</td>
</tr>
<tr>
<td style="text-align:center">configIDLE_SHOULD_YIELD</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">x</td>
</tr>
<tr>
<td style="text-align:center">说明</td>
<td style="text-align:center">常用</td>
<td style="text-align:center">很少用</td>
<td style="text-align:center">很少用</td>
<td style="text-align:center">很少用</td>
<td style="text-align:center">几乎不用</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>A：可抢占+时间片轮转+空闲任务让步</strong></li>
<li>B：可抢占+时间片轮转+空闲任务不让步</li>
<li>C：可抢占+非时间片轮转+空闲任务让步</li>
<li>D：可抢占+非时间片轮转+空闲任务不让步</li>
<li>E：合作调度</li>
</ul>
<h1 id="同步互斥与通信"><a class="markdownIt-Anchor" href="#同步互斥与通信"></a> 同步互斥与通信</h1>
<p>能实现同步、互斥的内核方法有：<strong>任务通知</strong>(task notification)、<strong>队列</strong>(queue)、<strong>事件组</strong>(event group)、<strong>信号量</strong>(semaphoe)、<strong>互斥量</strong>(mutex)</p>
<ul>
<li>队列：
<ul>
<li>里面可以放任意数据，可以放多个数据</li>
<li>任务、ISR都可以放入数据；任务、ISR都可以从中读出数据</li>
</ul>
</li>
<li>事件组：
<ul>
<li>一个事件用一bit表示，1表示事件发生了，0表示事件没发生</li>
<li>可以用来表示事件、事件的组合发生了，不能传递数据</li>
<li>有广播效果：事件或事件的组合发生了，等待它的多个任务都会被唤醒</li>
</ul>
</li>
<li>信号量：
<ul>
<li>核心是&quot;计数值&quot;</li>
<li>任务、ISR释放信号量时让计数值加1</li>
<li>任务、ISR获得信号量时，让计数值减1</li>
</ul>
</li>
<li>任务通知：
<ul>
<li>核心是任务的TCB里的数值</li>
<li>会被覆盖</li>
<li>发通知给谁？必须指定接收任务</li>
<li>只能由接收任务本身获取该通知</li>
</ul>
</li>
<li>互斥量：
<ul>
<li>数值只有0或1</li>
<li>谁获得互斥量，就必须由谁释放同一个互斥量</li>
</ul>
</li>
</ul>
<img src="https://s2.loli.net/2025/05/08/xI27PMC63fymOVl.png" style="zoom: 60%;" />
<h1 id="队列"><a class="markdownIt-Anchor" href="#队列"></a> 队列</h1>
<h2 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性</h2>
<ul>
<li>队列可以包含若干个数据：队列中有若干项，这被称为&quot;长度&quot;(length)</li>
<li>创建队列时就要指定长度、数据大小（大小固定）</li>
<li>数据的操作采用先进先出的方法(FIFO，First In First Out)：写数据时放到尾部，读数据时从头部读</li>
<li>也可以强制写队列头部：覆盖头部数据</li>
</ul>
<img src="https://s2.loli.net/2025/05/08/kEh7UwuB9b2PZYO.png" style="zoom: 25%;" />
<p>队列传输数据两种方法：</p>
<ul>
<li>拷贝：把<strong>数据、把变量的值</strong>复制进队列</li>
<li>引用：把<strong>数据、把变量的地址</strong>复制进队列</li>
</ul>
<p>有<strong>多个任务在等待同一个队列的数据</strong>。当<strong>队列中有数据</strong>时，<strong>哪个任务会进入就绪态</strong>？</p>
<ul>
<li><strong>优先级最高</strong>的任务</li>
<li>如果大家的<strong>优先级相同</strong>，那<strong>等待时间最久</strong>的任务会进入就绪态</li>
</ul>
<h2 id="队列函数"><a class="markdownIt-Anchor" href="#队列函数"></a> 队列函数</h2>
<h3 id="创建队列"><a class="markdownIt-Anchor" href="#创建队列"></a> 创建队列</h3>
<ul>
<li><strong>动态</strong>分配内存：<strong>xQueueCreate</strong>，队列的内存在函数内部动态分配</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">QueueHandle_t <span class="title function_">xQueueCreate</span><span class="params">( UBaseType_t uxQueueLength, UBaseType_t uxItemSize )</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">uxQueueLength</td>
<td style="text-align:center">队列长度，最多能存放多少个数据(item)</td>
</tr>
<tr>
<td style="text-align:center">uxItemSize</td>
<td style="text-align:center">每个数据(item)的大小：以字节为单位</td>
</tr>
<tr>
<td style="text-align:center">返回值</td>
<td style="text-align:center">非0：成功，返回句柄，以后使用句柄来操作队列 NULL：失败，因为内存不足</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>静态</strong>分配内存：<strong>xQueueCreateStatic</strong>，队列的内存要事先分配好</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">QueueHandle_t <span class="title function_">xQueueCreateStatic</span><span class="params">(UBaseType_t uxQueueLength,</span></span><br><span class="line"><span class="params">                           UBaseType_t uxItemSize, <span class="type">uint8_t</span> *pucQueueStorageBuffer,</span></span><br><span class="line"><span class="params">                           StaticQueue_t *pxQueueBuffer)</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">uxQueueLength</td>
<td style="text-align:center">队列长度，最多能存放多少个数据(item)</td>
</tr>
<tr>
<td style="text-align:center">uxItemSize</td>
<td style="text-align:center">每个数据(item)的大小：以字节为单位</td>
</tr>
<tr>
<td style="text-align:center">pucQueueStorageBuffer</td>
<td style="text-align:center">如果uxItemSize非0，pucQueueStorageBuffer必须指向一个uint8_t数组， 此数组大小至少为&quot;uxQueueLength * uxItemSize&quot;</td>
</tr>
<tr>
<td style="text-align:center">pxQueueBuffer</td>
<td style="text-align:center">必须执行一个StaticQueue_t结构体，用来保存队列的数据结构</td>
</tr>
<tr>
<td style="text-align:center">返回值</td>
<td style="text-align:center">非0：成功，返回句柄，以后使用句柄来操作队列 NULL：失败，因为pxQueueBuffer为NULL</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> QUEUE_LENGTH 10</span></span><br><span class="line"> <span class="meta">#<span class="keyword">define</span> ITEM_SIZE sizeof( uint32_t )</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// xQueueBuffer用来保存队列结构体</span></span><br><span class="line"> StaticQueue_t xQueueBuffer;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// ucQueueStorage 用来保存队列的数据</span></span><br><span class="line"> <span class="comment">// 大小为：队列长度 * 数据大小</span></span><br><span class="line"> <span class="type">uint8_t</span> ucQueueStorage[QUEUE_LENGTH * ITEM_SIZE];</span><br><span class="line"> </span><br><span class="line"> <span class="type">void</span> <span class="title function_">vATask</span><span class="params">( <span class="type">void</span> *pvParameters )</span></span><br><span class="line"> &#123;</span><br><span class="line">	QueueHandle_t xQueue1;</span><br><span class="line">	<span class="comment">// 创建队列: 可以容纳QUEUE_LENGTH个数据，每个数据大小是ITEM_SIZE</span></span><br><span class="line">	xQueue1 = xQueueCreateStatic( QUEUE_LENGTH,</span><br><span class="line">						  ITEM_SIZE,ucQueueStorage,</span><br><span class="line">						  &amp;xQueueBuffer); </span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="复位"><a class="markdownIt-Anchor" href="#复位"></a> 复位</h3>
<p>使用过程中可以调用<code>xQueueReset()</code>把队列恢复为初始状态</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* pxQueue : 复位哪个队列;</span></span><br><span class="line"><span class="comment"> * 返回值: pdPASS(必定成功)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueReset</span><span class="params">( QueueHandle_t pxQueue)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h3>
<p>删除队列的函数为<code>vQueueDelete()</code>，<strong>只能删除使用动态方法创建的队列</strong>，它会释放内存</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vQueueDelete</span><span class="params">( QueueHandle_t xQueue )</span>;</span><br></pre></td></tr></table></figure>
<h3 id="写队列"><a class="markdownIt-Anchor" href="#写队列"></a> 写队列</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendToBack</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                            <span class="type">const</span> <span class="type">void</span> *pvItemToQueue,</span></span><br><span class="line"><span class="params">                            TickType_t xTicksToWait)</span>;</span><br><span class="line"><span class="comment">/* 等同于xQueueSendToBack，往队列尾部写入数据，如果没有空间，阻塞时间为xTicksToWait */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSend</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                      <span class="type">const</span> <span class="type">void</span> *pvItemToQueue,</span></span><br><span class="line"><span class="params">                      TickType_t xTicksToWait)</span>;</span><br><span class="line"><span class="comment">/* 往队列尾部写入数据，此函数可以在中断函数中使用，不可阻塞 */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendToBackFromISR</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                                   <span class="type">const</span> <span class="type">void</span> *pvItemToQueue,</span></span><br><span class="line"><span class="params">                                   BaseType_t *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"><span class="comment">/* 往队列头部写入数据，如果没有空间，阻塞时间为xTicksToWait */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendToFront</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                             <span class="type">const</span> <span class="type">void</span> *pvItemToQueue,</span></span><br><span class="line"><span class="params">                             TickType_t xTicksToWait)</span>;</span><br><span class="line"><span class="comment">/* 往队列头部写入数据，此函数可以在中断函数中使用，不可阻塞 */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueSendToFrontFromISR</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                                    <span class="type">const</span> <span class="type">void</span> *pvItemToQueue,</span></span><br><span class="line"><span class="params">                                    BaseType_t *pxHigherPriorityTaskWoken)</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">xQueue</td>
<td style="text-align:center">队列句柄，要写哪个队列</td>
</tr>
<tr>
<td style="text-align:center">pvItemToQueue</td>
<td style="text-align:center">数据指针，这个数据的值会被复制进队列， 复制多大的数据？在创建队列时已经指定了数据大小</td>
</tr>
<tr>
<td style="text-align:center">xTicksToWait</td>
<td style="text-align:center">如果队列满则无法写入新数据，可以让任务进入阻塞状态， xTicksToWait表示阻塞的最大时间(Tick Count)。 如果被设为0，无法写入数据时函数会立刻返回； 如果被设为portMAX_DELAY，则会一直阻塞直到有空间可写</td>
</tr>
<tr>
<td style="text-align:center">返回值</td>
<td style="text-align:center">pdPASS：数据成功写入了队列 errQUEUE_FULL：写入失败，因为队列满了。</td>
</tr>
</tbody>
</table>
<h3 id="读队列"><a class="markdownIt-Anchor" href="#读队列"></a> 读队列</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在任务中使用</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueReceive</span><span class="params">( QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                          <span class="type">void</span> * <span class="type">const</span> pvBuffer,</span></span><br><span class="line"><span class="params">                          TickType_t xTicksToWait)</span>;</span><br><span class="line"><span class="comment">// 在ISR中使用</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueReceiveFromISR</span><span class="params">(QueueHandle_t    xQueue,</span></span><br><span class="line"><span class="params">                                <span class="type">void</span>             *pvBuffer,</span></span><br><span class="line"><span class="params">                                BaseType_t       *pxTaskWoken)</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">xQueue</td>
<td style="text-align:center">队列句柄，要读哪个队列</td>
</tr>
<tr>
<td style="text-align:center">pvBuffer</td>
<td style="text-align:center">bufer指针，队列的数据会被复制到这个buffer 复制多大的数据？在创建队列时已经指定了数据大小</td>
</tr>
<tr>
<td style="text-align:center">xTicksToWait</td>
<td style="text-align:center">果队列空则无法读出数据，可以让任务进入阻塞状态， xTicksToWait表示阻塞的最大时间(Tick Count)。 如果被设为0，无法读出数据时函数会立刻返回； 如果被设为portMAX_DELAY，则会一直阻塞直到有数据可写</td>
</tr>
<tr>
<td style="text-align:center">返回值</td>
<td style="text-align:center">pdPASS：从队列读出数据入 errQUEUE_EMPTY：读取失败，因为队列空了。</td>
</tr>
</tbody>
</table>
<h3 id="查询"><a class="markdownIt-Anchor" href="#查询"></a> 查询</h3>
<p>可以查询队列中有多少个数据、有多少空余空间</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*返回队列中可用数据的个数*/</span></span><br><span class="line">UBaseType_t <span class="title function_">uxQueueMessagesWaiting</span><span class="params">( <span class="type">const</span> QueueHandle_t xQueue )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*返回队列中可用空间的个数*/</span></span><br><span class="line">UBaseType_t <span class="title function_">uxQueueSpacesAvailable</span><span class="params">( <span class="type">const</span> QueueHandle_t xQueue )</span>;</span><br></pre></td></tr></table></figure>
<h3 id="覆盖偷看"><a class="markdownIt-Anchor" href="#覆盖偷看"></a> 覆盖/偷看</h3>
<p><strong>当队列长度为1</strong>时，可以使用<code>xQueueOverwrite()</code>或<code>xQueueOverwriteFromISR()</code>来<strong>覆盖数据</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 覆盖队列</span></span><br><span class="line"><span class="comment"> * xQueue: 写哪个队列</span></span><br><span class="line"><span class="comment"> * pvItemToQueue: 数据地址</span></span><br><span class="line"><span class="comment"> * 返回值: pdTRUE表示成功, pdFALSE表示失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueueOverwrite</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                           <span class="type">const</span> <span class="type">void</span> * pvItemToQueue)</span>;</span><br><span class="line">BaseType_t <span class="title function_">xQueueOverwriteFromISR</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                           		  <span class="type">const</span> <span class="type">void</span> * pvItemToQueue,</span></span><br><span class="line"><span class="params">                           		  BaseType_t *pxHigherPriorityTaskWoken)</span>;</span><br></pre></td></tr></table></figure>
<p>如果想让<strong>队列中的数据供多方读取</strong>，也就是说<strong>读取时不要移除数据</strong>，那么可以<strong>使用&quot;窥视&quot;</strong>，也就是<code>xQueuePeek()</code>或<code>xQueuePeekFromISR()</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 偷看队列</span></span><br><span class="line"><span class="comment"> * xQueue: 偷看哪个队列</span></span><br><span class="line"><span class="comment"> * pvItemToQueue: 数据地址, 用来保存复制出来的数据</span></span><br><span class="line"><span class="comment"> * xTicksToWait: 没有数据的话阻塞一会</span></span><br><span class="line"><span class="comment"> * 返回值: pdTRUE表示成功, pdFALSE表示失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xQueuePeek</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                      <span class="type">void</span> * <span class="type">const</span> pvBuffer,</span></span><br><span class="line"><span class="params">                      TickType_t xTicksToWait)</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xQueuePeekFromISR</span><span class="params">(QueueHandle_t xQueue,</span></span><br><span class="line"><span class="params">                             <span class="type">void</span> *pvBuffer,</span></span><br><span class="line"><span class="params">                             TickType_t xTicksToWait)</span>;</span><br></pre></td></tr></table></figure>
<h1 id="信息量"><a class="markdownIt-Anchor" href="#信息量"></a> 信息量</h1>
<h2 id="特性-2"><a class="markdownIt-Anchor" href="#特性-2"></a> 特性</h2>
<ul>
<li>信号：起通知作用</li>
<li>量：还可以用来表示资源的数量
<ul>
<li>当&quot;量&quot;只有0、1两个取值时，它就是&quot;<strong>二进制</strong>信号量&quot;(Binary Semaphores)</li>
<li>当&quot;量&quot;没有限制时，它就是&quot;<strong>计数型</strong>信号量&quot;(Counting Semaphores)</li>
</ul>
</li>
<li>支持的动作：&quot;give&quot;给出资源，计数值加1；&quot;take&quot;获得资源，计数值减1</li>
</ul>
<h2 id="函数"><a class="markdownIt-Anchor" href="#函数"></a> 函数</h2>
<h3 id="创建"><a class="markdownIt-Anchor" href="#创建"></a> 创建</h3>
<p>创建<strong>二进制信号量</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建一个二进制信号量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数内部会分配信号量结构体 </span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateBinary</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个二进制信号量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateBinaryStatic</span><span class="params">(StaticSemaphore_t *pxSemaphoreBuffer)</span>;</span><br></pre></td></tr></table></figure>
<p>创建<strong>计数型信号量</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建一个计数型信号量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数内部会分配信号量结构体 </span></span><br><span class="line"><span class="comment"> * uxMaxCount: 最大计数值</span></span><br><span class="line"><span class="comment"> * uxInitialCount: 初始计数值</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCounting</span><span class="params">(UBaseType_t uxMaxCount, UBaseType_t uxInitialCount)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个计数型信号量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span></span><br><span class="line"><span class="comment"> * uxMaxCount: 最大计数值</span></span><br><span class="line"><span class="comment"> * uxInitialCount: 初始计数值</span></span><br><span class="line"><span class="comment"> * pxSemaphoreBuffer: StaticSemaphore_t结构体指针</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateCountingStatic</span><span class="params">( UBaseType_t uxMaxCount, </span></span><br><span class="line"><span class="params">                                                 UBaseType_t uxInitialCount, </span></span><br><span class="line"><span class="params">                                                 StaticSemaphore_t *pxSemaphoreBuffer )</span>;</span><br></pre></td></tr></table></figure>
<h3 id="删除-2"><a class="markdownIt-Anchor" href="#删除-2"></a> 删除</h3>
<p><strong>动态创建的信号量</strong>，不再需要它们时，可以删除它们以回收内存。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* xSemaphore: 信号量句柄，你要删除哪个信号量 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vSemaphoreDelete</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br></pre></td></tr></table></figure>
<h3 id="givetake"><a class="markdownIt-Anchor" href="#givetake"></a> give/take</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在任务中使用</span></span><br><span class="line"><span class="comment">// xSemaphore信号量句柄，释放哪个信号量</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreGive</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// xSemaphore信号量句柄，获取哪个信号量</span></span><br><span class="line"><span class="comment">//如果无法马上获得信号量，阻塞一会。	  0：不阻塞，马上返回</span></span><br><span class="line"><span class="comment">//								portMAX_DELAY: 一直阻塞直到成功</span></span><br><span class="line"><span class="comment">//								其他值: 阻塞的Tick个数</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreTake</span><span class="params">(SemaphoreHandle_t xSemaphore, TickType_t xTicksToWait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在ISR中使用</span></span><br><span class="line"><span class="comment">// xSemaphore信号量句柄，释放哪个信号量;</span></span><br><span class="line"><span class="comment">// 如果释放信号量导致更高优先级的任务变为了就绪态，则*pxHigherPriorityTaskWoken = pdTRUE</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreGiveFromISR</span><span class="params">(SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                        		 BaseType_t *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"><span class="comment">// xSemaphore信号量句柄，获取哪个信号量</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreTakeFromISR</span><span class="params">(SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                        		 BaseType_t *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h1 id="互斥值"><a class="markdownIt-Anchor" href="#互斥值"></a> 互斥值</h1>
<h2 id="特性-3"><a class="markdownIt-Anchor" href="#特性-3"></a> 特性</h2>
<p><strong>FreeRTOS的互斥锁，并没有在代码上实现谁上锁，就只能由谁开锁，只是约定。</strong></p>
<ul>
<li>互斥量初始值为1</li>
<li>任务A想访问临界资源，先获得并占有互斥量，然后开始访问</li>
<li>任务B也想访问临界资源，也要先获得互斥量：被别人占有了，于是阻塞</li>
<li>任务A使用完毕，释放互斥量；任务B被唤醒、得到并占有互斥量，然后开始访问临界资源</li>
<li>任务B使用完毕，释放互斥量</li>
</ul>
<h2 id="函数-2"><a class="markdownIt-Anchor" href="#函数-2"></a> 函数</h2>
<p>要想使用互斥量，需要在配置文件FreeRTOSConfig.h中定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_MUTEXES 1</span></span><br></pre></td></tr></table></figure>
<h3 id="创建-2"><a class="markdownIt-Anchor" href="#创建-2"></a> 创建</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建一个互斥量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数内部会分配互斥量结构体 </span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功 */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateMutex</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个互斥量，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数无需动态分配内存，所以需要先有一个StaticSemaphore_t结构体，并传入它的指针</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功 */</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateMutexStatic</span><span class="params">( StaticSemaphore_t *pxMutexBuffer )</span>;</span><br></pre></td></tr></table></figure>
<h3 id="其他函数"><a class="markdownIt-Anchor" href="#其他函数"></a> 其他函数</h3>
<p><strong>互斥量不能在ISR中使用</strong>，ISR需要快速运行，不能阻塞太久。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* xSemaphore: 信号量句柄，你要删除哪个信号量, 互斥量也是一种信号量 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vSemaphoreDelete</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放 */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreGive</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放(ISR版本) */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreGiveFromISR</span><span class="params">(SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                       			 BaseType_t *pxHigherPriorityTaskWoken)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获得 */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreTake</span><span class="params">(SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                   		  TickType_t xTicksToWait)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获得(ISR版本) */</span></span><br><span class="line">xSemaphoreGiveFromISR(SemaphoreHandle_t xSemaphore,</span><br><span class="line">                      BaseType_t *pxHigherPriorityTaskWoken);</span><br></pre></td></tr></table></figure>
<h2 id="优先级反转"><a class="markdownIt-Anchor" href="#优先级反转"></a> 优先级反转</h2>
<p>假设任务A、B都想使用串口，A优先级比B低：</p>
<ul>
<li>任务A获得了串口的互斥量</li>
<li>任务B也想使用串口，它将会阻塞、等待A释放互斥量</li>
<li><strong>高优先级的任务，被低优先级的任务延迟，这被称为&quot;优先级反转&quot;</strong>(priority inversion)</li>
</ul>
<p><strong>互斥量可以通过&quot;优先级继承&quot;</strong>，临时提高<strong>有锁且低优先级的程序</strong>，可以很大程度**解决&quot;优先级反转&quot;**的问题</p>
<h2 id="递归锁"><a class="markdownIt-Anchor" href="#递归锁"></a> 递归锁</h2>
<p><strong>递归锁实现了：谁上锁就由谁解锁</strong></p>
<h3 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h3>
<p>假设有2个互斥量M1、M2，2个任务A、B：</p>
<ul>
<li>A获得了互斥量M1</li>
<li>B获得了互斥量M2</li>
<li>A还要获得互斥量M2才能运行，结果A阻塞</li>
<li>B还要获得互斥量M1才能运行，结果B阻塞</li>
<li>A、B都阻塞，再无法释放它们持有的互斥量</li>
<li>死锁发生！</li>
</ul>
<p>解决这样问题可以使用递归锁</p>
<ul>
<li>任务A获得递归锁M后，它还可以多次去获得这个锁</li>
<li>&quot;take&quot;了N次，要&quot;give&quot;N次，这个锁才会被释放</li>
</ul>
<h3 id="函数-3"><a class="markdownIt-Anchor" href="#函数-3"></a> 函数</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建一个递归锁，返回它的句柄，此函数内部会分配互斥量结构体 </span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功	*/</span></span><br><span class="line">SemaphoreHandle_t <span class="title function_">xSemaphoreCreateRecursiveMutex</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 释放 */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreGiveRecursive</span><span class="params">( SemaphoreHandle_t xSemaphore )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 获得 */</span></span><br><span class="line">BaseType_t <span class="title function_">xSemaphoreTakeRecursive</span><span class="params">(SemaphoreHandle_t xSemaphore,</span></span><br><span class="line"><span class="params">                   				   TickType_t xTicksToWait)</span>;</span><br></pre></td></tr></table></figure>
<h1 id="事件组"><a class="markdownIt-Anchor" href="#事件组"></a> 事件组</h1>
<h2 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h2>
<ul>
<li>事件组的每一位表示一个事件</li>
<li>每一位事件的含义由程序员决定，比如：Bit0表示用来串口是否就绪，Bit1表示按键是否被按下</li>
<li>这些位，值为1表示事件发生了，值为0表示事件没发生</li>
<li>一个或多个任务、ISR都可以去写这些位；一个或多个任务、ISR都可以去读这些位</li>
<li>可以等待某一位、某些位中的任意一个，也可以等待多位</li>
</ul>
<img src="https://s2.loli.net/2025/05/08/BFbDhSE5m76Cjx2.png" style="zoom: 67%;" />
<p>事件组用一个整数来表示，<strong>高8位留给内核使用</strong>，只能用其他的位来表示事件</p>
<ul>
<li>
<p>如果configUSE_16_BIT_TICKS是1，那么这个整数就是16位的，低8位用来表示事件</p>
</li>
<li>
<p>如果configUSE_16_BIT_TICKS是0，那么这个整数就是32位的，低24位用来表示事件</p>
</li>
<li>
<p>configUSE_16_BIT_TICKS是用来表示Tick Count的，怎么会影响事件组？这只是基于效率来考虑</p>
<ul>
<li>如果configUSE_16_BIT_TICKS是1，就表示该处理器使用16位更高效，所以事件组也使用16位</li>
<li>如果configUSE_16_BIT_TICKS是0，就表示该处理器使用32位更高效，所以事件组也使用32位</li>
</ul>
</li>
</ul>
<h2 id="函数-4"><a class="markdownIt-Anchor" href="#函数-4"></a> 函数</h2>
<h3 id="创建-3"><a class="markdownIt-Anchor" href="#创建-3"></a> 创建</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 创建一个事件组，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数内部会分配事件组结构体 </span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventGroupHandle_t <span class="title function_">xEventGroupCreate</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 创建一个事件组，返回它的句柄。</span></span><br><span class="line"><span class="comment"> * 此函数无需动态分配内存，所以需要先有一个StaticEventGroup_t结构体，并传入它的指针</span></span><br><span class="line"><span class="comment"> * 返回值: 返回句柄，非NULL表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventGroupHandle_t <span class="title function_">xEventGroupCreateStatic</span><span class="params">( StaticEventGroup_t * pxEventGroupBuffer)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="删除-3"><a class="markdownIt-Anchor" href="#删除-3"></a> 删除</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*	xEventGroup: 事件组句柄，你要删除哪个事件组	*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vEventGroupDelete</span><span class="params">( EventGroupHandle_t xEventGroup )</span></span><br></pre></td></tr></table></figure>
<h3 id="设置事件"><a class="markdownIt-Anchor" href="#设置事件"></a> 设置事件</h3>
<ul>
<li>在任务中使用<code>xEventGroupSetBits()</code></li>
<li>在ISR中使用<code>xEventGroupSetBitsFromISR()</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 设置事件组中的位</span></span><br><span class="line"><span class="comment"> * xEventGroup: 哪个事件组</span></span><br><span class="line"><span class="comment"> * uxBitsToSet: 设置哪些位? </span></span><br><span class="line"><span class="comment"> *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1</span></span><br><span class="line"><span class="comment"> *              可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0</span></span><br><span class="line"><span class="comment"> * 返回值: 返回原来的事件值(没什么意义, 因为很可能已经被其他任务修改了)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">EventBits_t <span class="title function_">xEventGroupSetBits</span><span class="params">(EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                               <span class="type">const</span> EventBits_t uxBitsToSet)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置事件组中的位</span></span><br><span class="line"><span class="comment"> * xEventGroup: 哪个事件组</span></span><br><span class="line"><span class="comment"> * uxBitsToSet: 设置哪些位? </span></span><br><span class="line"><span class="comment"> *              如果uxBitsToSet的bitX, bitY为1, 那么事件组中的bitX, bitY被设置为1</span></span><br><span class="line"><span class="comment"> *              可以用来设置多个位，比如 0x15 就表示设置bit4, bit2, bit0</span></span><br><span class="line"><span class="comment"> * pxHigherPriorityTaskWoken: 有没有导致更高优先级的任务进入就绪态? pdTRUE-有, pdFALSE-没有</span></span><br><span class="line"><span class="comment"> * 返回值: pdPASS-成功, pdFALSE-失败</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xEventGroupSetBitsFromISR</span><span class="params">( EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">									  <span class="type">const</span> EventBits_t uxBitsToSet,</span></span><br><span class="line"><span class="params">									  BaseType_t * pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure>
<p><code>xEventGroupSetBitsFromISR</code>函数<strong>不是直接去设置事件组</strong>，而是给一个FreeRTOS后台任务(daemon task)发送队列数据，由这个任务来设置事件组。</p>
<h3 id="等待事件"><a class="markdownIt-Anchor" href="#等待事件"></a> 等待事件</h3>
<p>使用<code>xEventGroupWaitBits</code>来等待事件，可以等待某一位、某些位中的任意一个，也可以等待多位；等到期望的事件后，还可以清除某些位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EventBits_t <span class="title function_">xEventGroupWaitBits</span><span class="params">( EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                                 <span class="type">const</span> EventBits_t uxBitsToWaitFor,</span></span><br><span class="line"><span class="params">                                 <span class="type">const</span> BaseType_t xClearOnExit,</span></span><br><span class="line"><span class="params">                                 <span class="type">const</span> BaseType_t xWaitForAllBits,</span></span><br><span class="line"><span class="params">                                 TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">xEventGroup</td>
<td style="text-align:center">等待哪个事件组？</td>
</tr>
<tr>
<td style="text-align:center">uxBitsToWaitFor</td>
<td style="text-align:center">等待哪些位？哪些位要被测试？</td>
</tr>
<tr>
<td style="text-align:center">xWaitForAllBits</td>
<td style="text-align:center">怎么测试？是&quot;AND&quot;还是&quot;OR&quot;？ pdTRUE: 等待的位，全部为1; pdFALSE: 等待的位，某一个为1即可</td>
</tr>
<tr>
<td style="text-align:center">xClearOnExit</td>
<td style="text-align:center">函数提出前是否要清除事件？ pdTRUE: 清除uxBitsToWaitFor指定的位 pdFALSE: 不清除</td>
</tr>
<tr>
<td style="text-align:center">xTicksToWait</td>
<td style="text-align:center">如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用<code>pdMS_TO_TICKS()</code>把ms转换为Tick Count</td>
</tr>
<tr>
<td style="text-align:center">返回值</td>
<td style="text-align:center">返回的是事件值， 如果期待的事件发生了，返回的是&quot;非阻塞条件成立&quot;时的事件值； 如果是超时退出，返回的是超时时刻的事件值。</td>
</tr>
</tbody>
</table>
<h3 id="同步点"><a class="markdownIt-Anchor" href="#同步点"></a> 同步点</h3>
<p>使用<code>xEventGroupSync()</code>函数可以同步多个任务：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EventBits_t <span class="title function_">xEventGroupSync</span><span class="params">(    EventGroupHandle_t xEventGroup,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> EventBits_t uxBitsToSet,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> EventBits_t uxBitsToWaitFor,</span></span><br><span class="line"><span class="params">                                TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">xEventGroup</td>
<td style="text-align:center">哪个事件组</td>
</tr>
<tr>
<td style="text-align:center">uxBitsToSet</td>
<td style="text-align:center">要设置哪些事件，已经完成了哪些事件？ 比如0x05(二进制为0101)会导致事件组的bit0,bit2被设置为1</td>
</tr>
<tr>
<td style="text-align:center">uxBitsToWaitFor</td>
<td style="text-align:center">等待那个位、哪些位？ 比如0x15(二级制10101)，表示要等待bit0,bit2,bit4都为1</td>
</tr>
<tr>
<td style="text-align:center">xTicksToWait</td>
<td style="text-align:center">如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用<code>pdMS_TO_TICKS()</code>把ms转换为Tick Count</td>
</tr>
<tr>
<td style="text-align:center">返回值</td>
<td style="text-align:center">返回的是事件值， 如果期待的事件发生了，返回的是&quot;非阻塞条件成立&quot;时的事件值； 如果是超时退出，返回的是超时时刻的事件值。</td>
</tr>
</tbody>
</table>
<h1 id="任务通知"><a class="markdownIt-Anchor" href="#任务通知"></a> 任务通知</h1>
<h2 id="特性-4"><a class="markdownIt-Anchor" href="#特性-4"></a> 特性</h2>
<h3 id="优势"><a class="markdownIt-Anchor" href="#优势"></a> 优势</h3>
<ul>
<li><strong>效率更高</strong>：使用任务通知来发送事件、数据给某个任务时，效率更高。比队列、信号量、事件组都有大的优势。</li>
<li><strong>更节省内存</strong>：使用其他方法时都要先创建对应的结构体，使用任务通知时无需额外创建结构体。</li>
</ul>
<h3 id="限制"><a class="markdownIt-Anchor" href="#限制"></a> 限制</h3>
<ul>
<li><strong>不能发送数据给ISR</strong>： ISR并没有任务结构体，所以无法使用任务通知的功能给ISR发送数据。但是ISR可以使用任务通知的功能，发数据给任务。</li>
<li><strong>数据只能给该任务独享</strong>： 使用队列、信号量、事件组时，数据保存在这些结构体中，其他任务、ISR都可以访问这些数据。使用任务通知时，数据存放入目标任务中，只有它可以访问这些数据。 在日常工作中，这个限制影响不大。因为很多场合是从多个数据源把数据发给某个任务，而不是把一个数据源的数据发给多个任务。</li>
<li><strong>无法缓冲数据</strong> ：使用队列时，假设队列深度为N，那么它可以保持N个数据。 使用任务通知时，任务结构体中只有一个任务通知值，只能保持一个数据。</li>
<li><strong>无法广播给多个任务</strong> ：使用事件组可以同时给多个任务发送事件。 使用任务通知，只能发个一个任务。</li>
<li><strong>如果发送受阻，发送方无法进入阻塞状态等待</strong>： 假设队列已经满了，使用<code>xQueueSendToBack()</code>给队列发送数据时，任务可以进入阻塞状态等待发送完成。 使用任务通知时，即使对方无法接收数据，发送方也无法阻塞等待，只能即刻返回错误。</li>
</ul>
<h3 id="通知状态和通知值"><a class="markdownIt-Anchor" href="#通知状态和通知值"></a> 通知状态和通知值</h3>
<p>每个人物都有一个结构体：TCB，里面存在2个成员：</p>
<ul>
<li>一个是uint8_t类型，用来表示通知<strong>状态</strong></li>
<li>一个是uint32_t类型，用来表示通知<strong>值</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tskTaskControlBlock</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* configTASK_NOTIFICATION_ARRAY_ENTRIES = 1 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint32_t</span> ulNotifiedValue[configTASK_NOTIFICATION_ARRAY_ENTRIES ];</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">uint8_t</span> ucNotifyState[configTASK_NOTIFICATION_ARRAY_ENTRIES ];</span><br><span class="line">    ......</span><br><span class="line">&#125; tskTCB;</span><br></pre></td></tr></table></figure>
<p>通知状态有3种取值：</p>
<ul>
<li><strong>taskNOT_WAITING_NOTIFICATION</strong>：任务没有在等待通知</li>
<li><strong>taskWAITING_NOTIFICATION</strong>：任务在等待通知</li>
<li><strong>taskNOTIFICATION_RECEIVED</strong>：任务接收到了通知，也被称为pending(有数据了，待处理)</li>
</ul>
<h2 id="任务通知的使用"><a class="markdownIt-Anchor" href="#任务通知的使用"></a> 任务通知的使用</h2>
<p>使用任务通知，可以实现<strong>轻量级的队列(长度为1)、邮箱(覆盖的队列)、计数型信号量、二进制信号量、事件组</strong>。</p>
<h3 id="函数-5"><a class="markdownIt-Anchor" href="#函数-5"></a> 函数</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// xTaskToNotify和xTaskHandle为任务句柄(创建任务时得到)，给哪个任务发通知</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyGive</span><span class="params">( TaskHandle_t xTaskToNotify )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskNotifyGiveFromISR</span><span class="params">( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">ulTaskNotifyTake</span><span class="params">( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// xTaskNotify 函数功能更强大，可以使用不同参数实现各类功能，比如：</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 让接收任务的通知值加一：这时xTaskNotify()等同于xTaskNotifyGive()</span></span><br><span class="line"><span class="comment">// 设置接收任务的通知值的某一位、某些位，这就是一个轻量级的、更高效的事件组</span></span><br><span class="line"><span class="comment">// 把一个新值写入接收任务的通知值：上一次的通知值被读走后，写入才成功。这就是轻量级的、长度为1的队列</span></span><br><span class="line"><span class="comment">// 用一个新值覆盖接收任务的通知值：无论上一次的通知值是否被读走，覆盖都成功。类似xQueueOverwrite()函数，这就是轻量级的邮箱</span></span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotify</span><span class="params">( TaskHandle_t xTaskToNotify, <span class="type">uint32_t</span> ulValue, eNotifyAction eAction )</span>;</span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyFromISR</span><span class="params">( TaskHandle_t xTaskToNotify,</span></span><br><span class="line"><span class="params">                               <span class="type">uint32_t</span> ulValue, </span></span><br><span class="line"><span class="params">                               eNotifyAction eAction, </span></span><br><span class="line"><span class="params">                               BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用xTaskNotifyWait()函数！它比ulTaskNotifyTake()更复杂：</span></span><br><span class="line"><span class="comment">// 可以让任务等待(可以加上超时时间)，等到任务状态为&quot;pending&quot;(也就是有数据)</span></span><br><span class="line"><span class="comment">// 还可以在函数进入、退出时，清除通知值的指定位</span></span><br><span class="line"></span><br><span class="line">BaseType_t <span class="title function_">xTaskNotifyWait</span><span class="params">( <span class="type">uint32_t</span> ulBitsToClearOnEntry, </span></span><br><span class="line"><span class="params">                            <span class="type">uint32_t</span> ulBitsToClearOnExit, </span></span><br><span class="line"><span class="params">                            <span class="type">uint32_t</span> *pulNotificationValue, </span></span><br><span class="line"><span class="params">                            TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>
<p><strong>eNotifyAction参数说明</strong>：</p>
<table>
<thead>
<tr>
<th style="text-align:center">eNotifyAction取值</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">eNoAction</td>
<td style="text-align:center">仅仅是更新通知状态为&quot;pending&quot;，未使用ulValue。 这个选项相当于轻量级的、更高效的二进制信号量。</td>
</tr>
<tr>
<td style="text-align:center">eSetBits</td>
<td style="text-align:center">通知值 = 原来的通知值 | ulValue，按位或。 相当于轻量级的、更高效的事件组。</td>
</tr>
<tr>
<td style="text-align:center">eIncrement</td>
<td style="text-align:center">通知值 = 原来的通知值 + 1，未使用ulValue。 相当于轻量级的、更高效的二进制信号量、计数型信号量。 相当于<code>xTaskNotifyGive()</code>函数。</td>
</tr>
<tr>
<td style="text-align:center">eSetValueWithoutOverwrite</td>
<td style="text-align:center">不覆盖。 如果通知状态为&quot;pending&quot;(表示有数据未读)， 则此次调用xTaskNotify不做任何事，返回pdFAIL。 如果通知状态不是&quot;pending&quot;(表示没有新数据)， 则：通知值 = ulValue。</td>
</tr>
<tr>
<td style="text-align:center">eSetValueWithOverwrite</td>
<td style="text-align:center">覆盖。 无论如何，不管通知状态是否为&quot;pendng&quot;， 通知值 = ulValue。</td>
</tr>
</tbody>
</table>
<h1 id="软件定时器"><a class="markdownIt-Anchor" href="#软件定时器"></a> 软件定时器</h1>
<h2 id="特性-5"><a class="markdownIt-Anchor" href="#特性-5"></a> 特性</h2>
<p>跟闹钟类似，<strong>只响一次/每隔多少时间就自动操作</strong>。</p>
<p><strong>两种状态</strong></p>
<ul>
<li><strong>运行</strong>(Running、Active)：运行态的定时器，当指定时间到达之后，它的回调函数会被调用</li>
<li><strong>冬眠</strong>(Dormant)：冬眠态的定时器还可以通过句柄来访问它，但是它不再运行，它的回调函数不会被调用</li>
</ul>
<h2 id="软件定时器的上下文"><a class="markdownIt-Anchor" href="#软件定时器的上下文"></a> 软件定时器的上下文</h2>
<h3 id="守护任务"><a class="markdownIt-Anchor" href="#守护任务"></a> 守护任务</h3>
<p>FreeRTOS中有一个Tick中断，软件定时器<strong>基于Tick来运行</strong>，但<strong>不在Tick中断中执行定时器函数</strong>，而是在<strong>RTOS Damemon Task</strong>中执行，即<strong>守护任务</strong>。</p>
<p>守护任务的优先级：configTIMER_TASK_PRIORITY</p>
<p>定时器命令队列的长度：configTIMER_QUEUE_LENGTH</p>
<h3 id="回调函数"><a class="markdownIt-Anchor" href="#回调函数"></a> 回调函数</h3>
<p>如下是定时器的回调函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ATimerCallback</span><span class="params">( TimerHandle_t xTimer )</span>;</span><br></pre></td></tr></table></figure>
<p>定时器的回调函数是在守护任务中被调用的，<strong>守护任务不是专为某个定时器服务的</strong>，它还要处理其他定时器。</p>
<p>因此回调任务不能影响其他人：</p>
<ul>
<li><strong>回调函数要尽快实行</strong>，不能进入阻塞状态</li>
<li><strong>不要调用会导致阻塞的API函数</strong>，比如<code>vTaskDelay()</code></li>
<li>可以调用<code>xQueueReceive()</code>之类的函数，但是超时时间要设为0：即刻返回，不可阻塞</li>
</ul>
<h2 id="函数-6"><a class="markdownIt-Anchor" href="#函数-6"></a> 函数</h2>
<img src="https://s2.loli.net/2025/05/08/angVbmzSiAKhTML.png" style="zoom:50%;" />
<h3 id="创建-4"><a class="markdownIt-Anchor" href="#创建-4"></a> 创建</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 使用动态分配内存的方法创建定时器</span></span><br><span class="line"><span class="comment"> * pcTimerName:定时器名字, 用处不大, 尽在调试时用到</span></span><br><span class="line"><span class="comment"> * xTimerPeriodInTicks: 周期, 以Tick为单位</span></span><br><span class="line"><span class="comment"> * uxAutoReload: 类型, pdTRUE表示自动加载, pdFALSE表示一次性</span></span><br><span class="line"><span class="comment"> * pvTimerID: 回调函数可以使用此参数, 比如分辨是哪个定时器</span></span><br><span class="line"><span class="comment"> * pxCallbackFunction: 回调函数</span></span><br><span class="line"><span class="comment"> * 返回值: 成功则返回TimerHandle_t, 否则返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TimerHandle_t <span class="title function_">xTimerCreate</span><span class="params">( <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcTimerName, </span></span><br><span class="line"><span class="params">							<span class="type">const</span> TickType_t xTimerPeriodInTicks,</span></span><br><span class="line"><span class="params">							<span class="type">const</span> UBaseType_t uxAutoReload,</span></span><br><span class="line"><span class="params">							<span class="type">void</span> * <span class="type">const</span> pvTimerID,</span></span><br><span class="line"><span class="params">							TimerCallbackFunction_t pxCallbackFunction )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用静态分配内存的方法创建定时器</span></span><br><span class="line"><span class="comment"> * pcTimerName:定时器名字, 用处不大, 尽在调试时用到</span></span><br><span class="line"><span class="comment"> * xTimerPeriodInTicks: 周期, 以Tick为单位</span></span><br><span class="line"><span class="comment"> * uxAutoReload: 类型, pdTRUE表示自动加载, pdFALSE表示一次性</span></span><br><span class="line"><span class="comment"> * pvTimerID: 回调函数可以使用此参数, 比如分辨是哪个定时器</span></span><br><span class="line"><span class="comment"> * pxCallbackFunction: 回调函数</span></span><br><span class="line"><span class="comment"> * pxTimerBuffer: 传入一个StaticTimer_t结构体, 将在上面构造定时器</span></span><br><span class="line"><span class="comment"> * 返回值: 成功则返回TimerHandle_t, 否则返回NULL</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">TimerHandle_t <span class="title function_">xTimerCreateStatic</span><span class="params">(<span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> pcTimerName,</span></span><br><span class="line"><span class="params">                                 TickType_t xTimerPeriodInTicks,</span></span><br><span class="line"><span class="params">                                 UBaseType_t uxAutoReload,</span></span><br><span class="line"><span class="params">                                 <span class="type">void</span> * pvTimerID,</span></span><br><span class="line"><span class="params">                                 TimerCallbackFunction_t pxCallbackFunction,</span></span><br><span class="line"><span class="params">                                 StaticTimer_t *pxTimerBuffer )</span>;</span><br></pre></td></tr></table></figure>
<p>回调函数的类型是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ATimerCallback</span><span class="params">( TimerHandle_t xTimer )</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(* TimerCallbackFunction_t)</span><span class="params">( TimerHandle_t xTimer )</span>;</span><br></pre></td></tr></table></figure>
<h3 id="删除-4"><a class="markdownIt-Anchor" href="#删除-4"></a> 删除</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 删除定时器</span></span><br><span class="line"><span class="comment"> * xTimer: 要删除哪个定时器</span></span><br><span class="line"><span class="comment"> * xTicksToWait: 超时时间</span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;删除命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerDelete</span><span class="params">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br></pre></td></tr></table></figure>
<h3 id="启动停止"><a class="markdownIt-Anchor" href="#启动停止"></a> 启动/停止</h3>
<p><strong>启动</strong>定时器就是设置它的状态为<strong>运行态</strong>(Running、Active)。</p>
<p><strong>停止</strong>定时器就是设置它的状态为<strong>冬眠</strong>(Dormant)，让它不能运行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 启动定时器</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * xTicksToWait: 超时时间</span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;启动命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerStart</span><span class="params">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 启动定时器(ISR版本)</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒,</span></span><br><span class="line"><span class="comment"> *                            如果守护任务的优先级比当前任务的高,</span></span><br><span class="line"><span class="comment"> *                            则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;,</span></span><br><span class="line"><span class="comment"> *                            表示需要进行任务调度</span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;启动命令&quot;无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerStartFromISR</span><span class="params">(   TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                                 BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 停止定时器</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * xTicksToWait: 超时时间</span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;停止命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerStop</span><span class="params">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 停止定时器(ISR版本)</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒,</span></span><br><span class="line"><span class="comment"> *                            如果守护任务的优先级比当前任务的高,</span></span><br><span class="line"><span class="comment"> *                            则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;,</span></span><br><span class="line"><span class="comment"> *                            表示需要进行任务调度</span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;停止命令&quot;无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerStopFromISR</span><span class="params">(    TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                                 BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure>
<p>创建定时器时，设置了它的周期(period)。<code>xTimerStart()</code>函数是用来启动定时器。假设调用<code>xTimerStart()</code>的时刻是tX，定时器的周期是n，那么在<code>tX+n</code>时刻定时器的回调函数被调用。</p>
<p>如果定时器已经被启动，但是它的函数尚未被执行，再次执行<code>xTimerStart()</code>函数相当于执行<code>xTimerReset()</code>，重新设定它的启动时间。</p>
<h2 id="复位-2"><a class="markdownIt-Anchor" href="#复位-2"></a> 复位</h2>
<p>从定时器的状态转换图可以知道，使用<code>xTimerReset()</code>函数可以让定时器的状态从冬眠态转换为运行态，相当于使用<code>xTimerStart()</code>函数。</p>
<p>如果定时器已经处于运行态，使用<code>xTimerReset()</code>函数就相当于重新确定超时时间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 复位定时器</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * xTicksToWait: 超时时间</span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;复位命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerReset</span><span class="params">( TimerHandle_t xTimer, TickType_t xTicksToWait )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 复位定时器(ISR版本)</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒,</span></span><br><span class="line"><span class="comment"> *                            如果守护任务的优先级比当前任务的高,</span></span><br><span class="line"><span class="comment"> *                            则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;,</span></span><br><span class="line"><span class="comment"> *                            表示需要进行任务调度</span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;停止命令&quot;无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerResetFromISR</span><span class="params">(   TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                                 BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure>
<h2 id="修改周期"><a class="markdownIt-Anchor" href="#修改周期"></a> 修改周期</h2>
<p>从定时器的状态转换图可以知道，使用<code>xTimerChangePeriod()</code>函数，处理能修改它的周期外，还可以让定时器的状态从冬眠态转换为运行态。</p>
<p><strong>修改定时器的周期时，会使用新的周期重新计算它的超时时间</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 修改定时器的周期</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * xNewPeriod: 新周期</span></span><br><span class="line"><span class="comment"> * xTicksToWait: 超时时间, 命令写入队列的超时时间 </span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;修改周期命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerChangePeriod</span><span class="params">(   TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                                 TickType_t xNewPeriod,</span></span><br><span class="line"><span class="params">                                 TickType_t xTicksToWait )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修改定时器的周期</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * xNewPeriod: 新周期</span></span><br><span class="line"><span class="comment"> * pxHigherPriorityTaskWoken: 向队列发出命令使得守护任务被唤醒,</span></span><br><span class="line"><span class="comment"> *                            如果守护任务的优先级比当前任务的高,</span></span><br><span class="line"><span class="comment"> *                            则&quot;*pxHigherPriorityTaskWoken = pdTRUE&quot;,</span></span><br><span class="line"><span class="comment"> *                            表示需要进行任务调度</span></span><br><span class="line"><span class="comment"> * 返回值: pdFAIL表示&quot;修改周期命令&quot;在xTicksToWait个Tick内无法写入队列</span></span><br><span class="line"><span class="comment"> *        pdPASS表示成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">BaseType_t <span class="title function_">xTimerChangePeriodFromISR</span><span class="params">( TimerHandle_t xTimer,</span></span><br><span class="line"><span class="params">                                      TickType_t xNewPeriod,</span></span><br><span class="line"><span class="params">                                      BaseType_t *pxHigherPriorityTaskWoken )</span>;</span><br></pre></td></tr></table></figure>
<h2 id="定时器id"><a class="markdownIt-Anchor" href="#定时器id"></a> 定时器ID</h2>
<ul>
<li>可以用来标记定时器，表示自己是什么定时器</li>
<li>可以用来保存参数，给回调函数使用</li>
</ul>
<p>它的初始值在创建定时器时由<code>xTimerCreate()</code>这类函数传入。</p>
<ul>
<li>更新ID：使用<code>vTimerSetTimerID()</code>函数</li>
<li>查询ID：查询<code>pvTimerGetTimerID()</code>函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 获得定时器的ID</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * 返回值: 定时器的ID	*/</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">pvTimerGetTimerID</span><span class="params">( TimerHandle_t xTimer )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置定时器的ID</span></span><br><span class="line"><span class="comment"> * xTimer: 哪个定时器</span></span><br><span class="line"><span class="comment"> * pvNewID: 新ID</span></span><br><span class="line"><span class="comment"> * 返回值: 无	 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTimerSetTimerID</span><span class="params">( TimerHandle_t xTimer, <span class="type">void</span> *pvNewID )</span>;</span><br></pre></td></tr></table></figure>
<h2 id="一般使用配置"><a class="markdownIt-Anchor" href="#一般使用配置"></a> 一般使用配置</h2>
<p>要使用定时器，需要做些准备工作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 1. 工程中 */</span></span><br><span class="line"><span class="comment">//	添加 timer.c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 2. 配置文件FreeRTOSConfig.h中 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TIMERS			 1   <span class="comment">/* 使能定时器 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTIMER_TASK_PRIORITY    31  <span class="comment">/* 守护任务的优先级, 尽可能高一些 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTIMER_QUEUE_LENGTH     5   <span class="comment">/* 命令队列长度 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTIMER_TASK_STACK_DEPTH 32  <span class="comment">/* 守护任务的栈大小 */</span></span></span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 3. 源码中 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;timers.h&quot;</span></span></span><br></pre></td></tr></table></figure>
<h1 id="中断管理"><a class="markdownIt-Anchor" href="#中断管理"></a> 中断管理</h1>
<h2 id="特性-6"><a class="markdownIt-Anchor" href="#特性-6"></a> 特性</h2>
<p>中断流程，<strong>ISR要尽量快</strong></p>
<ul>
<li><strong>保存现场</strong>：Task1被打断，需要先保存Task1的运行环境，比如各类寄存器的值</li>
<li><strong>分辨中断、调用处理函数</strong>(这个函数就被称为ISR，interrupt service routine)</li>
<li><strong>恢复现场</strong>：继续运行Task1，或者运行其他优先级更高的任务</li>
</ul>
<p>ISR的优先级高于任务：即使是优先级最低的中断，它的优先级也高于任务。任务只有在没有中断的情况下，才能执行。</p>
<p><strong>Q：为什么要引入两套API函数？</strong></p>
<ol>
<li>
<p>很多API函数会<strong>导致任务计入阻塞状态</strong>：</p>
</li>
<li>
<p>ISR调用API函数时，<strong>ISR不是&quot;任务&quot;，ISR不能进入阻塞状态</strong></p>
</li>
<li>
<p>所以，在任务中、在ISR中，这些函数的功能是有差别的</p>
</li>
</ol>
<h2 id="两套api函数列表"><a class="markdownIt-Anchor" href="#两套api函数列表"></a> 两套API函数列表</h2>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">在任务中</th>
<th style="text-align:center">在ISR中</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">队列(queue)</td>
<td style="text-align:center">xQueueSendToBack</td>
<td style="text-align:center">xQueueSendToBackFromISR</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">xQueueSendToFront</td>
<td style="text-align:center">xQueueSendToFrontFromISR</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">xQueueReceive</td>
<td style="text-align:center">xQueueReceiveFromISR</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">xQueueOverwrite</td>
<td style="text-align:center">xQueueOverwriteFromISR</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">xQueuePeek</td>
<td style="text-align:center">xQueuePeekFromISR</td>
</tr>
<tr>
<td style="text-align:center">信号量(semaphore)</td>
<td style="text-align:center">xSemaphoreGive</td>
<td style="text-align:center">xSemaphoreGiveFromISR</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">xSemaphoreTake</td>
<td style="text-align:center">xSemaphoreTakeFromISR</td>
</tr>
<tr>
<td style="text-align:center">事件组(event group)</td>
<td style="text-align:center">xEventGroupSetBits</td>
<td style="text-align:center">xEventGroupSetBitsFromISR</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">xEventGroupGetBits</td>
<td style="text-align:center">xEventGroupGetBitsFromISR</td>
</tr>
<tr>
<td style="text-align:center">任务通知(task notification)</td>
<td style="text-align:center">xTaskNotifyGive</td>
<td style="text-align:center">vTaskNotifyGiveFromISR</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">xTaskNotify</td>
<td style="text-align:center">xTaskNotifyFromISR</td>
</tr>
<tr>
<td style="text-align:center">软件定时器(software timer)</td>
<td style="text-align:center">xTimerStart</td>
<td style="text-align:center">xTimerStartFromISR</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">xTimerStop</td>
<td style="text-align:center">xTimerStopFromISR</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">xTimerReset</td>
<td style="text-align:center">xTimerResetFromISR</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">xTimerChangePeriod</td>
<td style="text-align:center">xTimerChangePeriodFromISR</td>
</tr>
</tbody>
</table>
<h2 id="怎么切换任务"><a class="markdownIt-Anchor" href="#怎么切换任务"></a> 怎么切换任务</h2>
<p>FreeRTOS的ISR函数中，使用两个宏进行任务切换：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">portEND_SWITCHING_ISR( xHigherPriorityTaskWoken ); 	<span class="comment">//汇编实现</span></span><br><span class="line">或</span><br><span class="line">portYIELD_FROM_ISR( xHigherPriorityTaskWoken );		<span class="comment">//C语言实现</span></span><br></pre></td></tr></table></figure>
<h2 id="中断与任务间的通信"><a class="markdownIt-Anchor" href="#中断与任务间的通信"></a> 中断与任务间的通信</h2>
<p><strong>队列、信号量、互斥量、事件组、任务通知</strong>等等方法，都可使用。</p>
<p>要注意的是，在ISR中使用的函数要有&quot;FromISR&quot;后缀。</p>
<h1 id="资源管理"><a class="markdownIt-Anchor" href="#资源管理"></a> 资源管理</h1>
<p>要独占式地访问临界资源，有3种方法：</p>
<ul>
<li>
<p>公平竞争：比如使用<strong>互斥量</strong>等</p>
</li>
<li>
<p>谁要跟我抢，我就灭掉谁：</p>
<ul>
<li>
<p>中断要跟我抢？我<strong>屏蔽中断</strong></p>
</li>
<li>
<p>其他任务要跟我抢？我<strong>禁止调度器</strong>，不运行任务切换</p>
</li>
</ul>
</li>
</ul>
<h2 id="屏蔽中断"><a class="markdownIt-Anchor" href="#屏蔽中断"></a> 屏蔽中断</h2>
<ul>
<li>任务中使用：<code>taskENTER_CRITICA()/taskEXIT_CRITICAL()</code></li>
<li>ISR中使用：<code>taskENTER_CRITICAL_FROM_ISR()/taskEXIT_CRITICAL_FROM_ISR()</code></li>
</ul>
<h3 id="任务中屏蔽中断"><a class="markdownIt-Anchor" href="#任务中屏蔽中断"></a> 任务中屏蔽中断</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 在任务中，当前时刻中断是使能的</span></span><br><span class="line"><span class="comment"> * 执行这句代码后，屏蔽中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">taskENTER_CRITICAL();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问临界资源 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 重新使能中断 */</span></span><br><span class="line">taskEXIT_CRITICAL();</span><br></pre></td></tr></table></figure>
<p>在<code>taskENTER_CRITICA()</code>和<code>taskEXIT_CRITICAL()</code>之间：</p>
<ul>
<li>
<p>低优先级的中断被屏蔽了：优先级低于等于<code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code></p>
</li>
<li>
<p>高优先级的中断可以产生：优先级高于<code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code></p>
<ul>
<li>但是，这些中断ISR里，不允许使用FreeRTOS的API函数</li>
</ul>
</li>
<li>
<p>任务调度依赖于中断、依赖于API函数，所以：这两段代码之间，不会有任务调度产生</p>
</li>
</ul>
<h3 id="在isr中屏蔽中断"><a class="markdownIt-Anchor" href="#在isr中屏蔽中断"></a> 在ISR中屏蔽中断</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vAnInterruptServiceRoutine</span><span class="params">( <span class="type">void</span> )</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 用来记录当前中断是否使能 */</span></span><br><span class="line">    UBaseType_t uxSavedInterruptStatus;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 在ISR中，当前时刻中断可能是使能的，也可能是禁止的</span></span><br><span class="line"><span class="comment">     * 所以要记录当前状态, 后面要恢复为原先的状态</span></span><br><span class="line"><span class="comment">     * 执行这句代码后，屏蔽中断	*/</span></span><br><span class="line">    uxSavedInterruptStatus = taskENTER_CRITICAL_FROM_ISR();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 访问临界资源 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 恢复中断状态 */</span></span><br><span class="line">    taskEXIT_CRITICAL_FROM_ISR( uxSavedInterruptStatus );</span><br><span class="line">    <span class="comment">/* 现在，当前ISR可以被更高优先级的中断打断了 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>taskENTER_CRITICA_FROM_ISR()</code>和<code>taskEXIT_CRITICAL_FROM_ISR()</code>之间：</p>
<ul>
<li>
<p>低优先级的中断被屏蔽了：优先级低于、等于<code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code></p>
</li>
<li>
<p>高优先级的中断可以产生：优先级高于<code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code></p>
<ul>
<li>但是，这些中断ISR里，不允许使用FreeRTOS的API函数</li>
</ul>
</li>
<li>
<p>任务调度依赖于中断、依赖于API函数，所以：这两段代码之间，不会有任务调度产生</p>
</li>
</ul>
<h2 id="暂停调度器"><a class="markdownIt-Anchor" href="#暂停调度器"></a> 暂停调度器</h2>
<p>如果<strong>有别的任务来跟你竞争临界资源</strong>，可以<strong>把中断关掉</strong>：这当然可以禁止别的任务运行，但是这代价太大了。它会影响到中断的处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 暂停调度器 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">vTaskSuspendAll</span><span class="params">( <span class="type">void</span> )</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 恢复调度器</span></span><br><span class="line"><span class="comment"> * 返回值: pdTRUE表示在暂定期间有更高优先级的任务就绪了</span></span><br><span class="line"><span class="comment"> *        可以不理会这个返回值	*/</span></span><br><span class="line">BaseType_t <span class="title function_">xTaskResumeAll</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure>
<p>示例操作，下面可以<strong>递归使用</strong>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vTaskSuspendScheduler();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 访问临界资源 */</span></span><br><span class="line"></span><br><span class="line">xTaskResumeScheduler();</span><br></pre></td></tr></table></figure>
<h1 id="调试方法"><a class="markdownIt-Anchor" href="#调试方法"></a> 调试方法</h1>
<h2 id="调试"><a class="markdownIt-Anchor" href="#调试"></a> 调试</h2>
<ul>
<li>打印</li>
<li>断言：<code>configASSERT</code></li>
<li>Trace</li>
<li>Hook函数(回调函数)</li>
</ul>
<h3 id="打印"><a class="markdownIt-Anchor" href="#打印"></a> 打印</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">fputc</span><span class="params">( <span class="type">int</span> ch, FILE *f )</span>;</span><br></pre></td></tr></table></figure>
<h3 id="断言"><a class="markdownIt-Anchor" href="#断言"></a> 断言</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configASSERT(x)  <span class="keyword">if</span> (!x) while(1);</span></span><br></pre></td></tr></table></figure>
<h3 id="trace"><a class="markdownIt-Anchor" href="#trace"></a> Trace</h3>
<table>
<thead>
<tr>
<th>trace宏</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>traceTASK_INCREMENT_TICK(xTickCount)</td>
<td>当tick计数自增之前此宏函数被调用。参数xTickCount当前的Tick值，它还没有增加。</td>
</tr>
<tr>
<td>traceTASK_SWITCHED_OUT()</td>
<td>vTaskSwitchContext中，把当前任务切换出去之前调用此宏函数。</td>
</tr>
<tr>
<td>traceTASK_SWITCHED_IN()</td>
<td>vTaskSwitchContext中，新的任务已经被切换进来了，就调用此函数。</td>
</tr>
<tr>
<td>traceBLOCKING_ON_QUEUE_RECEIVE(pxQueue)</td>
<td>当正在执行的当前任务因为试图去读取一个空的队列、信号或者互斥量而进入阻塞状态时，此函数会被立即调用。参数pxQueue保存的是试图读取的目标队列、信号或者互斥量的句柄，传递给此宏函数。</td>
</tr>
<tr>
<td>traceBLOCKING_ON_QUEUE_SEND(pxQueue)</td>
<td>当正在执行的当前任务因为试图往一个已经写满的队列或者信号或者互斥量而进入了阻塞状态时，此函数会被立即调用。参数pxQueue保存的是试图写入的目标队列、信号或者互斥量的句柄，传递给此宏函数。</td>
</tr>
<tr>
<td>traceQUEUE_SEND(pxQueue)</td>
<td>当一个队列或者信号发送成功时，此宏函数会在内核函数xQueueSend(),xQueueSendToFront(),xQueueSendToBack(),以及所有的信号give函数中被调用，参数pxQueue是要发送的目标队列或信号的句柄，传递给此宏函数。</td>
</tr>
<tr>
<td>traceQUEUE_SEND_FAILED(pxQueue)</td>
<td>当一个队列或者信号发送失败时，此宏函数会在内核函数xQueueSend(),xQueueSendToFront(),xQueueSendToBack(),以及所有的信号give函数中被调用，参数pxQueue是要发送的目标队列或信号的句柄，传递给此宏函数。</td>
</tr>
<tr>
<td>traceQUEUE_RECEIVE(pxQueue)</td>
<td>当读取一个队列或者接收信号成功时，此宏函数会在内核函数xQueueReceive()以及所有的信号take函数中被调用，参数pxQueue是要接收的目标队列或信号的句柄，传递给此宏函数。</td>
</tr>
<tr>
<td>traceQUEUE_RECEIVE_FAILED(pxQueue)</td>
<td>当读取一个队列或者接收信号失败时，此宏函数会在内核函数xQueueReceive()以及所有的信号take函数中被调用，参数pxQueue是要接收的目标队列或信号的句柄，传递给此宏函数。</td>
</tr>
<tr>
<td>traceQUEUE_SEND_FROM_ISR(pxQueue)</td>
<td>当在中断中发送一个队列成功时，此函数会在xQueueSendFromISR()中被调用。参数pxQueue是要发送的目标队列的句柄。</td>
</tr>
<tr>
<td>traceQUEUE_SEND_FROM_ISR_FAILED(pxQueue)</td>
<td>当在中断中发送一个队列失败时，此函数会在xQueueSendFromISR()中被调用。参数pxQueue是要发送的目标队列的句柄。</td>
</tr>
<tr>
<td>traceQUEUE_RECEIVE_FROM_ISR(pxQueue)</td>
<td>当在中断中读取一个队列成功时，此函数会在xQueueReceiveFromISR()中被调用。参数pxQueue是要发送的目标队列的句柄。</td>
</tr>
<tr>
<td>traceQUEUE_RECEIVE_FROM_ISR_FAILED(pxQueue)</td>
<td>当在中断中读取一个队列失败时，此函数会在xQueueReceiveFromISR()中被调用。参数pxQueue是要发送的目标队列的句柄。</td>
</tr>
<tr>
<td>traceTASK_DELAY_UNTIL()</td>
<td>当一个任务因为调用了vTaskDelayUntil()进入了阻塞状态的前一刻此宏函数会在vTaskDelayUntil()中被立即调用。</td>
</tr>
<tr>
<td>traceTASK_DELAY()</td>
<td>当一个任务因为调用了vTaskDelay()进入了阻塞状态的前一刻此宏函数会在vTaskDelay中被立即调用。</td>
</tr>
</tbody>
</table>
<h3 id="malloc-hook函数"><a class="markdownIt-Anchor" href="#malloc-hook函数"></a> Malloc Hook函数</h3>
<p>编程时，一般的逻辑错误都容易解决。难以处理的是内存越界、栈溢出等。</p>
<p>内存越界经常发生在堆的使用过程总：堆，就是使用malloc得到的内存。</p>
<p>并没有很好的方法检测内存越界，但是可以提供一些回调函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vApplicationMallocFailedHook</span><span class="params">( <span class="type">void</span> )</span>;</span><br></pre></td></tr></table></figure>
<h3 id="栈溢出hook函数"><a class="markdownIt-Anchor" href="#栈溢出hook函数"></a> 栈溢出Hook函数</h3>
<p>在切换任务(vTaskSwitchContext)时调用taskCHECK_FOR_STACK_OVERFLOW来检测栈是否溢出，如果溢出会调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vApplicationStackOverflowHook</span><span class="params">( TaskHandle_t xTask, <span class="type">char</span> * pcTaskName )</span>;</span><br></pre></td></tr></table></figure>
<p>怎么判断栈溢出？</p>
<p>方法1：</p>
<ul>
<li>当前任务被切换出去之前，它的整个运行现场都被保存在栈里，这时<strong>很可能</strong>就是它对栈的使用到达了峰值。</li>
<li>这方法很高效，但是并不精确</li>
<li>比如：任务在运行过程中调用了函数A大量地使用了栈，调用完函数A后才被调度。</li>
</ul>
<p><img src="https://s2.loli.net/2025/05/08/3qzi8OMJFeAfYh2.png" alt="" /></p>
<p>方法2：</p>
<ul>
<li>创建任务时，它的栈被填入固定的值，比如：0xa5</li>
<li>检测栈里最后16字节的数据，如果不是0xa5的话表示栈即将、或者已经被用完了</li>
<li>没有方法1快速，但是也足够快</li>
<li>能捕获<strong>几乎所有</strong>的栈溢出</li>
<li>为什么是几乎所有？可能有些函数使用栈时，非常凑巧地把栈设置为0xa5：几乎不可能</li>
</ul>
<p><img src="https://s2.loli.net/2025/05/08/FaGJVURZPSEdCnq.png" alt="" /></p>
<h2 id="优化"><a class="markdownIt-Anchor" href="#优化"></a> 优化</h2>
<h3 id="栈使用情况"><a class="markdownIt-Anchor" href="#栈使用情况"></a> 栈使用情况</h3>
<p>在创建任务时分配了栈，可以填入固定的数值比如0xa5，以后可以使用以下函数查看&quot;栈的高水位&quot;，也就是还有多少空余的栈空间：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxTaskGetStackHighWaterMark</span><span class="params">( TaskHandle_t xTask )</span>;</span><br></pre></td></tr></table></figure>
<p><strong>原理</strong>：从栈底往栈顶逐个字节地判断，它们的值持续是0xa5就表示它是空闲的。</p>
<h3 id="使用运行时间统计"><a class="markdownIt-Anchor" href="#使用运行时间统计"></a> 使用运行时间统计</h3>
<h3 id="涉及的宏定义头"><a class="markdownIt-Anchor" href="#涉及的宏定义头"></a> 涉及的宏定义头</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> configGENERATE_RUN_TIME_STATS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TRACE_FACILITY    1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_STATS_FORMATTING_FUNCTIONS  1</span></span><br></pre></td></tr></table></figure>
<h3 id="函数说明"><a class="markdownIt-Anchor" href="#函数说明"></a> 函数说明</h3>
<ul>
<li>uxTaskGetSystemState：获得任务的统计信息</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UBaseType_t <span class="title function_">uxTaskGetSystemState</span><span class="params">( TaskStatus_t * <span class="type">const</span> pxTaskStatusArray,</span></span><br><span class="line"><span class="params">                                        <span class="type">const</span> UBaseType_t uxArraySize,</span></span><br><span class="line"><span class="params">                                        <span class="type">uint32_t</span> * <span class="type">const</span> pulTotalRunTime )</span>;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">pxTaskStatusArray</td>
<td style="text-align:center">指向一个TaskStatus_t结构体数组，用来保存任务的统计信息。 有多少个任务？可以用<code>uxTaskGetNumberOfTasks()</code>来获得。</td>
</tr>
<tr>
<td style="text-align:center">uxArraySize</td>
<td style="text-align:center">数组大小、数组项个数，必须大于或等于<code>uxTaskGetNumberOfTasks()</code></td>
</tr>
<tr>
<td style="text-align:center">pulTotalRunTime</td>
<td style="text-align:center">用来保存当前总的运行时间(更快的定时器)，可以传入NULL</td>
</tr>
<tr>
<td style="text-align:center">返回值</td>
<td style="text-align:center">传入的pxTaskStatusArray数组，被设置了几个数组项。 注意：如果传入的uxArraySize小于<code>uxTaskGetNumberOfTasks()</code>，返回值就是0</td>
</tr>
</tbody>
</table>
<ul>
<li>vTaskList ：获得任务的统计信息，形式为可读的字符串。注意，pcWriteBuffer必须足够大。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskList</span><span class="params">( <span class="type">signed</span> <span class="type">char</span> *pcWriteBuffer )</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2025/05/08/irBOM9YKgcWPveJ.png" alt="" /></p>
<ul>
<li>vTaskGetRunTimeStats：获得任务的运行信息，形式为可读的字符串。注意，pcWriteBuffer必须足够大。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vTaskGetRunTimeStats</span><span class="params">( <span class="type">signed</span> <span class="type">char</span> *pcWriteBuffer )</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2025/05/08/tTabdjAKB98SeWY.png" alt="" /></p>
<p><strong>至此，完结</strong>！</p>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<p><a href="https://rtos.100ask.net/zh/FreeRTOS/simulator/chapter1.html#_1-1-freertos%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84">第一章 FreeRTOS概述与体验 | 百问网</a></p>
<p><a href="https://rtos.100ask.net/zh/FreeRTOS/DShanMCU-F103/">百问网《FreeRTOS入门与工程实践-基于STM32F103》教程-基于DShanMCU-103(STM32F103) | 百问网</a></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>STM32</tag>
        <tag>Bootloader</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown基础用法</title>
    <url>/2023/04/12/Markdown%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="markdown基础用法"><a class="markdownIt-Anchor" href="#markdown基础用法"></a> Markdown基础用法</h1>
<h3 id="官网网址httpwwwtyporaio"><a class="markdownIt-Anchor" href="#官网网址httpwwwtyporaio"></a> 官网网址：<a href="http://www.typora.io/">http://www.typora.io/</a></h3>
<p>可以下载排字模板和编辑主题。</p>
<p><strong>使用Typora，通过Ctrl+/即可进入Markdown源代码编辑模式。</strong></p>
<h3 id="标题"><a class="markdownIt-Anchor" href="#标题"></a> 标题</h3>
<p>#+空格+标题名称-----------一级标题<br />
##+空格+标题名称---------二级标题<br />
###+空格+标题名称--------三级标题<br />
####+空格+标题名称------四级标题<br />
#####+空格+标题名称------五级标题<br />
######+空格+标题名称-----六级标题<br />
<em><strong>最大支持六级标题</strong></em></p>
<h3 id="字体"><a class="markdownIt-Anchor" href="#字体"></a> 字体</h3>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line"><span class="bullet">*</span> + 文字 + *         斜体</span><br><span class="line">** + 文字 + **       加粗</span><br><span class="line"><span class="strong">*** + 文字 + **</span>*     斜体加粗</span><br><span class="line">~~ + 文字 + ~~       删除线</span><br></pre></td></tr></table></figure>
<p>对于标准的markdown文本是不支持居中对齐的。不过markdown同时兼容HTML，可以通过HTML语法格式书写来让文本居中对齐。</p>
<h3 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h3>
<blockquote>
<p>‘&gt;’+加空格+文字</p>
</blockquote>
<h3 id="分割线"><a class="markdownIt-Anchor" href="#分割线"></a> 分割线</h3>
<p>1.三个*然后回车<br />
2.三个-（减号）回车</p>
<h3 id="插入图片"><a class="markdownIt-Anchor" href="#插入图片"></a> 插入图片</h3>
<p>①本地的图片：英文的！+[图片名称]+（路径）<br />
②网络图：英文的！+[图片名称]+（网络图片地址）<br />
比如：<br />
<img src="https://s2.loli.net/2025/05/07/YhvXnKTEQL4FM2j.png" alt="" /></p>
<h3 id="链接"><a class="markdownIt-Anchor" href="#链接"></a> 链接</h3>
<p>[点击跳转到+名称]（网站、文件等地址）<br />
比如：<a href="https://blog.csdn.net/weixin_47795024?spm=1001.2100.3001.5343">我的博客</a></p>
<h3 id="列表"><a class="markdownIt-Anchor" href="#列表"></a> 列表</h3>
<p>①有序列表；序号（1，①）+英文的句号（.）+输入得内容，然后回车自动补出下一个序号<br />
②无序列表；减号（-）+空格+输入内容        回车自动补出下一个</p>
<h3 id="表格"><a class="markdownIt-Anchor" href="#表格"></a> 表格</h3>
<p>右击创建表格</p>
<h3 id="代码"><a class="markdownIt-Anchor" href="#代码"></a> 代码</h3>
<p>Tab键上面的点（·）三个 + 代码类型（java c++ c#等）然后回车</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数学公式"><a class="markdownIt-Anchor" href="#数学公式"></a> 数学公式</h3>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></munderover><msup><mi>i</mi><mn>2</mn></msup><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><msup><mi>n</mi><mn>2</mn></msup><mo>+</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><mn>6</mn></mfrac></mrow><annotation encoding="application/x-tex">
\sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.9291em;vertical-align:-1.2777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.05em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.2777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1771em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4911em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">6</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>
<p><a href="https://math.meta.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">LaTeX公式格式</a></p>
<h1 id="markdown快捷键"><a class="markdownIt-Anchor" href="#markdown快捷键"></a> Markdown快捷键</h1>
<p>撤销：Ctrl/Command + Z<br />
重做：Ctrl/Command + Y<br />
加粗：Ctrl/Command + B<br />
斜体：Ctrl/Command + I<br />
标题：Ctrl/Command + Shift + H<br />
无序列表：Ctrl/Command + Shift + U<br />
有序列表：Ctrl/Command + Shift + O<br />
检查列表：Ctrl/Command + Shift + C<br />
插入代码：Ctrl/Command + Shift + K<br />
插入链接：Ctrl/Command + Shift + L<br />
插入图片：Ctrl/Command + Shift + G<br />
查找：Ctrl/Command + F<br />
mand + Shift + L<br />
插入图片：Ctrl/Command + Shift + G<br />
查找：Ctrl/Command + F<br />
替换：Ctrl/Command + G</p>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>Opencv基础学习笔记</title>
    <url>/2025/08/07/Opencv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="opencv基础学习笔记"><a class="markdownIt-Anchor" href="#opencv基础学习笔记"></a> Opencv基础学习笔记</h1>
<p>Opencv基础部分，以前学过，做个笔记用于复习；</p>
<p>当然我建议学C++版本，更齐全，Python版本的课程教学内容缺太多了；</p>
<p>这里只看到第35节的基础部分就结束了（因为之前只学到这）</p>
<p>[<a href="https://www.bilibili.com/video/BV1Q54y1z7kz?spm_id_from=333.788.videopod.episodes&amp;vd_source=2686d8279192347a7d56afcb53bb00d9">opencv_C++] 入门强推！！！【B站最全】_哔哩哔哩_bilibili</a></p>
<h2 id="图像基本操作"><a class="markdownIt-Anchor" href="#图像基本操作"></a> 图像基本操作</h2>
<p>BGR：Blue Green Red</p>
<p>HSV：Hue(色调) Satration(饱和度) Value(明度)</p>
<p>Shape：[500, 500, 3] — [h, w, RGB]</p>
<p><img src="https://s2.loli.net/2025/08/07/mkij8ZIasTPVrdB.png" alt="" /></p>
<h3 id="图像读取"><a class="markdownIt-Anchor" href="#图像读取"></a> 图像读取</h3>
<ul>
<li>cv2.IMREAD_COLOR：彩色图像</li>
<li>cv2.IMREAD_GRAYSCALE：灰度图像</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment"># 彩色图片</span></span><br><span class="line">img = cv2.imread(<span class="string">&quot;1.jpg&quot;</span>, cv2.IMREAD_COLOR)</span><br><span class="line"><span class="comment"># 灰度图片</span></span><br><span class="line"><span class="comment"># img = cv2.imread(&quot;1.jpg&quot;, cv2.IMREAD_GRAYSCALEa)</span></span><br><span class="line"><span class="comment"># 展示img的通道值</span></span><br><span class="line"><span class="comment"># print(img.shape)</span></span><br><span class="line">cv2.imshow(<span class="string">&quot;Image&quot;</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 按下任意键关闭所有窗口</span></span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h3 id="图像保存"><a class="markdownIt-Anchor" href="#图像保存"></a> 图像保存</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment"># 读取图片1</span></span><br><span class="line">img1 = cv.imread(<span class="string">&quot;1.jpg&quot;</span>)</span><br><span class="line"><span class="comment"># 展示图片1</span></span><br><span class="line">cv2.imshow(<span class="string">&quot;Image1&quot;</span>, img1)</span><br><span class="line"><span class="comment"># 图片1保存为图片2</span></span><br><span class="line">cv2.imwrite(<span class="string">&quot;2.jpg&quot;</span>, img)</span><br><span class="line"><span class="comment"># 读取图片2</span></span><br><span class="line">img2 = cv.imread(<span class="string">&quot;2.jpg&quot;</span>)</span><br><span class="line"><span class="comment"># 展示图片2</span></span><br><span class="line">cv2.imshow(<span class="string">&quot;Image2&quot;</span>, img2)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img1 = cv.imread(<span class="string">&quot;1.jpg&quot;</span>)</span><br><span class="line"><span class="built_in">type</span>(img1)</span><br><span class="line"><span class="comment"># numpy.ndarray</span></span><br><span class="line">img1.size</span><br><span class="line"><span class="comment"># 207000</span></span><br><span class="line">img1.dtype</span><br><span class="line"><span class="comment"># dtype(&#x27;uint8&#x27;)</span></span><br></pre></td></tr></table></figure>
<h3 id="视频读取"><a class="markdownIt-Anchor" href="#视频读取"></a> 视频读取</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment"># 打开本地摄像头</span></span><br><span class="line">vc = cv2.VideoCapture(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">if</span> vc.isOpened():</span><br><span class="line">    <span class="built_in">open</span>, frame = vc.read()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">open</span> = <span class="literal">False</span></span><br><span class="line"><span class="keyword">while</span> <span class="built_in">open</span>:</span><br><span class="line">    ret, frame = vc.read()</span><br><span class="line">    <span class="keyword">if</span> frame <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">if</span> ret == <span class="literal">True</span>:</span><br><span class="line">        <span class="comment"># BGR转灰度</span></span><br><span class="line">        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span><br><span class="line">        cv2.imshow(<span class="string">&quot;res&quot;</span>, gray)</span><br><span class="line">        <span class="comment"># 按下Q键退出</span></span><br><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">10</span>) &amp; <span class="number">0xFF</span> == <span class="built_in">ord</span>(<span class="string">&#x27;q&#x27;</span>):</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">vc.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h3 id="截取部分图像数据"><a class="markdownIt-Anchor" href="#截取部分图像数据"></a> 截取部分图像数据</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img1 = cv2.imread(<span class="string">&quot;1.jpg&quot;</span>)</span><br><span class="line">cv2.imshow(<span class="string">&quot;img1&quot;</span>, img1)</span><br><span class="line"><span class="comment"># 截取200x200</span></span><br><span class="line">img2 = img1[<span class="number">0</span>:<span class="number">200</span>, <span class="number">0</span>:<span class="number">200</span>]</span><br><span class="line">cv2.imshow(<span class="string">&quot;img2&quot;</span>, img2)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2025/08/07/rlneymuaKTJP76S.png" style="zoom:50%;" />
<h3 id="颜色通道提取"><a class="markdownIt-Anchor" href="#颜色通道提取"></a> 颜色通道提取</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># split，把多通道图像分为多个单通道图像</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img1 = cv2.imread(<span class="string">&quot;1.jpg&quot;</span>)</span><br><span class="line">cv2.imshow(<span class="string">&quot;img1&quot;</span>, img1)</span><br><span class="line"><span class="comment"># 颜色通道提取</span></span><br><span class="line">b, g, r = cv2.split(img1)</span><br><span class="line"><span class="built_in">print</span>(b, g, r)</span><br><span class="line"><span class="comment"># 通道合并</span></span><br><span class="line">img2 = cv2.merge((b, g, r))</span><br><span class="line">cv2.imshow(<span class="string">&quot;img2&quot;</span>, img2)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"><span class="comment"># 只保留B</span></span><br><span class="line"><span class="comment"># cur_img = img1.copy()</span></span><br><span class="line"><span class="comment"># cur_img[:, :, 1] = 0</span></span><br><span class="line"><span class="comment"># cur_img[:, :, 2] = 0</span></span><br><span class="line"><span class="comment"># cv2.imshow(&quot;B&quot;, cur_img)</span></span><br><span class="line"><span class="comment"># 只保留G</span></span><br><span class="line"><span class="comment"># cur_img = img1.copy()</span></span><br><span class="line"><span class="comment"># cur_img[:, :, 0] = 0</span></span><br><span class="line"><span class="comment"># cur_img[:, :, 2] = 0</span></span><br><span class="line"><span class="comment"># cv2.imshow(&quot;G&quot;, cur_img)</span></span><br><span class="line"><span class="comment"># 只保留R</span></span><br><span class="line"><span class="comment"># cur_img = img1.copy()</span></span><br><span class="line"><span class="comment"># cur_img[:, :, 0] = 0</span></span><br><span class="line"><span class="comment"># cur_img[:, :, 1] = 0</span></span><br><span class="line"><span class="comment"># cv2.imshow(&quot;R&quot;, cur_img)</span></span><br></pre></td></tr></table></figure>
<h3 id="调整对比度和亮度"><a class="markdownIt-Anchor" href="#调整对比度和亮度"></a> 调整对比度和亮度</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导入所需的库</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取输入图像</span></span><br><span class="line">image = cv2.imread(<span class="string">&#x27;1.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#定义alpha和beta</span></span><br><span class="line">alpha = <span class="number">1.5</span> <span class="comment">#对比度控制</span></span><br><span class="line">beta  = <span class="number">10</span>  <span class="comment">#亮度控制</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#调用convertScaleAbs函数</span></span><br><span class="line">adjusted = cv2.convertScaleAbs(image, alpha=alpha, beta=beta)</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示输出图像</span></span><br><span class="line">cv2.imshow(<span class="string">&#x27;adjusted&#x27;</span>, adjusted)</span><br><span class="line">cv2.waitKey()</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h3 id="绘制基本图形和文本"><a class="markdownIt-Anchor" href="#绘制基本图形和文本"></a> 绘制基本图形和文本</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## 直线</span></span><br><span class="line"><span class="comment"># image：需绘制直线的图像</span></span><br><span class="line"><span class="comment"># starting cordinates ：直线的起点</span></span><br><span class="line"><span class="comment"># ending cordinates ：直线的终点</span></span><br><span class="line"><span class="comment"># color ：线的颜色</span></span><br><span class="line"><span class="comment"># thickness ：线的粗细像素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cv2.line(image,starting cordinates,ending cordinates,color,thickness)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment"># 创建一个黑色面板</span></span><br><span class="line">image = np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>),np.uint8)</span><br><span class="line"><span class="comment"># 画直线</span></span><br><span class="line">cv2.line(image,(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">511</span>,<span class="number">511</span>),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">3</span>)</span><br><span class="line"><span class="comment">#色彩空间转换</span></span><br><span class="line">image = cv2.cvtColor(image,cv2.COLOR_BGR2RGB)</span><br><span class="line">cv2.imshow(<span class="string">&quot;绘制直线&quot;</span>,image)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 矩形</span></span><br><span class="line"><span class="comment"># image：需绘制矩形的图像</span></span><br><span class="line"><span class="comment"># starting vertex ：矩形的左上角顶点</span></span><br><span class="line"><span class="comment"># opposit vertex ：矩形的右下角顶点</span></span><br><span class="line"><span class="comment"># color ：线的颜色</span></span><br><span class="line"><span class="comment"># thickness ：线的粗细像素，-1表示填充</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cv2.rectangle(image,starting vertex,opposit vertex,color,thickness)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment"># 创建一个黑色面板</span></span><br><span class="line">image = np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>),np.uint8)    </span><br><span class="line"><span class="comment"># 画大矩形</span></span><br><span class="line">cv2.rectangle(image,(<span class="number">100</span>,<span class="number">100</span>),(<span class="number">400</span>,<span class="number">400</span>),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">2</span>)   </span><br><span class="line"><span class="comment"># 画小矩形</span></span><br><span class="line">cv2.rectangle(image,(<span class="number">200</span>,<span class="number">200</span>),(<span class="number">300</span>,<span class="number">300</span>),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),-<span class="number">1</span>)  </span><br><span class="line"><span class="comment"># 色彩空间转换</span></span><br><span class="line">image = cv2.cvtColor(image,cv2.COLOR_BGR2RGB)  </span><br><span class="line">cv2.imshow(<span class="string">&quot;绘制矩形&quot;</span>,image)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 圆</span></span><br><span class="line"><span class="comment"># image：需绘制圆的图像</span></span><br><span class="line"><span class="comment"># center：所绘制圆的圆心坐标</span></span><br><span class="line"><span class="comment"># radius：圆的半径</span></span><br><span class="line"><span class="comment"># color：圆的颜色</span></span><br><span class="line"><span class="comment"># fill：线的粗细像素，-1表示填充</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cv2.cirlce(image,center,radius,color,fill)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment">#创建一个黑色面板</span></span><br><span class="line">image = np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>),np.uint8)   </span><br><span class="line"><span class="comment">#画空心圆</span></span><br><span class="line">cv2.circle(image,(<span class="number">150</span>,<span class="number">150</span>),<span class="number">100</span>,(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">2</span>)  </span><br><span class="line"><span class="comment">#画实心圆</span></span><br><span class="line">cv2.circle(image,(<span class="number">350</span>,<span class="number">350</span>),<span class="number">100</span>,(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),-<span class="number">1</span>)   </span><br><span class="line"><span class="comment">#色彩空间转换</span></span><br><span class="line">image = cv2.cvtColor(image,cv2.COLOR_BGR2RGB)  </span><br><span class="line">cv2.imshow(<span class="string">&quot;绘制圆&quot;</span>,image)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 椭圆</span></span><br><span class="line"><span class="comment"># image:绘制椭圆的图像。</span></span><br><span class="line"><span class="comment"># centerCoordinates:它是椭圆的中心坐标。</span></span><br><span class="line"><span class="comment"># axesLength:它包含两个变量的元组，分别包含椭圆的长轴和短轴的长度</span></span><br><span class="line"><span class="comment"># angle:椭圆旋转角度，以度为单位。</span></span><br><span class="line"><span class="comment"># startAngle:椭圆弧的起始角度，以度为单位。</span></span><br><span class="line"><span class="comment"># endAngle:椭圆弧的终止角度，以度为单位。</span></span><br><span class="line"><span class="comment"># color:它是要绘制的形状边界线的颜色。</span></span><br><span class="line"><span class="comment"># thickness:是形状边界线的粗细像素。-1表示将用指定的颜色填充形状。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cv2.ellipse(image, centerCoordinates, axesLength, angle, startAngle, endAngle, color, thickness)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment"># 创建一个黑色面板</span></span><br><span class="line">image = np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>),np.uint8)    </span><br><span class="line"><span class="comment"># 画半个椭圆</span></span><br><span class="line">cv2.ellipse(image,(<span class="number">150</span>,<span class="number">150</span>),(<span class="number">100</span>,<span class="number">50</span>),<span class="number">0</span>,<span class="number">0</span>,<span class="number">180</span>,(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),-<span class="number">1</span>)  </span><br><span class="line"><span class="comment"># 画45度角的整个椭圆</span></span><br><span class="line">cv2.ellipse(image,(<span class="number">350</span>,<span class="number">350</span>),(<span class="number">100</span>,<span class="number">50</span>),<span class="number">45</span>,<span class="number">0</span>,<span class="number">360</span>,(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),-<span class="number">1</span>) </span><br><span class="line"><span class="comment"># 色彩空间转换</span></span><br><span class="line">image = cv2.cvtColor(image,cv2.COLOR_BGR2RGB)  </span><br><span class="line">cv2.imshow(<span class="string">&quot;绘制椭圆&quot;</span>,image)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 画多边形</span></span><br><span class="line"><span class="comment"># img：绘制椭圆的图像。</span></span><br><span class="line"><span class="comment"># pts：绘制的顶点</span></span><br><span class="line"><span class="comment"># color：线的颜色</span></span><br><span class="line"><span class="comment"># thickness： 厚度</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cv2.polylines(image,[pts],True,color,thickness)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="comment"># 创建一个黑色面板</span></span><br><span class="line">image = np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>),np.uint8)</span><br><span class="line"><span class="comment"># 构建多边形的顶点</span></span><br><span class="line">pts = np.array([[<span class="number">200</span>,<span class="number">100</span>],[<span class="number">200</span>,<span class="number">500</span>],[<span class="number">50</span>,<span class="number">300</span>],[<span class="number">500</span>,<span class="number">200</span>],[<span class="number">500</span>,<span class="number">400</span>]],np.int32)  </span><br><span class="line"><span class="comment"># 以折线画图</span></span><br><span class="line">cv2.polylines(image,[pts],<span class="literal">True</span>,(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">3</span>)   </span><br><span class="line"><span class="comment"># 色彩空间转换</span></span><br><span class="line">image = cv2.cvtColor(image,cv2.COLOR_BGR2RGB)  </span><br><span class="line">cv2.imshow(<span class="string">&quot;绘制多边形&quot;</span>,image)</span><br><span class="line">cv2.waitKey(<span class="number">10000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制英文文本</span></span><br><span class="line"><span class="comment"># img：表示在那个图片上放置文本内容</span></span><br><span class="line"><span class="comment"># text：要绘制的文本内容</span></span><br><span class="line"><span class="comment"># org：文本在图片中的左下角坐标</span></span><br><span class="line"><span class="comment"># fontFace：字体类型即字体，通过cv2.FONT_可查看字体类型</span></span><br><span class="line"><span class="comment"># fontScale：字体大小</span></span><br><span class="line"><span class="comment"># color：字体颜色</span></span><br><span class="line"><span class="comment"># thickness：字体粗细</span></span><br><span class="line"><span class="comment"># lineType：边界类型</span></span><br><span class="line"><span class="comment"># bottomLeftOrigin：默认为True，表示图片数据源在左下角；为False，表示图片数据源在左上角</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字体</span></span><br><span class="line"><span class="comment"># cv2.FONT_HERSHEY_SIMPLEX - 正常大小无衬线字体</span></span><br><span class="line"><span class="comment"># cv2.FONT_HERSHEY_PLAIN - 小号无衬线字体</span></span><br><span class="line"><span class="comment"># cv2.FONT_HERSHEY_DUPLEX - 正常大小无衬线字体比(更复杂)</span></span><br><span class="line"><span class="comment"># cv2.FONT_HERSHEY_COMPLEX - 正常大小有衬线字体</span></span><br><span class="line"><span class="comment"># cv2.FONT_HERSHEY_TRIPLEX - 正常大小有衬线字体(更复杂)</span></span><br><span class="line"><span class="comment"># cv2.FONT_HERSHEY_COMPLEX_SMALL</span></span><br><span class="line"><span class="comment"># cv2.FONT_HERSHEY_SCRIPT_SIMPLEX - 手写风格字体。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cv2.putText(img, text, org, fontFace, fontScale, color[, thickness[, lineType[, bottomLeftOrigin]]])</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="comment"># 创建纯黑的背景图用来画图形</span></span><br><span class="line">img = np.zeros((<span class="number">800</span>, <span class="number">800</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line"><span class="comment"># 绘制文本</span></span><br><span class="line">cv2.putText(img, <span class="string">&#x27;Hello OpenCV&#x27;</span>, (<span class="number">50</span>,<span class="number">400</span>), cv2.FONT_HERSHEY_COMPLEX, <span class="number">2</span>, [<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>])</span><br><span class="line">cv2.imshow(<span class="string">&#x27;draw&#x27;</span>, img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 绘制中文</span></span><br><span class="line"><span class="comment"># 安装pillow：pip install pillow</span></span><br><span class="line"><span class="comment"># 使用Pillow包绘制中文文本.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> ImageFont, ImageDraw, Image</span><br><span class="line"><span class="comment"># 纯白背景</span></span><br><span class="line">img = np.full((<span class="number">500</span>, <span class="number">500</span>, <span class="number">3</span>), fill_value=<span class="number">255</span>, dtype=np.uint8)</span><br><span class="line"><span class="comment"># 导入字体文件，要自己下字体</span></span><br><span class="line">font = ImageFont.truetype(<span class="string">&#x27;./msyh.ttc&#x27;</span>, <span class="number">35</span>)</span><br><span class="line"><span class="comment"># 创建一个pillow的图片</span></span><br><span class="line">img_pil = Image.fromarray(img)</span><br><span class="line"><span class="comment"># 绘制pillow图片</span></span><br><span class="line">draw = ImageDraw.Draw(img_pil)</span><br><span class="line"><span class="comment"># 利用draw去绘制中文</span></span><br><span class="line">draw.text((<span class="number">100</span>, <span class="number">250</span>), <span class="string">&#x27;快跑，别用Python，用C++!!!&#x27;</span>, font=font, fill=(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>))</span><br><span class="line"><span class="comment"># 重新变回ndarray</span></span><br><span class="line">img = np.array(img_pil)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;img&#x27;</span> ,img)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="边界填充"><a class="markdownIt-Anchor" href="#边界填充"></a> 边界填充</h3>
<p><strong>改变图片最外围的边框</strong></p>
<ul>
<li>BORDER_<strong>REPLICATE</strong>：复制法，<strong>复制最边缘像素</strong>。</li>
<li>BORDER_<strong>REFLECT</strong>：反射法，对图像中的像素进行<strong>镜像复制</strong>：<strong>fedcba|abcdefgh|hgfedcb</strong></li>
<li>BORDER_<strong>REFLECT_101</strong>：反射法，以最边缘像素为轴，<strong>对称</strong>，<strong>gfedcb|abcdefgh|gfedcba</strong></li>
<li>BORDER_<strong>WRAP</strong>：<strong>外包装法cdefgh|abcdefgh|abcdefg</strong></li>
<li>BORDER_<strong>CONSTANT</strong>：常量法，<strong>常数值填充</strong>。</li>
</ul>
<p><img src="https://s2.loli.net/2025/08/07/U4HaOiIdogCMEnk.png" alt="" /></p>
<h3 id="图像融合"><a class="markdownIt-Anchor" href="#图像融合"></a> 图像融合</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img_cat = cv2.imread(<span class="string">&#x27;1.jpg&#x27;</span>)</span><br><span class="line">img_dog = cv2.imread(<span class="string">&#x27;2.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置同样大小</span></span><br><span class="line">img_dog = cv2.resize(img_dog, (<span class="number">639</span>, <span class="number">640</span>))</span><br><span class="line"><span class="comment"># 设置权重, res = x1 * a + x2 * b + c </span></span><br><span class="line">res = cv2.addWeighted(img_cat, <span class="number">0.4</span>, img_dog, <span class="number">0.6</span>, <span class="number">0</span>)</span><br><span class="line">cv2.imshow(<span class="string">&quot;res&quot;</span>, res)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2025/08/07/e3w5QuVWdzCSR7F.png" style="zoom:25%;" />
<h2 id="图像阈值与平滑处理"><a class="markdownIt-Anchor" href="#图像阈值与平滑处理"></a> 图像阈值与平滑处理</h2>
<h3 id="图像阈值"><a class="markdownIt-Anchor" href="#图像阈值"></a> 图像阈值</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># src： 输入图，只能输入单通道图像，通常来说为灰度图</span></span><br><span class="line"><span class="comment"># dst： 输出图</span></span><br><span class="line"><span class="comment"># thresh： 阈值，0-255</span></span><br><span class="line"><span class="comment"># maxval： 像素最大可得值</span></span><br><span class="line"><span class="comment"># type：二值化操作的类型</span></span><br><span class="line">ret, dst = cv2.threshold(src, thresh, maxval, <span class="built_in">type</span>)</span><br></pre></td></tr></table></figure>
<p>type为如下操作</p>
<ul>
<li>
<p><strong>cv2.THRESH_BINARY</strong> 超过阈值部分取maxval，其他取0</p>
</li>
<li>
<p><strong>cv2.THRESH_BINARY_INV</strong> 超过阈值部分取0，其他取maxval</p>
</li>
<li>
<p><strong>cv2.THRESH_TRUNC</strong> 大于阈值部分设为阈值，其他不变</p>
</li>
<li>
<p><strong>cv2.THRESH_TOZERO</strong> 大于阈值部分不变，其他为0</p>
</li>
<li>
<p><strong>cv2.THRESH_TOZERO_INV</strong> 大于阈值部分为0，其他不变</p>
</li>
</ul>
<p><strong>常常配合createTrackbar使用</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># name：滑动条的名字，</span></span><br><span class="line"><span class="comment"># dst：滑动条被放置的窗口的名字，</span></span><br><span class="line"><span class="comment"># default：滑动条默认值，</span></span><br><span class="line"><span class="comment"># max_value：滑动条的最大值，</span></span><br><span class="line"><span class="comment"># fun：回调函数，每次滑动都会调用回调函数。</span></span><br><span class="line">cv2.createTrackbar(name, dst, default, max_value, fun)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 得到滑动条的数值</span></span><br><span class="line">cv2.getTrackbarPos()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置滑动条的默认值</span></span><br><span class="line">cv2.setTrackbarPos(name, dst, default)</span><br></pre></td></tr></table></figure>
<h3 id="图像滤波"><a class="markdownIt-Anchor" href="#图像滤波"></a> 图像滤波</h3>
<p><strong>滤波</strong>的意义是为了让图片更加平滑，<strong>减少噪声</strong>。</p>
<h4 id="中值滤波"><a class="markdownIt-Anchor" href="#中值滤波"></a> 中值滤波</h4>
<img src="https://s2.loli.net/2025/08/07/swbGcHMxkKUXdoI.png" style="zoom:50%;" />
<h4 id="双边滤波"><a class="markdownIt-Anchor" href="#双边滤波"></a> 双边滤波</h4>
<p>双边滤波计算某一个像素点的新值时，不仅考虑距离信息（距离越远，权重越小），还考虑色彩信息（色彩差别越大，权重越小)</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">dst = cv2.bilateralFilter(src, d, sigmaColor, sigmaSpace, borderType)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img1 = cv2.imread(<span class="string">&#x27;2.jpg&#x27;</span>)</span><br><span class="line">img1 = cv2.resize(img1, (<span class="number">200</span>, <span class="number">200</span>))</span><br><span class="line"><span class="comment"># 均值滤波</span></span><br><span class="line"><span class="comment"># 简单的平均卷积操作</span></span><br><span class="line">blur = cv2.blur(img1, (<span class="number">100</span>, <span class="number">100</span>))</span><br><span class="line"><span class="comment"># 方框滤波</span></span><br><span class="line"><span class="comment"># 和均值差不多，可以选择归一化</span></span><br><span class="line">box1 = cv2.boxFilter(img1, -<span class="number">1</span>, (<span class="number">100</span>, <span class="number">100</span>), normalize=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># box2 = cv2.boxFilter(img1, -1, (3,3), normalize=False)</span></span><br><span class="line"><span class="comment"># 高斯滤波</span></span><br><span class="line"><span class="comment"># 高斯模糊的卷积核里的数值满足高斯分布，即更重视中间的</span></span><br><span class="line">gaussian = cv2.GaussianBlur(img1, (<span class="number">9</span>, <span class="number">9</span>), <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 中值滤波</span></span><br><span class="line"><span class="comment"># 相当于中值替代</span></span><br><span class="line">med = cv2.medianBlur(img1, <span class="number">9</span>)</span><br><span class="line">res = np.hstack((img1, blur, box1, gaussian, med))</span><br><span class="line">cv2.imshow(<span class="string">&quot;img, blur, box, gaussian, med&quot;</span>, res)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2025/08/07/RKmlzSne7Q1EsrD.png" alt="" /></p>
<h2 id="图像形态学"><a class="markdownIt-Anchor" href="#图像形态学"></a> 图像形态学</h2>
<h3 id="腐蚀"><a class="markdownIt-Anchor" href="#腐蚀"></a> 腐蚀</h3>
<p><strong>去除小型噪声、分离粘连物体、细化边缘</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img2 = cv2.imread(<span class="string">&#x27;2.jpg&#x27;</span>)</span><br><span class="line">img2 = cv2.resize(img2, (<span class="number">200</span>, <span class="number">200</span>))</span><br><span class="line">kernel = np.ones((<span class="number">30</span>, <span class="number">30</span>), np.uint8)</span><br><span class="line"><span class="comment"># 越来越黑</span></span><br><span class="line"><span class="comment"># 在kernel（30，30）的区域获取最大值赋值到对应pixel</span></span><br><span class="line">erosion_1 = cv2.erode(img2, kernel, iterations=<span class="number">1</span>)</span><br><span class="line">erosion_2 = cv2.erode(img2, kernel, iterations=<span class="number">2</span>)</span><br><span class="line">erosion_3 = cv2.erode(img2, kernel, iterations=<span class="number">3</span>)</span><br><span class="line">res = np.hstack((img2, erosion_1, erosion_2, erosion_3))</span><br><span class="line">cv2.imshow(<span class="string">&#x27;res&#x27;</span>, res)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2025/08/07/pgO75fUdT34eHsC.png" alt="" /></p>
<h3 id="膨胀"><a class="markdownIt-Anchor" href="#膨胀"></a> 膨胀</h3>
<p><strong>连接断裂的物体部分、填充物体内部的小孔或空洞、扩大物体尺寸、去除孤立噪声点</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img2 = cv2.imread(<span class="string">&#x27;2.jpg&#x27;</span>)</span><br><span class="line">img2 = cv2.resize(img2, (<span class="number">200</span>, <span class="number">200</span>))</span><br><span class="line">kernel = np.ones((<span class="number">30</span>, <span class="number">30</span>), np.uint8)</span><br><span class="line"><span class="comment"># 越来越白</span></span><br><span class="line"><span class="comment"># 在kernel（30，30）的区域获取最小值赋值到对应pixel</span></span><br><span class="line">dilate_1 = cv2.dilate(img2, kernel, iterations=<span class="number">1</span>)</span><br><span class="line">dilate_2 = cv2.dilate(img2, kernel, iterations=<span class="number">2</span>)</span><br><span class="line">dilate_3 = cv2.dilate(img2, kernel, iterations=<span class="number">3</span>)</span><br><span class="line">res = np.hstack((img2, dilate_1, dilate_2, dilate_3))</span><br><span class="line">cv2.imshow(<span class="string">&#x27;res&#x27;</span>, res)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2025/08/07/qPGdz8hyXE251BV.png" alt="" /></p>
<h3 id="开运算与闭运算"><a class="markdownIt-Anchor" href="#开运算与闭运算"></a> 开运算与闭运算</h3>
<p><strong>开运算：消除细小噪声与孤立点、分离粘连物体、平滑物体外轮廓</strong></p>
<p>作用：医学图像中去除组织切片的小斑点、文本识别前清除文档扫描件的墨渍或断裂笔画</p>
<p><strong>闭运算：填充内部空洞与缝隙、连接临近物体、平滑内轮廓</strong></p>
<p>作用：工业检测中填补零件表面的微小缺陷、遥感图像中连接断裂的道路或河流</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img2 = cv2.imread(<span class="string">&#x27;2.jpg&#x27;</span>)</span><br><span class="line">img2 = cv2.resize(img2, (<span class="number">200</span>, <span class="number">200</span>))</span><br><span class="line"><span class="comment"># 原图</span></span><br><span class="line">cv2.imshow(<span class="string">&#x27;img2&#x27;</span>, img2)</span><br><span class="line"><span class="comment"># 开：先腐蚀，再膨胀</span></span><br><span class="line">kernel = np.ones((<span class="number">10</span>, <span class="number">10</span>), np.uint8)</span><br><span class="line">opening = cv2.morphologyEx(img2, cv2.MORPH_OPEN, kernel)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;Opening&#x27;</span>, opening)</span><br><span class="line"><span class="comment"># 闭：先膨胀，再腐蚀</span></span><br><span class="line">kernel = np.ones((<span class="number">10</span>, <span class="number">10</span>), np.uint8)</span><br><span class="line">closing = cv2.morphologyEx(img2, cv2.MORPH_CLOSE, kernel)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;Closing&#x27;</span>, closing)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2025/08/07/Q8LIBtSwNy9WxEJ.png" style="zoom:60%;" />
<h3 id="形态学梯度计算"><a class="markdownIt-Anchor" href="#形态学梯度计算"></a> 形态学梯度计算</h3>
<p>边缘检测、特征提取、图像增强与锐化、光照估计与校正</p>
<p><strong>目标分割</strong>：结合梯度信息与区域生长算法，实现语义分割</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img2 = cv2.imread(<span class="string">&#x27;2.jpg&#x27;</span>)</span><br><span class="line">img2 = cv2.resize(img2, (<span class="number">200</span>, <span class="number">200</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度 = 膨胀 - 腐蚀，用膨胀的图像减去腐蚀的图像</span></span><br><span class="line">kernel = np.ones((<span class="number">4</span>, <span class="number">4</span>), np.uint8)</span><br><span class="line">gradient = cv2.morphologyEx(img2, cv2.MORPH_GRADIENT, kernel)</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&#x27;gradient&#x27;</span>, gradient)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2025/08/07/g8hHCLPVjsceRaB.png" style="zoom:67%;" />
<h3 id="礼帽与黑帽"><a class="markdownIt-Anchor" href="#礼帽与黑帽"></a> 礼帽与黑帽</h3>
<p><strong>突出图像中的局部亮暗特征或校正光照不均匀</strong></p>
<ul>
<li><strong>礼帽 = 原始输入 - 开运算</strong>
<ul>
<li>突出原图像中<strong>更亮</strong>的局域</li>
</ul>
</li>
</ul>
<p>作用：提取比周围背景更亮的细小物体、消除不均匀光照的影响，增强微弱目标特征</p>
<p><strong>黑帽可以用于提取原图片里面的有特征的线/数字</strong></p>
<ul>
<li><strong>黑帽 = 闭运算 - 原始输入</strong>
<ul>
<li>突出原图像中<strong>更暗</strong>的局域</li>
</ul>
</li>
</ul>
<p>作用：提取比周围更暗的区域、通过闭运算填充亮背景中的暗水印，再减去原图实现去水印</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img2 = cv2.imread(<span class="string">&#x27;2.jpg&#x27;</span>)</span><br><span class="line">img2 = cv2.resize(img2, (<span class="number">200</span>, <span class="number">200</span>))</span><br><span class="line">kernel = np.ones((<span class="number">15</span>, <span class="number">15</span>),np.uint8)</span><br><span class="line"><span class="comment"># 礼帽</span></span><br><span class="line">tophat = cv2.morphologyEx(img2, cv2.MORPH_TOPHAT, kernel)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;Please&#x27;</span>, tophat)</span><br><span class="line"><span class="comment"># 黑帽</span></span><br><span class="line">blackhat = cv2.morphologyEx(img2, cv2.MORPH_BLACKHAT, kernel)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;Black&#x27;</span>, blackhat)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2025/08/07/9Wc5vUFCwGJ4dQB.png" style="zoom:67%;" />
<h3 id="提取图片中水平线和垂直线"><a class="markdownIt-Anchor" href="#提取图片中水平线和垂直线"></a> 提取图片中水平线和垂直线</h3>
<ul>
<li>
<p>读取图片，转灰度图像cv_BGR2GRAY</p>
</li>
<li>
<p>转二值图像adaptiveThreshold</p>
</li>
<li>
<p>获取形状和尺寸的结构元素getStructuringElement</p>
<ul>
<li>
<pre class="highlight"><code class="PYTHON"><span class="comment"># MODE</span>
<span class="comment"># 矩形：MORPH_RECT;</span>
<span class="comment"># 交叉形：MORPH_CROSS;</span>
<span class="comment"># 椭圆形：MORPH_ELLIPSE;</span>
<span class="comment"># SIZE -- 内核的尺寸，比如（11，1）</span>
<span class="comment"># POINT -- 锚点的位置，比如（-1，-1）</span>
kernel = cv2.getStructuringElement(MODE, SIZE, POINT)
&lt;!--code￼<span class="number">19</span>--&gt;

</code></pre>
</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img2 = cv2.imread(<span class="string">&#x27;2.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="comment"># sobel 求导x</span></span><br><span class="line">sobelx = cv2.Sobel(img2, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>, ksize=<span class="number">3</span>)</span><br><span class="line">sobelx = cv2.convertScaleAbs(sobelx)</span><br><span class="line"><span class="comment"># sobel 求导y</span></span><br><span class="line">sobely = cv2.Sobel(img2, cv2.CV_64F, <span class="number">0</span>, <span class="number">1</span>, ksize=<span class="number">3</span>)</span><br><span class="line">sobely = cv2.convertScaleAbs(sobely)</span><br><span class="line"><span class="comment"># sobel 求导x，y</span></span><br><span class="line">sobelxy=cv2.Sobel(img2, cv2.CV_64F, <span class="number">1</span>, <span class="number">1</span>, ksize=<span class="number">3</span>)</span><br><span class="line">sobelxy = cv2.convertScaleAbs(sobelxy)</span><br><span class="line">sob = np.hstack((sobelx, sobely, sobelxy))</span><br><span class="line">cv2.imshow(<span class="string">&#x27;sob&#x27;</span>, sob)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2025/08/07/GfdDjvmSCH2E4rW.png" style="zoom:40%;" />
<h3 id="scharr算子"><a class="markdownIt-Anchor" href="#scharr算子"></a> Scharr算子</h3>
<img src="https://s2.loli.net/2025/08/07/Xl9h3PidIDsKkgy.png" style="zoom:67%;" />
<h3 id="laplacian算子"><a class="markdownIt-Anchor" href="#laplacian算子"></a> laplacian算子</h3>
<p>单独使用效果差，<strong>需配合高斯滤波（LOG算子）以抑制噪声</strong></p>
<img src="https://s2.loli.net/2025/08/07/NTHbXvCk7OISlom.png" style="zoom: 67%;" />
<p>处理流程：</p>
<ul>
<li>高斯模糊-去噪声GaussianBlur()</li>
<li>转换为灰度图像cvtColor()</li>
<li>拉普拉斯-二阶导数计算Laplacian()</li>
<li>取绝对值，显示结果convertScaleAbs()</li>
</ul>
<h3 id="算子对比"><a class="markdownIt-Anchor" href="#算子对比"></a> 算子对比</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 几种算子对比</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img2 = cv2.imread(<span class="string">&#x27;2.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"><span class="comment"># sobel 求导x</span></span><br><span class="line">sobelx = cv2.Sobel(img2, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>, ksize=<span class="number">3</span>)</span><br><span class="line">sobelx = cv2.convertScaleAbs(sobelx)</span><br><span class="line"><span class="comment"># sobel 求导y</span></span><br><span class="line">sobely = cv2.Sobel(img2, cv2.CV_64F, <span class="number">0</span>, <span class="number">1</span>, ksize=<span class="number">3</span>)</span><br><span class="line">sobely = cv2.convertScaleAbs(sobely)</span><br><span class="line"><span class="comment"># sobel 根据权重设置x, y</span></span><br><span class="line">sobelxy = cv2.addWeighted(sobelx, <span class="number">0.5</span>, sobely, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># scharr 求导x</span></span><br><span class="line">scharrx = cv2.Scharr(img2, cv2.CV_64F, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">scharrx = cv2.convertScaleAbs(scharrx)</span><br><span class="line"><span class="comment"># scharr 求导y</span></span><br><span class="line">scharry = cv2.Scharr(img2, cv2.CV_64F, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">scharry = cv2.convertScaleAbs(scharry)</span><br><span class="line"><span class="comment"># scharr 根据权重设置x, y</span></span><br><span class="line">scharrxy = cv2.addWeighted(scharrx, <span class="number">0.5</span>, scharry, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉普拉斯</span></span><br><span class="line">laplacian = cv2.Laplacian(img2, cv2.CV_64F)</span><br><span class="line">laplacian = cv2.convertScaleAbs(laplacian)</span><br><span class="line"></span><br><span class="line">res = np.hstack((sobelxy, scharrxy, laplacian))</span><br><span class="line">cv2.imshow(<span class="string">&#x27;res&#x27;</span>, res)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>可以看出<strong>Scharr要比Sobel显示的边缘更多，而Laplacian显示的更少</strong></p>
<img src="https://s2.loli.net/2025/08/07/3cyeRWCjtFSgJqv.png" style="zoom: 50%;" />
<h2 id="边缘检测"><a class="markdownIt-Anchor" href="#边缘检测"></a> 边缘检测</h2>
<h3 id="canny边缘检测"><a class="markdownIt-Anchor" href="#canny边缘检测"></a> Canny边缘检测</h3>
<p>处理流程：</p>
<ul>
<li>
<p><strong>高斯模糊</strong>，用于平滑图像，滤除噪声</p>
</li>
<li>
<p><strong>灰度转换</strong></p>
</li>
<li>
<p><strong>计算</strong>图像中每个像素点的<strong>梯度强度和方向</strong></p>
</li>
<li>
<p><strong>非极大值</strong>（Non-Maximum Suppression）<strong>抑制</strong>，消除边缘检测带来的杂散响应</p>
</li>
<li>
<p>应用<strong>双阈值</strong>（Double-Threshold）检测来确定真实的和潜在的边缘。</p>
</li>
</ul>
<p>通过抑制孤立的弱边缘最终完成边缘检测。</p>
<ol>
<li><strong>高斯滤波器</strong></li>
</ol>
<img src="https://s2.loli.net/2025/08/07/vbWGPXjwdsI4QgV.png" style="zoom:60%;" />
<ol start="2">
<li><strong>计算梯度和方向</strong></li>
</ol>
<img src="https://s2.loli.net/2025/08/07/agxKpCfRTjw49tB.png" style="zoom:75%;" />
<ol start="3">
<li><strong>非极大值抑制</strong></li>
</ol>
<img src="https://s2.loli.net/2025/08/07/zFpHotQA3IwG7Eb.png" style="zoom: 67%;" />
<p><strong>线性插值法</strong>：<strong>distance(g1, g2)表示两点之间的距离</strong></p>
<p>​	设g1的梯度幅值M(g1), g2的梯度幅值M(g2)</p>
<p>​	则dtmp1可以得到：M(dtmp1) = w * M(g2) + (1 - w) * M(g1)</p>
<p>​	其中w = distance(dtmp1, g2) / distance(g1, g2)</p>
<ol start="4">
<li><strong>双阈值检测</strong></li>
</ol>
<img src="https://s2.loli.net/2025/08/07/wEfgW8tuRYrz5Fx.png" style="zoom:80%;" />
<p><strong>梯度 &gt; maxVal，则为maxVal；梯度 &lt; minVal，则为minVal</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"># image：输入原图（必须为单通道图）</span></span><br><span class="line"><span class="string"># threshold1、2用于检测图像中明显的边缘</span></span><br><span class="line"><span class="string"># apertureSize：Sobel算子的大小</span></span><br><span class="line"><span class="string"># 参数(布尔值)：</span></span><br><span class="line"><span class="string">true：使用更精确的L2范数进行计算（即两个方向的倒数的平方和再开放）</span></span><br><span class="line"><span class="string">false：使用L1范数（直接将两个方向导数的绝对值相加）。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">cv2.Canny(image, threshold1, threshold2, [, edges[, apertureSize[, L2gradient]]])   </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img2 = cv2.imread(<span class="string">&#x27;2.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE)</span><br><span class="line"></span><br><span class="line">v1 = cv2.Canny(img2, <span class="number">160</span>, <span class="number">200</span>)</span><br><span class="line">v2 = cv2.Canny(img2, <span class="number">0</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">res = np.hstack((v1, v2))</span><br><span class="line">cv2.imshow(<span class="string">&#x27;res&#x27;</span>, res)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2025/08/07/26BaAhmz4qFkjJC.png" style="zoom:33%;" />
<h3 id="霍夫圆"><a class="markdownIt-Anchor" href="#霍夫圆"></a> 霍夫圆</h3>
<p><strong>前提：边缘检测已经做完</strong></p>
<ol>
<li>把原图做一次<strong>Canny 边缘检测</strong>，得到<strong>边缘检测的二值图</strong></li>
<li>对原始图像执行一次 <strong>Sobel 算子</strong>，计算出<strong>所有像素的邻域梯度值</strong></li>
<li>初始化圆心空间 N(a, b)，令所有的 N(a, b)=0。若要求圆心在图像中，则a，b值的范围分别对应图像的宽高，N(a,b)表示一共有a * b个</li>
<li>遍历 Canny 边缘二值图中的所有非零像素点，沿着梯度方向 (切线的垂直方向，根据<strong>Sobel 算子计算出的垂直梯度及水平梯度得来)固定搜索半径范围画线</strong>，将线段经过的所有累加器中的点 (a,b) 的 N(a,b)+=1。</li>
</ol>
<img src="https://s2.loli.net/2025/08/07/YTWEaj3D6eBrm7X.png" style="zoom:67%;" />
<ol start="5">
<li>统计排序 N(a,b)，得到可能的圆心（<strong>N(a,b) 越大，越有可能是圆心</strong>）</li>
</ol>
<p><strong>大白话：给定一个半径R，对于所有的白色点，都i会进行半径为R的画圆；颜色越深，越令人信服。</strong></p>
<img src="https://s2.loli.net/2025/08/07/y2PrKDoGu6eMi5t.png" style="zoom:67%;" />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Circles：用来存储HoughCircles的结果，类型为list，list中对象格式为x,y,r</span></span><br><span class="line"><span class="comment"># image：输入图像，即源图像，8位单通道图像，如果使用彩色图像，需要先转换成灰度图像</span></span><br><span class="line"><span class="comment"># method：定义检测图像中圆的方法。目前唯一实现的方法是cv2.HOUGH_GRADIENT</span></span><br><span class="line"><span class="comment"># dp：图像像素分辨率与参数空间分辨率的比值（官方文档上写的是图像分辨率与累加器分辨率的比值，它把参数空间认为是一个累加器，毕竟里面存储的都是经过的像素点的数量），dp=1，则参数空间与图像像素空间（分辨率）一样大，dp=2，参数空间的分辨率只有像素空间的一半大；#通过设置dp可以减少计算量</span></span><br><span class="line"><span class="comment"># minDist：检测到的圆中心（x,y）坐标之间的最小距离。如果minDist太小，则会保留大部分圆心相近的圆。如果minDist太大，则会将圆心相近的圆进行合并（若两圆心距离 &lt; minDist，则认为是同一个圆）</span></span><br><span class="line"><span class="comment"># param1：canny 边缘检测的高阈值，低阈值被自动置为高阈值的一半，默认为 100</span></span><br><span class="line"><span class="comment"># param2：累加平面某点是否是圆心的判定阈值。大于该阈值才判断为圆。当值设置的很小是，检测到的圆越多。默认值为 100</span></span><br><span class="line"><span class="comment"># minRadius：半径的最小大小（以像素为单位）默认为 0</span></span><br><span class="line"><span class="comment"># maxRadius：半径的最大大小（以像素为单位）默认为 0</span></span><br><span class="line"></span><br><span class="line">circles=cv2.HoughCircles(image, cv2.HOUGH_GRADIENT, dp=<span class="number">1</span>, minDist=<span class="number">10</span>, param1=<span class="literal">None</span>, param2=<span class="literal">None</span>, minRadius=<span class="literal">None</span>, maxRadius=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/bjxqmy/p/12333022.html">opencv —— HoughCircles 霍夫圆变换原理及圆检测 - 狂奔的小学生 - 博客园</a></p>
<p><a href="https://blog.csdn.net/m0_74259636/article/details/132655935">opencv 十一 霍夫圆检测原理及高级使用案例（含优化步骤）-CSDN博客</a></p>
<h3 id="像素重映射"><a class="markdownIt-Anchor" href="#像素重映射"></a> 像素重映射</h3>
<p>重映射是从图像中的一个位置获取像素并将其放置在新图像中的另一位置的过程。</p>
<img src="https://s2.loli.net/2025/08/07/psiUVzTDf6vZW4w.png" style="zoom:40%;" />
<h2 id="图像金字塔"><a class="markdownIt-Anchor" href="#图像金字塔"></a> 图像金字塔</h2>
<p>图像金字塔是指一组图像且不同分辨率的子图集合，它是图像多尺度表达的一种，以多分辨率来解释图像的结构，主要用于图像的分割或压缩。</p>
<p>实际应用中需注意：</p>
<ul>
<li><strong>金字塔层数</strong>：通常4-6层，过多会导致信息冗余。</li>
<li><strong>结构元素</strong>：高斯核大小影响平滑效果（常用5×5）</li>
</ul>
<p><strong>图像增强：分层调整细节与对比度<br />
图像融合：无缝拼接不同图像<br />
目标检测：多尺度定位物体<br />
图像压缩：分层存储与渐进传输<br />
噪声抑制与光照校正</strong></p>
<ul>
<li><strong>向下采样方法（缩小）</strong></li>
<li><strong>向上采样方法（放大）</strong></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pyrUp()放大图像，空白的像素点补0</span></span><br><span class="line"><span class="comment"># pyrDown()缩小图像，将奇数行和列去掉</span></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img2 = cv2.imread(<span class="string">&#x27;2.jpg&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(img2.shape)</span><br><span class="line">up = cv2.pyrUp(img2)</span><br><span class="line"><span class="built_in">print</span>(up.shape)</span><br><span class="line">down = cv2.pyrDown(img2)</span><br><span class="line"><span class="built_in">print</span>(down.shape)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"><span class="comment"># (360, 360, 3)</span></span><br><span class="line"><span class="comment"># (720, 720, 3)</span></span><br><span class="line"><span class="comment"># (180, 180, 3)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>拉普拉斯金字塔：<strong>lap = img2 - down</strong></li>
</ul>
<h2 id="直方图与傅里叶变换"><a class="markdownIt-Anchor" href="#直方图与傅里叶变换"></a> 直方图与傅里叶变换</h2>
<h3 id="直方图"><a class="markdownIt-Anchor" href="#直方图"></a> 直方图</h3>
<img src="https://s2.loli.net/2025/08/07/IKbZEPGeYR5A9Us.png" style="zoom:80%;" />
<p><strong>它是一种提高图像对比度的方法，拉伸图像灰度值范围</strong></p>
<p>直方图的<strong>横轴</strong>表示<strong>亮度</strong>，从左到右表示亮度从低到高</p>
<p>直方图的<strong>纵轴</strong>表示<strong>像素数量</strong>，从下到上表示像素从少到多。</p>
<p>直方图在<strong>某个亮度区间的凸起越高</strong>，就表示<strong>在这个亮度区间内的像素越多</strong></p>
<p>若直方图的<strong>凸起主要集中在左侧</strong>，则说明这张照片的<strong>亮度整体偏低</strong></p>
<p>作用：</p>
<ul>
<li>
<p>图像分析与诊断</p>
<ul>
<li>亮度与对比度评估</li>
<li>曝光检测</li>
</ul>
</li>
<li>
<p>图像增强</p>
<ul>
<li>直方图均衡化</li>
</ul>
</li>
<li>
<p>图像分割与阈值处理</p>
<ul>
<li>阈值选择</li>
<li>掩膜区域分析</li>
</ul>
</li>
<li>
<p>颜色分析与处理</p>
<ul>
<li>通道分离统计</li>
<li>颜色校正</li>
</ul>
</li>
<li>
<p>图像匹配与检索</p>
<ul>
<li>相似度比较</li>
<li>特征提取</li>
</ul>
</li>
</ul>
<p>四种基本类型：</p>
<ul>
<li>RGB直方图</li>
<li>通道直方图</li>
<li>明度直方图</li>
<li>颜色直方图</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">## images: 原图像图像格式为 uint8 或 ﬂoat32。当传入函数时应 用中括号 [] 括来例如[img]</span></span><br><span class="line"><span class="comment">## channels: 同样用中括号括来它会告函数我们统幅图 像的直方图。如果入图像是灰度图它的值就是 [0]如果是彩色图像 的传入的参数可以是 [0][1][2] 它们分别对应着 BGR。</span></span><br><span class="line"><span class="comment">## mask: 掩模图像。统整幅图像的直方图就把它为 None。但是如 果你想统图像某一分的直方图的你就制作一个掩模图像并 使用它。</span></span><br><span class="line"><span class="comment">## histSize:BIN 的数目。也应用中括号括来</span></span><br><span class="line"><span class="comment">## ranges: 像素值范围常为 [0,255]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># cv2.calcHist(images,channels,mask,histSize,ranges)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">&#x27;TkAgg&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">img2 = cv2.imread(<span class="string">&#x27;2.jpg&#x27;</span>)</span><br><span class="line">gray = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)</span><br><span class="line">hist = cv2.calcHist([gray], [<span class="number">0</span>], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line"></span><br><span class="line">plt.hist(img2.ravel(), <span class="number">256</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line"><span class="comment"># 可以看出这张图片的灰度颜色大部分接近于150左右</span></span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2025/08/07/x8vBuU9FrTZqEzi.png" style="zoom: 33%;" />
<p><strong>mask功能</strong>：一张图片有时候不需要统计整张图片，而是统计最中间或者做边界的一部分图片，那么就可以在参数中加入mask，原理是<strong>选中的部分为1，非选中的部分为0</strong>。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建mask</span></span><br><span class="line">mask = np.zeros(img.shape[:<span class="number">2</span>], np.uint8)</span><br><span class="line">mask[<span class="number">100</span>:<span class="number">150</span>,<span class="number">100</span>:<span class="number">150</span>] = <span class="number">255</span></span><br><span class="line">plt.imshow(mask, <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line"></span><br><span class="line">img=cv2.imread(<span class="string">&#x27;1&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">mask_img=cv2.bitwise_and(img, img, mask=mask)<span class="comment">#图片之间与操作</span></span><br><span class="line">plt.imshow(mask_img)</span><br></pre></td></tr></table></figure>
<h3 id="直方图均衡化"><a class="markdownIt-Anchor" href="#直方图均衡化"></a> 直方图均衡化</h3>
<p>直方图均衡化会使<strong>图片突出的地方更加突出</strong>，可以增加图片的特征</p>
<p>计算原理：<strong>新灰度值 = 旧灰度值 * 累计概率</strong></p>
<p>累计概率 = 当前灰度值的概率 + 小于当前灰度值的概率</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># img必须是灰度图像</span></span><br><span class="line"><span class="comment"># equalizeHist(img)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">&#x27;TkAgg&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img2 = cv2.imread(<span class="string">&#x27;2.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">plt.hist(img2.ravel(), <span class="number">256</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;img2&quot;</span>, img2)</span><br><span class="line"></span><br><span class="line">equ = cv2.equalizeHist(img2)</span><br><span class="line">plt.hist(equ.ravel(), <span class="number">256</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">cv2.imshow(<span class="string">&quot;equ&quot;</span>, equ)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2025/08/07/saLK8TrhwxmgM3V.png" style="zoom:33%;" />
<img src="https://s2.loli.net/2025/08/07/KUq7p84DdfbTCBF.png" style="zoom:50%;" />
<img src="https://s2.loli.net/2025/08/07/Rn8AhbcCIUH5dXE.png" style="zoom:33%;" />
<img src="https://s2.loli.net/2025/08/07/9SK7i8LZQTr1epg.png" style="zoom:50%;" />
<p><strong>均衡化后的图片亮的地方更加亮，暗的地方更加暗</strong>，使图片的立体感更加强烈，但也有一定问题（自己搜吧）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img2 = cv2.imread(<span class="string">&#x27;2.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">equ = cv2.equalizeHist(img2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自适应直方图均衡化</span></span><br><span class="line"><span class="comment"># clipLimit颜色对比度的阈值， titleGridSize进行像素均衡化的网格大小，即在多少网格下进行直方图的均衡化操作</span></span><br><span class="line">clahe = cv2.createCLAHE(clipLimit=<span class="number">2.0</span>, tileGridSize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">res_clahe = clahe.apply(img2)</span><br><span class="line">res = np.hstack((img2, equ, res_clahe))</span><br><span class="line">cv2.imshow(<span class="string">&#x27;res&#x27;</span>, res)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2025/08/07/6iTM4rtawRnmDC1.png" style="zoom:40%;" />
<h3 id="直方图比较方法"><a class="markdownIt-Anchor" href="#直方图比较方法"></a> 直方图比较方法</h3>
<ol>
<li>首先把图像从RGB色彩空间转换为HSV色彩空间，cvtColor</li>
<li>计算图像的直方图，然后归一化到[0 ~ 1]之间，calcHist和normalize</li>
<li>使用下列四方法之一进行比较，compareHist</li>
</ol>
<ul>
<li>Correlation：相关性比较</li>
</ul>
<img src="https://s2.loli.net/2025/08/07/95RLiWjFy7Vz4Pf.png" style="zoom:67%;" />
<ul>
<li>Chi-Square：卡方比较</li>
</ul>
<img src="https://s2.loli.net/2025/08/07/SCJsAcjoVtQxgrP.png" style="zoom:60%;" />
<ul>
<li>Intersection：十字交叉性</li>
</ul>
<img src="https://s2.loli.net/2025/08/07/tJK4yOA2HUnlx8Z.png" style="zoom:67%;" />
<ul>
<li>Bhattacharyya distance：巴氏距离</li>
</ul>
<img src="https://s2.loli.net/2025/08/07/2wlgNvcJdxU46IV.png" style="zoom:80%;" />
<h3 id="模板匹配"><a class="markdownIt-Anchor" href="#模板匹配"></a> 模板匹配</h3>
<p>模板在原图像上从原点开始滑动，计算模板与（图像被模板覆盖的地方）的<strong>差别</strong>程度</p>
<p><s>假如原图形是AxB大小，而模板是axb大小，则输出结果的矩阵是(A-a+1)x(B-b+1)</s></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">&#x27;TkAgg&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img1 = cv2.imread(<span class="string">&#x27;1.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">template = cv2.imread(<span class="string">&#x27;2.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">h, w = template.shape[:<span class="number">2</span>]</span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img,<span class="string">&#x27;gray&#x27;</span>),plt.title(<span class="string">&quot;img&quot;</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(template,<span class="string">&#x27;gray&#x27;</span>),plt.title(<span class="string">&quot;template&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<ul>
<li>TM_SQDIFF：计算平方不同，计算出来的值越小，越相关</li>
<li>TM_CCORR：计算相关性，计算出来的值越大，越相关</li>
<li>TM_CCOEFF：计算相关系数，计算出来的值越大，越相关</li>
<li>TM_SQDIFF_NORMED：计算归一化平方不同，计算出来的值越接近0，越相关</li>
<li>TM_CCORR_NORMED：计算归一化相关性，计算出来的值越接近1，越相关</li>
<li>TM_CCOEFF_NORMED：计算归一化相关系数，计算出来的值越接近1，越相关</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">img_rgb=cv2.imread(<span class="string">&quot;mario.jpg&quot;</span>)</span><br><span class="line">img_gray=cv2.cvtColor(img_rgb,cv2.COLOR_BGR2GRAY)</span><br><span class="line">template=cv2.imread(<span class="string">&#x27;mario_coin.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">h,w=template.shape[:<span class="number">2</span>]</span><br><span class="line">res=cv2.matchTemplate(img_gray,template,cv2.TM_CCOEFF_NORMED)</span><br><span class="line">threshold=<span class="number">0.8</span></span><br><span class="line">loc=np.where(res&gt;=threshold)</span><br><span class="line"><span class="keyword">for</span> pt <span class="keyword">in</span> <span class="built_in">zip</span>(*loc[::-<span class="number">1</span>]):</span><br><span class="line">    bottom_right=(pt[<span class="number">0</span>]+w,pt[<span class="number">1</span>]+h)</span><br><span class="line">    cv2.rectangle(img_rgb,pt,bottom_right,(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span><br><span class="line">cv2.imshow(<span class="string">&quot;img_rgb&quot;</span>,img_rgb)</span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2025/08/07/kZo9NUgBMuFsvYP.png" style="zoom:80%;" />
<h3 id="图像轮廓"><a class="markdownIt-Anchor" href="#图像轮廓"></a> 图像轮廓</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mode：轮廓检索模式</span></span><br><span class="line">	<span class="comment"># RETR_EXTERNAL：只检索最外面的轮廓；</span></span><br><span class="line">	<span class="comment"># RETR_LIST：检索所有的轮廓，并将其保存到一条链表当中；</span></span><br><span class="line">	<span class="comment"># RETR_CCOMP：检索所有的轮廓，并将他们组织为两层：顶层是各部分的外部边界，第二层是空洞的边界;</span></span><br><span class="line">	<span class="comment"># RETR_TREE：检索所有的轮廓，并重构嵌套轮廓的整个层次;</span></span><br><span class="line"><span class="comment"># method：轮廓逼近方法</span></span><br><span class="line">	<span class="comment"># CHAIN_APPROX_NONE：以Freeman链码的方式输出轮廓，所有其他方法输出多边形（顶点的序列）。</span></span><br><span class="line">	<span class="comment"># CHAIN_APPROX_SIMPLE：压缩水平的、垂直的和斜的部分，也就是函数只保留他们的终点部分。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## cv2.findContours(img, mode, method)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制轮廓</span></span><br><span class="line"><span class="comment">## cv2.drawContours</span></span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line">img2 = cv2.imread(<span class="string">&#x27;2.jpg&#x27;</span>)</span><br><span class="line"><span class="comment"># 转灰度</span></span><br><span class="line">gray = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY)</span><br><span class="line"><span class="comment"># 取色阈</span></span><br><span class="line">ret, thresh = cv2.threshold(gray, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span><br><span class="line"><span class="comment"># 找边缘</span></span><br><span class="line">contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)</span><br><span class="line">draw_img = img2.copy()</span><br><span class="line"><span class="comment"># 绘制边缘，-1表示显示所有轮廓</span></span><br><span class="line">res = cv2.drawContours(draw_img, contours, -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">cv2.imshow(<span class="string">&#x27;res&#x27;</span>, res)</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2025/08/07/YvDVyEAZHolpG4j.png" style="zoom:50%;" />
<h3 id="轮廓特征"><a class="markdownIt-Anchor" href="#轮廓特征"></a> 轮廓特征</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 书接上回，这里可以用于计算符合面积或者周长的各种形状</span></span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"><span class="comment">#面积</span></span><br><span class="line">cv2.contourArea(cnt)</span><br><span class="line"><span class="comment">#周长，True表示闭合的</span></span><br><span class="line">cv2.arcLength(cnt,<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<h3 id="轮廓周围绘制矩形"><a class="markdownIt-Anchor" href="#轮廓周围绘制矩形"></a> 轮廓周围绘制矩形</h3>
<p>用最少的线来代替，在几个点之间的直线，如果能用更少的点来表示，就采用更少的点</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># approxPolyDP</span></span><br><span class="line">epsilon = <span class="number">0.15</span> * cv2.arcLength(cnt, <span class="literal">True</span>) </span><br><span class="line">approx = cv2.approxPolyDP(cnt,epsilon,<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">draw_img2 = img2.copy()</span><br><span class="line">res = cv2.drawContours(draw_img, [approx], -<span class="number">1</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">cv.imshow(<span class="string">&#x27;res&#x27;</span>, res)</span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2025/08/07/bjNpcAW1aeYi2v5.png" style="zoom:70%;" />
<h3 id="凸包convex-hull"><a class="markdownIt-Anchor" href="#凸包convex-hull"></a> 凸包（Convex Hull）</h3>
<img src="https://s2.loli.net/2025/08/07/QkAbonj4RDZ3c2V.png" style="zoom:65%;" />
<h3 id="图像矩"><a class="markdownIt-Anchor" href="#图像矩"></a> 图像矩</h3>
<img src="https://s2.loli.net/2025/08/07/rB5Sxu1vq6MnLEs.png" style="zoom:80%;" />
<p><a href="https://blog.csdn.net/FriendshipTang/article/details/126394301">OpenCV-Python快速入门（十一）：图像矩_python图像的矩-CSDN博客</a></p>
<h3 id="点多边形测试"><a class="markdownIt-Anchor" href="#点多边形测试"></a> 点多边形测试</h3>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">cv2.pointPolygonTest</span><br></pre></td></tr></table></figure>
<h3 id="傅里叶变换"><a class="markdownIt-Anchor" href="#傅里叶变换"></a> 傅里叶变换</h3>
<p><strong>高频</strong>：变化<strong>剧烈</strong>的灰度分量，例如边界<br />
<strong>低频</strong>：变化<strong>缓慢</strong>的灰度分量，例如一片大海</p>
<p>滤波<br />
<strong>低通滤波器</strong>：只保留低频，会使得<strong>图像模糊</strong><br />
<strong>高通滤波器</strong>：只保留高频，会使得<strong>图像细节增强</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line">matplotlib.use(<span class="string">&#x27;TkAgg&#x27;</span>)</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img2 = cv2.imread(<span class="string">&#x27;2.jpg&#x27;</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 先转换成np.float32 格式</span></span><br><span class="line">img_float32 = np.float32(img2)</span><br><span class="line"><span class="comment"># 傅里叶变换</span></span><br><span class="line">dft = cv2.dft(img_float32, flags=cv2.DFT_COMPLEX_OUTPUT)</span><br><span class="line"><span class="comment"># 转换到中心位置</span></span><br><span class="line">dft_shift = np.fft.fftshift(dft)</span><br><span class="line"><span class="comment"># 得到灰度图能表示的形式</span></span><br><span class="line">magnitude_spectrum = <span class="number">20</span> * np.log(cv2.magnitude(dft_shift[:, :, <span class="number">0</span>], dft_shift[:, :, <span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>), plt.imshow(img2, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Input Image&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>), plt.imshow(magnitude_spectrum, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Magnitude Spectrum&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">cv2.waitKey(<span class="number">0</span>)</span><br><span class="line">cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2025/08/07/5DryblzCuiZXG9f.png" style="zoom:67%;" />
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv2.imread(<span class="string">&#x27;1.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">img_float32 = np.float32(img)</span><br><span class="line"></span><br><span class="line">dft = cv2.dft(img_float32, flags = cv2.DFT_COMPLEX_OUTPUT)</span><br><span class="line">dft_shift = np.fft.fftshift(dft)</span><br><span class="line"></span><br><span class="line">rows, cols = img.shape</span><br><span class="line">crow, ccol = <span class="built_in">int</span>(rows/<span class="number">2</span>) , <span class="built_in">int</span>(cols/<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 低通滤波</span></span><br><span class="line">mask = np.zeros((rows, cols, <span class="number">2</span>), np.uint8)</span><br><span class="line">mask[crow-<span class="number">30</span>:crow+<span class="number">30</span>, ccol-<span class="number">30</span>:ccol+<span class="number">30</span>] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## # 高通滤波</span></span><br><span class="line"><span class="comment">## mask = np.ones((rows, cols, 2), np.uint8)</span></span><br><span class="line"><span class="comment">## mask[crow-30:crow+30, ccol-30:ccol+30] = 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># IDFT</span></span><br><span class="line">fshift = dft_shift*mask</span><br><span class="line">f_ishift = np.fft.ifftshift(fshift)</span><br><span class="line">img_back = cv2.idft(f_ishift)</span><br><span class="line">img_back = cv2.magnitude(img_back[:,:,<span class="number">0</span>],img_back[:,:,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img, cmap = <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Input Image&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(img_back, cmap = <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Result&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">plt.show()                </span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2025/08/07/lvgEniWw74a8pP6.png" style="zoom:67%;" />
<h2 id="项目"><a class="markdownIt-Anchor" href="#项目"></a> 项目</h2>
<p><u>本科参与的一个项目，其实不难。</u></p>
<p>描述：给定一个<strong>绿色圆形标靶</strong>，测出其与相机的<strong>角度和距离</strong>；再给电机反馈这些参数。</p>
<p><strong>相机标定法</strong>，借助matlab以及相机对着棋盘进行标定，获得如下参数。</p>
<p>**相机内参：**焦距（fx，fy）；主点坐标（cx，cy）；畸变系数（径向畸变k1，k2，k3和切向畸变p1，p2）</p>
<p><strong>相机内参</strong>：旋转矩阵（3x3）；平移向量（3x1）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">import</span> serial</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------- 1. 初始化相机和标定参数 --------------------</span></span><br><span class="line"><span class="comment"># 相机内参（假设已通过标定获得）</span></span><br><span class="line">camera_matrix = np.array([</span><br><span class="line">    [<span class="number">800</span>, <span class="number">0</span>, <span class="number">320</span>],    <span class="comment"># fx, fy为焦距（像素单位），cx, cy为主点坐标</span></span><br><span class="line">    [<span class="number">0</span>, <span class="number">800</span>, <span class="number">240</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">])</span><br><span class="line">dist_coeffs = np.array([<span class="number">0.12</span>, -<span class="number">0.05</span>, <span class="number">0.0005</span>, <span class="number">0.0005</span>, <span class="number">0.0</span>])  <span class="comment"># 畸变系数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 标靶实际半径（单位：米）</span></span><br><span class="line">TARGET_RADIUS = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化摄像头</span></span><br><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)  <span class="comment"># 0为默认摄像头</span></span><br><span class="line">cap.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_WIDTH, <span class="number">640</span>)</span><br><span class="line">cap.<span class="built_in">set</span>(cv2.CAP_PROP_FRAME_HEIGHT, <span class="number">480</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------- 2. 初始化串口（USART） --------------------</span></span><br><span class="line"><span class="comment"># 根据实际串口修改</span></span><br><span class="line">ser = serial.Serial(<span class="string">&#x27;COM3&#x27;</span>, <span class="number">115200</span>, timeout=<span class="number">1</span>)  <span class="comment"># 波特率需与电机控制器匹配</span></span><br><span class="line">time.sleep(<span class="number">2</span>)  <span class="comment"># 等待串口初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------- 3. 主循环：检测标靶并计算参数 --------------------</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    ret, frame = cap.read()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> ret:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 畸变校正</span></span><br><span class="line">    undistorted_frame = cv2.undistort(frame, camera_matrix, dist_coeffs)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># --- 检测绿色圆形标靶（最大圆）---</span></span><br><span class="line">    <span class="comment"># 转换为HSV颜色空间提取绿色区域</span></span><br><span class="line">    hsv = cv2.cvtColor(undistorted_frame, cv2.COLOR_BGR2HSV)</span><br><span class="line">    lower_green = np.array([<span class="number">35</span>, <span class="number">50</span>, <span class="number">50</span>])    <span class="comment"># HSV绿色范围下限</span></span><br><span class="line">    upper_green = np.array([<span class="number">85</span>, <span class="number">255</span>, <span class="number">255</span>])  <span class="comment"># HSV绿色范围上限</span></span><br><span class="line">    <span class="comment"># 颜色或亮度阈值分割，取绿色,过滤</span></span><br><span class="line">    mask = cv2.inRange(hsv, lower_green, upper_green)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 形态学处理（去噪）</span></span><br><span class="line">    <span class="comment"># 闭运算，先膨胀，再腐蚀 --- &gt;  填充目标内部的小孔或空洞、平滑目标边界、连接断裂的物体边缘</span></span><br><span class="line">    kernel = np.ones((<span class="number">5</span>, <span class="number">5</span>), np.uint8)</span><br><span class="line">    mask = cv2.morphologyEx(mask, cv2.MORPH_CLOSE, kernel)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 霍夫圆变换检测所有圆形</span></span><br><span class="line">    circles = cv2.HoughCircles(mask, cv2.HOUGH_GRADIENT, dp=<span class="number">1</span>, minDist=<span class="number">50</span>,</span><br><span class="line">                              param1=<span class="number">50</span>, param2=<span class="number">30</span>, minRadius=<span class="number">10</span>, maxRadius=<span class="number">200</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> circles <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="comment"># 筛选最大圆（假设标靶是最大的绿色圆形）</span></span><br><span class="line">        circles = np.uint16(np.around(circles))</span><br><span class="line">        largest_circle = <span class="built_in">max</span>(circles[<span class="number">0</span>, :], key=<span class="keyword">lambda</span> x: x[<span class="number">2</span>])  <span class="comment"># 按半径排序</span></span><br><span class="line">        x, y, r = largest_circle</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 绘制检测结果</span></span><br><span class="line">        cv2.circle(undistorted_frame, (x, y), r, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">        cv2.circle(undistorted_frame, (x, y), <span class="number">2</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 计算距离 ---</span></span><br><span class="line">        <span class="comment"># 相似三角形原理：distance = (fx * 实际半径) / 检测到的像素半径</span></span><br><span class="line">        distance = (camera_matrix[<span class="number">0</span>, <span class="number">0</span>] * TARGET_RADIUS) / r</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 计算角度（偏航角和俯仰角）---</span></span><br><span class="line">        <span class="comment"># 像素坐标转换为以光心为原点的坐标</span></span><br><span class="line">        u = x - camera_matrix[<span class="number">0</span>, <span class="number">2</span>]  <span class="comment"># 水平偏移（x方向）</span></span><br><span class="line">        v = camera_matrix[<span class="number">1</span>, <span class="number">2</span>] - y   <span class="comment"># 垂直偏移（y轴向下，取反）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算角度（弧度）</span></span><br><span class="line">        theta_x = math.atan2(u, camera_matrix[<span class="number">0</span>, <span class="number">0</span>])  <span class="comment"># 偏航角（水平）</span></span><br><span class="line">        theta_y = math.atan2(v, camera_matrix[<span class="number">1</span>, <span class="number">1</span>])  <span class="comment"># 俯仰角（垂直）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 转换为角度制</span></span><br><span class="line">        angle_x_deg = math.degrees(theta_x)</span><br><span class="line">        angle_y_deg = math.degrees(theta_y)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 显示结果 ---</span></span><br><span class="line">        cv2.putText(undistorted_frame, <span class="string">f&quot;Distance: <span class="subst">&#123;distance:<span class="number">.2</span>f&#125;</span>m&quot;</span>, (<span class="number">10</span>, <span class="number">30</span>),</span><br><span class="line">                    cv2.FONT_HERSHEY_SIMPLEX, <span class="number">0.7</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">        cv2.putText(undistorted_frame, <span class="string">f&quot;Angle X: <span class="subst">&#123;angle_x_deg:<span class="number">.2</span>f&#125;</span>deg&quot;</span>, (<span class="number">10</span>, <span class="number">60</span>),</span><br><span class="line">                    cv2.FONT_HERSHEY_SIMPLEX, <span class="number">0.7</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># --- 通过USART发送数据 ---</span></span><br><span class="line">        <span class="comment"># 格式：角度(deg),距离(m)\n（如&quot;15.30,2.45\n&quot;）</span></span><br><span class="line">        command = <span class="string">f&quot;<span class="subst">&#123;angle_x_deg:<span class="number">.2</span>f&#125;</span>,<span class="subst">&#123;distance:<span class="number">.2</span>f&#125;</span>\n&quot;</span>.encode()</span><br><span class="line">        ser.write(command)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Sent to motor: <span class="subst">&#123;command.decode().strip()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 显示实时画面</span></span><br><span class="line">    cv2.imshow(<span class="string">&quot;Target Detection&quot;</span>, undistorted_frame)</span><br><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) == <span class="number">27</span>:  <span class="comment"># ESC键退出</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -------------------- 4. 释放资源 --------------------</span></span><br><span class="line">cap.release()</span><br><span class="line">cv2.destroyAllWindows()</span><br><span class="line">ser.close()</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Opencv</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>Opencv</tag>
        <tag>计算机视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>使用新域名后不加载主题</title>
    <url>/2022/05/15/%E4%BD%BF%E7%94%A8%E6%96%B0%E5%9F%9F%E5%90%8D%E5%90%8E%E4%B8%8D%E5%8A%A0%E8%BD%BD%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<h3 id="心路历程"><a class="markdownIt-Anchor" href="#心路历程"></a> <strong>心路历程</strong></h3>
<p>看了一圈CSDN，基本上都是抄抄改改，只有几个还有点负责心，但依然没有解决我的问题，差点就放弃了，不过好在通过试错给试出来了。</p>
<h3 id="解决方法"><a class="markdownIt-Anchor" href="#解决方法"></a> 解决方法</h3>
<p>使用了新域名后，发现网页的CSS和JS都没用了，但本地静态可以正常运行。这个时候需要修改个人博客底下的_config.yml文件，先找到这个地方：</p>
<p><img src="https://s2.loli.net/2025/05/07/KCLeSkUBlQGursV.png" alt="" /></p>
<p>将url改为<strong><a href="http://githubname.github.io">githubname.github.io</a></strong>，<strong>不要出现下一层仓库名</strong>。</p>
<p><strong>说明</strong>：CSDN上别人的解决方法不适用，是因为我们这个没有单独给出root，切记切记。</p>
]]></content>
      <categories>
        <category>网页</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>STM32学习笔记</title>
    <url>/2024/06/12/STM32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>主要学习STM32C8T6的基本配置以及各部件操作。</p>
<p><strong>Q：哈希体系和冯洛伊曼体系区别</strong>：前者是指令集和数据存储在<strong>不同存储器</strong>，后者是将两者存储<strong>在同一个存储器</strong></p>
<p><strong>计算机五大组成部分</strong>：控制器、运算器、存储器、输入设备、输出设备</p>
<p><strong>32位</strong>处理器，一个指针<strong>4字节</strong>；<strong>64位</strong>处理器，一个指针<strong>8字节</strong></p>
<h2 id="stm32f103c8t6基本配置"><a class="markdownIt-Anchor" href="#stm32f103c8t6基本配置"></a> STM32F103C8T6基本配置</h2>
<p><strong>STM32是小端存储，低地址的数据放在低字节上</strong></p>
<p><strong>堆从低地址向上增长，栈从高地址向下增长</strong></p>
<h3 id="内容"><a class="markdownIt-Anchor" href="#内容"></a> 内容</h3>
<p><strong>STM32F103C8T6最小系统版组成</strong>：MCU、时钟电路、复位电路、外部接口电路、电源电路，启动电路。</p>
<ul>
<li>
<p>内核：<strong>Cortex-M3</strong>，<strong>32位</strong>处理器内核，最大寻址位<strong>2^32=4GB</strong>字节；</p>
</li>
<li>
<p><strong>Flash：64K字节；</strong></p>
</li>
<li>
<p><strong>SRAM：20K字节；</strong></p>
</li>
</ul>
<p>2个ADC、4个定时器、2个IIC、2个SPI、3个USART、1个CAN</p>
<h3 id="qcotex-m3寄存器组的用法"><a class="markdownIt-Anchor" href="#qcotex-m3寄存器组的用法"></a> Q：Cotex-M3寄存器组的用法</h3>
<p><strong>R0~R12为通用寄存器；R13是主堆栈指针（MSP）和进程堆栈（PSP）；R14是链接寄存器（LR），R15是程序计数器（PC）</strong></p>
<ul>
<li><strong>R0—R3</strong>用于<strong>传参和表达式计算</strong>；</li>
<li><strong>R4—R11</strong>用于<strong>保存局部变量</strong>；</li>
<li>R12是临时寄存器；</li>
<li><strong>R13是堆栈指针，别名：SP</strong>；
<ul>
<li>MSP（Main Stack Pointer）:主模式下使用</li>
<li>PSP（Process Stack Pointer）：操作系统/线程切换使用</li>
</ul>
</li>
<li><strong>R14是链接寄存器，用于保存函数返回地址，别名：LR</strong>；</li>
<li><strong>R15是程序计数器，用于跳转到下一个执行的命令，别名：PC</strong>；</li>
</ul>
<h3 id="qstm32f1与f4的区别"><a class="markdownIt-Anchor" href="#qstm32f1与f4的区别"></a> Q：STM32F1与F4的区别？</h3>
<ul>
<li>
<p><strong>内核</strong> ：F1是M3，F4是M4</p>
</li>
<li>
<p><strong>主频</strong>：F1最大主频是72MHz，F4最大主频是168MHz</p>
</li>
<li>
<p><strong>浮点</strong>：F1无浮点计算，F4有</p>
</li>
<li>
<p><strong>功能</strong>：F4外设比F1功能更强大</p>
</li>
</ul>
<h2 id="stm32的五个时钟源"><a class="markdownIt-Anchor" href="#stm32的五个时钟源"></a> STM32的五个时钟源</h2>
<ul>
<li>
<p>HSI是高速内部时钟，RC振荡器，频率8MHz，精度不高</p>
</li>
<li>
<p><strong>HSE是高速外部时钟</strong>，可接石英/陶瓷谐振器，频率4~16MHz，<strong>常用作主系统时钟源</strong></p>
</li>
<li>
<p>LSI是低速内部时钟，RC振荡器，频率40KHz，通过低功耗时钟</p>
</li>
<li>
<p>LSE是低速外部时钟，石英晶体，频率32.768KHz</p>
</li>
<li>
<p><strong>PLL是锁相环倍频输出，时钟源可以为HSI / 2、HSE或HSE / 2，倍频范围是2~16倍，最大72MHz</strong></p>
</li>
</ul>
<p><strong>时钟树</strong>：系统时钟 SYSCLK → AHB（HCLK）→ APB1/PCLK1、APB2/PCLK2</p>
<h3 id="q设置系统时钟的基本流程"><a class="markdownIt-Anchor" href="#q设置系统时钟的基本流程"></a> Q：设置系统时钟的基本流程？</h3>
<ol>
<li>开启外部高速时钟HSE</li>
<li>设置Flash的等待周期</li>
<li>设置APB1、APB2、AHB分频系数（RCC_CFGR寄存器）</li>
<li>设置PLL的时钟来源和倍频系数</li>
<li>使能PLL</li>
<li>将系统时钟切换到PLL</li>
</ol>
<h2 id="stm32启动过程"><a class="markdownIt-Anchor" href="#stm32启动过程"></a> STM32启动过程</h2>
<ol>
<li>
<p><strong>通过Boot引脚决定启动方式</strong>（Flash、系统内存、SRAM）</p>
</li>
<li>
<p><strong>加载中断向量表</strong>（从起始地址读取，比如0x0800 0000）</p>
</li>
<li>
<p><strong>初始化栈指针</strong>（加载__initial_sp，这是向量表的第0项，0x0800 0000）</p>
</li>
<li>
<p><strong>指向复位程序</strong>（执行Reset_Handler，这是向量表的第1项，0x0800 0004）</p>
</li>
<li>
<p>在Reset_Handler中</p>
<ul>
<li>复制数据段（data）到RAM</li>
<li>清空BSS段</li>
<li>调用SystemInit设置系统时钟</li>
<li>调用 __main ----&gt; main()</li>
</ul>
</li>
<li>
<p><strong>设置异常中断</strong> 	HardFault_Handler</p>
</li>
</ol>
<h2 id="gpio"><a class="markdownIt-Anchor" href="#gpio"></a> GPIO</h2>
<ul>
<li>
<p><strong>四种输入</strong>：上拉输入、下拉输入、浮空输入、模拟输入</p>
</li>
<li>
<p><strong>四种输出</strong>：通用推挽、复用推挽、通用开漏、复用开漏</p>
</li>
</ul>
<p><strong>APB1总线控制DAC、USB、I2C、SPI、CAN、串口2345、普通TIM</strong></p>
<p><strong>APB2总线控制ADC、USART1、GPIO、TIM1（高级定时器）、AFIO（复用功能）</strong></p>
<h3 id="q开漏与推挽的区别"><a class="markdownIt-Anchor" href="#q开漏与推挽的区别"></a> Q：开漏与推挽的区别？</h3>
<p>推挽可以正常输出高低电平，<strong>开漏</strong>只能输出低电平，<strong>高电平呈现高阻态</strong>，并且需要上拉电阻。</p>
<h3 id="q通用和复用的区别"><a class="markdownIt-Anchor" href="#q通用和复用的区别"></a> Q：通用和复用的区别？</h3>
<p><strong>通用</strong>是单纯做<strong>输入或输出</strong>，<strong>复用</strong>是用作<strong>外设功能引脚</strong></p>
<h2 id="蜂鸣器"><a class="markdownIt-Anchor" href="#蜂鸣器"></a> 蜂鸣器</h2>
<h3 id="内容-2"><a class="markdownIt-Anchor" href="#内容-2"></a> 内容</h3>
<p><strong>有源</strong>蜂鸣器：内部<strong>自带振荡电路</strong>，将正负极接上直流电压即可发声，<strong>频率固定</strong>。</p>
<p><strong>无源</strong>蜂鸣器：内部<strong>不带</strong>振荡电路，需要控制器提供振荡脉冲发生，<strong>频率不固定</strong>。</p>
<h2 id="中断"><a class="markdownIt-Anchor" href="#中断"></a> 中断</h2>
<h3 id="内容-3"><a class="markdownIt-Anchor" href="#内容-3"></a> 内容</h3>
<p><strong>EXIT</strong>(Extern Interrupt)：外部中断控制器，<strong>监听GPIO引脚的电平变化</strong></p>
<p><strong>NVIC</strong>(Nested Vector Interrupt Control)：嵌套向量中断控制器，<strong>负责中断响应，优先级管理</strong></p>
<p><strong>本质</strong>：程序运行时，EXIT监听指定GPIO电平，一旦发生改变，CPU会暂停当前任务并保存现场，向NVIC发出中断请求，去处理中断程序；当中断程序处理完成后，自行恢复现场，继续执行。</p>
<p>GPIO —&gt; EXTI映射使用AFIO</p>
<p>触发方式：上升沿/下降沿/双边沿</p>
<h3 id="qstm32支持多少个外部中断"><a class="markdownIt-Anchor" href="#qstm32支持多少个外部中断"></a> Q：STM32支持多少个外部中断？</h3>
<p>19个外部中断，但只有7个中断服务函数。</p>
<h3 id="q中断和异常"><a class="markdownIt-Anchor" href="#q中断和异常"></a> Q：中断和异常？</h3>
<p>中断通常由外部硬件设备产生，如IO中断，时钟中断等；异常通常由CPU内部产生，如数组越界，除零操作等。</p>
<p>TIP：<strong>中断的优先级数值越小，优先级越高</strong>，比如抢占优先级和响应优先级。</p>
<h2 id="timer"><a class="markdownIt-Anchor" href="#timer"></a> TIMER</h2>
<p><strong>16位计数器、预分频器、自动重装寄存器的时基单元</strong>，在72MHz时钟可以实现最大59.65s的定时。</p>
<ul>
<li>
<p><strong>基础</strong>定时器：<strong>仅支持计数</strong></p>
</li>
<li>
<p><strong>通用/高级</strong>定时器：<strong>支持向上计数、向下计数、中央对齐</strong></p>
</li>
</ul>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>定时器计数频率：</mtext><mi>C</mi><mi>K</mi><mi mathvariant="normal">_</mi><mi>C</mi><mi>N</mi><mi>T</mi><mo>=</mo><mfrac><mrow><mi>C</mi><mi>L</mi><mi>C</mi><mi>K</mi></mrow><mrow><mi>P</mi><mi>S</mi><mi>C</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">
定时器计数频率：CK\_CNT = \frac{CLCK}{PSC + 1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9933em;vertical-align:-0.31em;"></span><span class="mord cjk_fallback">定时器计数频率：</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.13889em;">CNT</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1297em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">PSC</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>
<p>CLCK是定时器输入时钟（一般是APB时钟），PSC是预分频器数值。</p>
<p><img src="https://s2.loli.net/2025/05/07/EjZKNokdDmv8YpH.png" alt="" /></p>
<h3 id="q如何设置一个20ms定时器"><a class="markdownIt-Anchor" href="#q如何设置一个20ms定时器"></a> Q：如何设置一个20ms定时器？</h3>
<p>给定HCLK = 72MHz，选择预分频系数PSC = 7199，计算CK_CNT = 10KHz = 0.1ms，只需要计数200次即可。</p>
<h3 id="q如何开启定时器"><a class="markdownIt-Anchor" href="#q如何开启定时器"></a> Q：如何开启定时器？</h3>
<ol>
<li>开启RCC时钟</li>
<li>配置时基单元的时钟源</li>
<li>配置预分频系数和自动重装载值</li>
<li>配置中断控制和NVIC中断优先级</li>
<li>使能定时器</li>
</ol>
<h2 id="adc"><a class="markdownIt-Anchor" href="#adc"></a> ADC</h2>
<p><strong>Analog - Digital Converter</strong>：模拟 - 数字转换器</p>
<p><strong>12位逐次逼近型ADC</strong>，转换时间约1us</p>
<p>输入电压：0 ~ 3.3V，转换范围：0 ~ 4095</p>
<p><strong>ADC转换的步骤：采样 —&gt; 保持 —&gt;量化 —&gt; 编码</strong></p>
<h3 id="qstm32-adc的总转换时间如何计算"><a class="markdownIt-Anchor" href="#qstm32-adc的总转换时间如何计算"></a> Q：STM32 ADC的总转换时间如何计算</h3>
<p>T = 采样时间 + 12.5个ADC周期</p>
<p>（12个周期量化，0.5周期位采样保持转换的准备时间）</p>
<h2 id="stm32的flash"><a class="markdownIt-Anchor" href="#stm32的flash"></a> STM32的Flash</h2>
<ul>
<li><strong>Flash写入只能将1写成0，不能将0写成1</strong>，因此要写新数据，必须先擦除（擦除是将0恢复成1）</li>
<li>结构层级：<strong>页 &lt; 扇区 &lt; 块 &lt; 芯片</strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">每块</th>
<th style="text-align:center">每扇页</th>
<th style="text-align:center">每页</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">16扇页</td>
<td style="text-align:center">16页</td>
<td style="text-align:center">256 Byte</td>
</tr>
</tbody>
</table>
<p><strong>常用的Flash擦写规则</strong></p>
<ul>
<li>最小擦除：扇区</li>
<li>可选择擦除：扇区、块、全片</li>
<li>最大写入单位：页（不能跨页写入）</li>
<li>最小写入单位：1 字节</li>
<li><strong>未写入时默认FLASH全为1（0xFF）</strong></li>
<li>写操作只能把1变成0，若需恢复0变1，则必须先擦除</li>
</ul>
<h3 id="qnor-flash和nand-flash区别"><a class="markdownIt-Anchor" href="#qnor-flash和nand-flash区别"></a> Q：NOR Flash和NAND Flash区别？</h3>
<ul>
<li>
<p><strong>NOR Flash支持随机读取，NAND Flash块读取</strong></p>
</li>
<li>
<p>NOR<strong>读</strong>得比NAND<strong>快</strong></p>
</li>
<li>
<p>NOR<strong>写和擦慢，容量小，价格贵</strong></p>
</li>
</ul>
<h2 id="存储器之间对照"><a class="markdownIt-Anchor" href="#存储器之间对照"></a> 存储器之间对照</h2>
<ul>
<li>
<p><strong>SRAM</strong>：静态随机存储，不需要定时刷新充电，存储速度快，容量小，<strong>断电丢失</strong></p>
</li>
<li>
<p><strong>DRAM</strong>：动态随机存储，需要定时刷新充电，价格比SRAM便宜，但访问速度慢，耗电量大</p>
</li>
<li>
<p><strong>E2PROM</strong>：带电可擦除可编辑只读存储器，<strong>断电后仍能保存信息，可以单字节擦除</strong></p>
</li>
<li>
<p><strong>FLASH（ROM）</strong>：闪存，存取速度慢，容量大，<strong>掉电不丢失，按扇区/块擦除</strong></p>
</li>
</ul>
<h2 id="dma"><a class="markdownIt-Anchor" href="#dma"></a> DMA</h2>
<p><strong>Direct Memory Access</strong>：直接存储器访问控制器</p>
<p><strong>用途</strong>：允许外设或存储器和存储器之间高速数据传输，<strong>无需CPU干预，节省CPU资源</strong></p>
<p><em>使用小寄巧：DMA可以获取当前剩余数据量，根据设置的接收buffer大小减去当前剩余数据量，得到<strong>当前接收数据大小</strong></em></p>
<p>STM32F103C8T6 DMA资源： DMA1</p>
<p><strong>Q：DMA的传输模式有哪些？</strong></p>
<ul>
<li>
<p><strong>DMA_Mode_Normal</strong>，正常缓存模式，<strong>完成指定大小传输后停止</strong></p>
</li>
<li>
<p><strong>DMA_Mode_Circle</strong>， 循环模式，<strong>传输完成后自动重新加载，连续传输</strong></p>
</li>
</ul>
<h2 id="通信协议总览"><a class="markdownIt-Anchor" href="#通信协议总览"></a> 通信协议总览</h2>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">双工</th>
<th style="text-align:center">时钟</th>
<th style="text-align:center">电平</th>
<th style="text-align:center">设备</th>
<th style="text-align:center">引脚</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">UART</td>
<td style="text-align:center">全双工</td>
<td style="text-align:center">异步</td>
<td style="text-align:center">单端</td>
<td style="text-align:center">点对点</td>
<td style="text-align:center">TX、RX</td>
</tr>
<tr>
<td style="text-align:center">I2C</td>
<td style="text-align:center">半双工</td>
<td style="text-align:center">同步</td>
<td style="text-align:center">单端</td>
<td style="text-align:center">多设备</td>
<td style="text-align:center">SCL、SDA</td>
</tr>
<tr>
<td style="text-align:center">SPI</td>
<td style="text-align:center">全双工</td>
<td style="text-align:center">同步</td>
<td style="text-align:center">单端</td>
<td style="text-align:center">多设备</td>
<td style="text-align:center">CS、SCLK、MOSI、MISO</td>
</tr>
<tr>
<td style="text-align:center">CAN</td>
<td style="text-align:center">半双工</td>
<td style="text-align:center">异步</td>
<td style="text-align:center">差分</td>
<td style="text-align:center">多设备</td>
<td style="text-align:center">CAN_H、CAN_L</td>
</tr>
<tr>
<td style="text-align:center">USB</td>
<td style="text-align:center">半双工</td>
<td style="text-align:center">异步</td>
<td style="text-align:center">差分</td>
<td style="text-align:center">点对点</td>
<td style="text-align:center">DP、DM</td>
</tr>
</tbody>
</table>
<h2 id="uart"><a class="markdownIt-Anchor" href="#uart"></a> UART</h2>
<p><strong>串口通信</strong></p>
<p><img src="https://s2.loli.net/2025/05/07/yfZ6Hv5uq1SL8m9.png" alt="" /></p>
<p><strong>低位先行</strong>：若发送信息0X0F，则传输数据位是1111 0000，最终接收信息0X0F</p>
<p>波特率对齐（比特率=波特率 * log2（N)，N是二进制位数）；</p>
<p><strong>过程</strong>：起始一个<strong>低电平</strong>信号表示<strong>开始发送数据</strong>，接着是<strong>8个数据位</strong>，然后是校验位（奇/偶/NONE），最后是<strong>高电平</strong>表示停止位（0.5/1/1.5/2）</p>
<p><img src="https://s2.loli.net/2025/05/07/NJ3RueE5X7DtIoj.png" alt="" /></p>
<h3 id="q串口通信如何配置"><a class="markdownIt-Anchor" href="#q串口通信如何配置"></a> Q：串口通信如何配置？</h3>
<ol>
<li>串口<strong>时钟使能</strong>，GPIO时钟使能</li>
<li><strong>复位</strong>串口外设</li>
<li>配置GPIO
<ul>
<li><strong>TX</strong>为<strong>复用推挽</strong>，<strong>RX</strong>为<strong>浮空输入</strong></li>
</ul>
</li>
<li>初始化串口参数（波特率，数据位，校验位，收发模式）</li>
<li><strong>开启中断并初始化NVIC</strong></li>
<li><strong>使能串口外设</strong></li>
<li><strong>编写串口函数</strong></li>
</ol>
<h3 id="q描述下rs232和rs485的区别"><a class="markdownIt-Anchor" href="#q描述下rs232和rs485的区别"></a> Q：描述下RS232和RS485的区别？</h3>
<p><strong>TTL（全双工）</strong>：0V表示0，+3.3V~+5V表示1</p>
<p><strong>RS232（全双工）</strong>：+3V ~ +15V表示0，-3V ~ -15V表示1，（TTL通过RS232芯片）</p>
<p><strong>RS485（半双工）</strong>：两线电压差-2V ~ -6V表示0，+2V ~ +6V表示1（TTL通过RS485芯片）</p>
<h2 id="i2c"><a class="markdownIt-Anchor" href="#i2c"></a> I2C</h2>
<p>Inter IC BUS（<strong>同步、半双工</strong>），支持<strong>一主多从和多主多从</strong>（MSB高位先行）</p>
<p>两根通信线：SCL（Serial Clock）、SDA（Serial Data），上拉电阻一般4.7K~10K</p>
<p><strong>STM32支持7/10位地址模式</strong></p>
<p><img src="https://s2.loli.net/2025/05/07/Lh49pJTuEyxrFGB.png" alt="" /></p>
<h3 id="qi2c总线在传输过程中有哪些类型信号"><a class="markdownIt-Anchor" href="#qi2c总线在传输过程中有哪些类型信号"></a> Q：I2C总线在传输过程中有哪些类型信号？</h3>
<ul>
<li><strong>开始信号</strong>：SCL高电平，SDA由高到低，开始发送数据</li>
<li><strong>结束信号</strong>：SCL高电平，SDA由低到高，结束发送数据</li>
<li><strong>应答信号</strong>：SCL高电平，发送8Bit数据，<strong>接收端</strong>向<strong>发送端</strong>发<strong>低电平</strong>，表示<strong>成功接收</strong>（在接收前需要释放SDA）</li>
</ul>
<p><em><strong>TIP：一旦 开始信号产生后，数据传输必须在 SCL 为低时开始。</strong></em></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 作图，记得SCL先行，他决定了此时的信号状态，想一想Start和Stop</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* SCL高电平，SDA从高到低，记得拉低SCL，防止被错误认为是另一个起始条件 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SCL_H;			<span class="comment">//	SCL高</span></span><br><span class="line">    SDA_H;			<span class="comment">//	SDA高</span></span><br><span class="line">    Delay_us(<span class="number">2</span>);</span><br><span class="line">    SDA_L;			<span class="comment">//	SDA低</span></span><br><span class="line">    SCL_L;			<span class="comment">//	SCL低</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* End信号，SCL高电平，SDA从低到高 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    SCL_L;</span><br><span class="line">    SDA_L;</span><br><span class="line">    SCL_H;</span><br><span class="line">    SDA_H;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>TIP：软件模拟I2C时，SDA电平切换只出现在SCL低电平阶段，不要搞混</strong></em></p>
<h3 id="qi2c的软硬件模式怎么配置"><a class="markdownIt-Anchor" href="#qi2c的软硬件模式怎么配置"></a> Q：I2C的软硬件模式怎么配置？</h3>
<p><strong>硬件模式：复用开漏输出+上拉电阻</strong>；内部有固定I2C结构；有通信速率设置，400Kbps</p>
<p><strong>软件模式：通用开漏输出+上拉电阻</strong>；通过GPIO模拟I2C信号；没有通信速率配置，<strong>需要自己写一个delay</strong>，100Kbps</p>
<p>TIP：有些人偷懒用 <code>GPIO_MODE_OUTPUT_PP</code>（推挽）来模拟，但必须自己手动释放SDA变高</p>
<h3 id="qi2c的仲裁机制"><a class="markdownIt-Anchor" href="#qi2c的仲裁机制"></a> Q：I2C的仲裁机制？</h3>
<p><strong>“线与”<strong>操作（&amp;&amp;），即</strong>低电平优先</strong>，谁先发送低电平，谁就对总线占有控制权。</p>
<h3 id="qi2c的从机设备地址id-写地址-读地址"><a class="markdownIt-Anchor" href="#qi2c的从机设备地址id-写地址-读地址"></a> Q：I2C的从机设备地址ID、写地址、读地址？</h3>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">该部分需要查询对应芯片手册!</span><br><span class="line">举例AT24C02，地址ADDR = <span class="number">1010</span>，控制格式<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">0</span> A2 A1 A0 R/W。</span><br><span class="line">若A2 = <span class="number">0</span>，A1 = <span class="number">0</span>，A0 = <span class="number">0</span>，写操作R/W=<span class="number">0</span>，读操作R/W=<span class="number">1</span></span><br><span class="line">    <span class="comment">// TIP: 正常I2C发送7位，是不带R/W，所以设备地址有变化，详细可以去问下GPT</span></span><br><span class="line">    设备地址 <span class="number">0101</span> <span class="number">0000</span> <span class="number">0X50</span>（控制格式去掉R/W后右移，高位补<span class="number">0</span>）</span><br><span class="line">    写地址为 <span class="number">1010</span> <span class="number">0000</span> <span class="number">0XA0</span>（设备地址&lt;&lt;<span class="number">1</span> | <span class="number">0</span>）</span><br><span class="line">    读地址为 <span class="number">1010</span> <span class="number">0001</span> <span class="number">0XA1</span>（设备地址&lt;&lt;<span class="number">1</span> | <span class="number">1</span>）</span><br></pre></td></tr></table></figure>
<h4 id="特定地址写"><a class="markdownIt-Anchor" href="#特定地址写"></a> 特定地址写</h4>
<p><img src="https://s2.loli.net/2025/05/07/rdzHou5UOhMECKZ.png" alt="" /></p>
<h4 id="当前地址读"><a class="markdownIt-Anchor" href="#当前地址读"></a> 当前地址读</h4>
<p><img src="https://s2.loli.net/2025/05/07/2uT3q6VhUWELOZy.png" alt="" /></p>
<h2 id="spi"><a class="markdownIt-Anchor" href="#spi"></a> SPI</h2>
<p><strong>Serial Peripheral Interface</strong>：串行外设接口（<strong>MSB先行</strong>），<strong>速度比I2C快很多</strong></p>
<p>四根通信线：</p>
<ul>
<li><strong>SCLK（Serial Clock）</strong></li>
<li><strong>MOSI（Master Output Slave Input）</strong></li>
<li><strong>MISO（Master Input Slave Output）</strong></li>
<li><strong>CS</strong></li>
</ul>
<p><strong>MISO输入为上拉或浮空输入，SCLK、MOSI输出配置为复用推挽输出、CS配置为推挽输出。</strong></p>
<ul>
<li>
<p><strong>起止条件</strong>：CS高电平切换到低电平</p>
</li>
<li>
<p><strong>终止条件</strong>：CS低电平切换到高电平</p>
</li>
<li>
<p><strong>发送信息</strong>：<strong>CS一直为低电平</strong></p>
</li>
</ul>
<h3 id="q四种工作模式"><a class="markdownIt-Anchor" href="#q四种工作模式"></a> Q：四种工作模式</h3>
<p>时钟极性CPOL（上升沿/下降沿）；时钟相位CPHA（第一个边沿/第二个边沿）</p>
<ul>
<li><strong>CPOL = 0 ------&gt;上升沿</strong></li>
<li><strong>CPOL = 1 ------&gt; 下降沿</strong></li>
<li><strong>CPHA = 0 ------&gt;第一个边沿</strong></li>
<li><strong>CPHA = 1 ------&gt; 第二个边沿</strong></li>
</ul>
<h3 id="q如何确定使用哪个模式"><a class="markdownIt-Anchor" href="#q如何确定使用哪个模式"></a> Q：如何确定使用哪个模式</h3>
<p>看<strong>从机空闲状态</strong>是低电平还是高电平，来确认CPOL；再从<strong>从机芯片时序图里确认何时采取数据</strong>。</p>
<p><strong>下图解释：在没有进入Cycle时，通过SPICLK是高低电平来判断CPOL；CPHA通过正中间的那个边沿判断。</strong></p>
<p><img src="https://s2.loli.net/2025/05/07/SEBAmWquCTYNJaZ.png" alt="" /></p>
<h3 id="q陀螺仪可以用spi通信吗有什么好处"><a class="markdownIt-Anchor" href="#q陀螺仪可以用spi通信吗有什么好处"></a> Q：陀螺仪可以用SPI通信吗，有什么好处？</h3>
<p>有的既可以使用SPI，也可以使用I2C，当然SPI的传输速度会更快<br />
<strong>MPU6050只能I2C，MPU9250可以I2C和SPI</strong></p>
<h2 id="看门狗"><a class="markdownIt-Anchor" href="#看门狗"></a> 看门狗</h2>
<p>看门狗监控程序运行状态，当程序因为设计漏洞、硬件故障导致出现卡死等问题时，看门狗可以及时复位程序；<strong>本质是定时器</strong>，在指定范围内，<strong>程序没有执行喂狗</strong>（重置计数器），看门狗硬件<strong>会自动产生复位</strong>信号。</p>
<p><strong>独立看门狗（IWDG）</strong>：独立于主系统时钟，时间精度低，<strong>开启就无法关闭</strong>。</p>
<p><strong>窗口看门狗（WWDG）</strong>：能产生<strong>系统复位信号和提前唤醒中断</strong>。</p>
<h2 id="i2s"><a class="markdownIt-Anchor" href="#i2s"></a> I2S</h2>
<p>I2S（Inter-IC Sound）是一种广泛应用于数字音频传输的串行接口标准</p>
<p>应用场景如下</p>
<p><strong>I2S RX方向</strong>：麦克风在机械振动下将声音信号转变为电压信号，电压信号经过放大等处理，给到ADC采样，将模拟信号转化为数字信号；音频在ADC与DSP之间的传输协议就是使用的I2S协议。</p>
<p><strong>I2S TX方向</strong>：数字信号经过编码、存储、压缩等技术后，发送给解码器DAC（DSP、专用解码器），将数字信号还原为模拟信号，最后给到喇叭完成声音/音频的播放。音频在DAC与DSP之间的传输就是使用I2S协议。</p>
<p><img src="https://s2.loli.net/2025/07/24/VeDQ5lg7JZ1WLHE.png" alt="" /></p>
<h3 id="基本信号线"><a class="markdownIt-Anchor" href="#基本信号线"></a> 基本信号线</h3>
<p><img src="https://s2.loli.net/2025/07/24/rmOP4cp9dV7i5ka.png" alt="" /></p>
<p><strong>时钟线（Continues Serial Clock，SCK）</strong>：SCK提供传输时的时钟信号，确定了数据传输的速度和时序，也称之为BCLK；<strong>SCK的频率 = 2 x 采样频率 x 位宽</strong></p>
<p><strong>左/右声道线（Left-Right Clock，LRCK）</strong>：LRCK线指示了当前传输的是左声道的音频数据还是右声道的音频数据。又称<strong>帧同步信号</strong>。<strong>LRCK的频率 = 采样频率</strong></p>
<p><strong>数据线（Serial Data，SD）</strong>：SD线用于传输实际的音频数据。数据的位宽可以根据具体应用而变化，通常为16位或32位。TX方向为：Serial Data Out（SDOUT）；RX方向为：Serial Data In（SDIN）。</p>
<h3 id="常见参数说明"><a class="markdownIt-Anchor" href="#常见参数说明"></a> 常见参数说明</h3>
<ul>
<li><strong>位宽</strong>（Word Length）：位宽指定<strong>每个采样数据的位数</strong>，通常为16位或32位。较大的位宽可以提供更高的分辨率和动态范围。</li>
<li><strong>时钟极性</strong>（Clock Polarity）：时钟极性确定了<strong>数据位传输的时钟沿</strong>。根据具体的I2S设备和系统设置，可以定义在时钟上升沿或下降沿开始数据传输</li>
<li><strong>帧同步极性</strong>（Frame Sync Polarity）：帧同步极性确定了<strong>帧同步信号的有效电平</strong>。帧同步信号指示音频数据的帧起始和结束位置。</li>
<li><strong>传输格式</strong>（Data Format）：传输格式定义了<strong>音频数据的编码方式</strong>，传输格式还可以指定数据的顺序，如左声道先传输还是右声道先传输</li>
</ul>
<h3 id="主从模式"><a class="markdownIt-Anchor" href="#主从模式"></a> 主从模式</h3>
<p>I2S工作模式可以是主模式（Master Mode）或从模式（Slave Mode）。两者唯一的区别是：Master Mode提供时钟信号（SCK）和帧同步信号（LRCK）</p>
<p><img src="https://s2.loli.net/2025/07/24/NtylZ6xkdAULSzc.png" alt="" /></p>
<h3 id="数据传输模式"><a class="markdownIt-Anchor" href="#数据传输模式"></a> 数据传输模式</h3>
<p>I2S接口标准中，存在三种数据传输模式，分别是：**飞利浦标准模式（I2S mode），左对齐（Left Justified）和右对齐（Right Justified）**三种传输模式。</p>
<ul>
<li><strong>飞利浦标准模式</strong></li>
</ul>
<p><img src="https://s2.loli.net/2025/07/24/vDoh63pXNgzyTSf.png" alt="" /></p>
<p>（1）LRCK（左右声道选择信号）：LRCK信号用于指示当前数据帧是左声道数据还是右声道数据。<strong>飞利浦格式中</strong>，当<strong>LRCK为低</strong>时，表示当前传输的数据是<strong>左声道</strong>数据；当<strong>LRCK为高</strong>时，表示当前传输的数据为<strong>右声道</strong>数据</p>
<p>（2）SCK（位时钟）：数据传输的时钟信号。<strong>在SCK下降沿发送数据，在SCK上升沿采样数据</strong></p>
<p>（3）<strong>Data Delay</strong>：发送的有效数据相对于LRCK的跳变沿（从0到1或从1到0）延迟一个时钟周期</p>
<p>（4）数据发送从MSB开始；<strong>数据MSB与LRCK delay 1个SCK的边沿对齐</strong></p>
<ul>
<li><strong>左对齐模式</strong></li>
</ul>
<p><img src="https://s2.loli.net/2025/07/24/MDc5SaFyL4WjPQN.png" alt="" /></p>
<p>（1）在左对齐格式中，<strong>LRCK为高</strong>时，表示当前传输的数据为<strong>左声道数据</strong>；当<strong>LRCK为低</strong>时，表示当前传输的数据为<strong>右声道</strong>数据</p>
<p>（2）<strong>在SCK下降沿发送数据，在SCK上升沿接收数据</strong></p>
<p>（3）<strong>无data delay</strong>：发送的有效数据相当于LRCK跳变沿（从0到1或从1到0）不延迟</p>
<p>（4）数据发送从MSB开始；<strong>数据MSB与LRCK跳变沿对齐</strong></p>
<ul>
<li>右对齐模式</li>
</ul>
<p><img src="https://s2.loli.net/2025/07/24/86L1tIylvoDk3R2.png" alt="" /></p>
<p>（1）右对齐格式中，<strong>LRCK为高</strong>时，表示当前传输的数据为<strong>右声道</strong>数据；当<strong>LRCK为低</strong>时，表示当前传输的数据为<strong>左声道</strong>数据</p>
<p>（2）<strong>在SCK下降沿发送数据，在SCK上升沿接收数据</strong></p>
<p>（3）<strong>无Data delay</strong>：发送的有效数据相当于LRCK跳变沿（从0到1或从1到0）不延迟</p>
<p>（4）数据发送从MSB开始；<strong>数据LSB与LRCK跳变沿对齐</strong></p>
<h3 id="数据位宽与位深"><a class="markdownIt-Anchor" href="#数据位宽与位深"></a> 数据位宽与位深</h3>
<p><strong>位宽计算过程</strong>：</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>S</mi><mi>C</mi><mi>K</mi><mo>=</mo><mn>2</mn><mo>∗</mo><mtext>采样频率</mtext><mo>∗</mo><mtext>位宽</mtext><mo>=</mo><mn>2</mn><mo>∗</mo><mi>L</mi><mi>R</mi><mi>C</mi><mi>K</mi><mo>∗</mo><mtext>位宽</mtext><mspace linebreak="newline"></mspace><mtext>位宽</mtext><mo>=</mo><mi>S</mi><mi>C</mi><mi>K</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mn>2</mn><mo>∗</mo><mi>L</mi><mi>R</mi><mi>C</mi><mi>K</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">
SCK = 2 * 采样频率 * 位宽 = 2 * LRCK * 位宽 \\

位宽 = SCK / (2 * LRCK)
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">SC</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">采样频率</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">位宽</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">RC</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">位宽</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">位宽</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">SC</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord">/</span><span class="mopen">(</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">RC</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mclose">)</span></span></span></span></span>
<p><strong>位深</strong>：表示音频数据量化后的精度（<strong>I2S中位宽和位深都是由Master决定的</strong>）</p>
<p>下面是<strong>32位位宽，20位位深</strong></p>
<p><img src="https://s2.loli.net/2025/07/24/CA15xFE6yzMKtvb.png" alt="" /></p>
<h2 id="can以下的不建议看去看另外一篇吧"><a class="markdownIt-Anchor" href="#can以下的不建议看去看另外一篇吧"></a> CAN（以下的不建议看，去看另外一篇吧）</h2>
<h3 id="内容-4"><a class="markdownIt-Anchor" href="#内容-4"></a> 内容</h3>
<p>CAN总线（<strong>Controller Area Network Bus</strong>）控制器局域网总线。</p>
<p>一个节点包括3个部分：<strong>微处理MCU、CAN控制器、CAN收发器。</strong>（CAN_H、CAN_L为双绞线）</p>
<p><strong>开环网络两端</strong>必须有<strong>2.2KΩ的终端电阻</strong>；<strong>闭环网络两端</strong>必须有<strong>120Ω的终端电阻（抗干扰作用）</strong>；</p>
<p>（信号到终端被电阻吸收，避免反射回干扰下一次信号，所以一般都是放两端）</p>
<p><img src="https://s2.loli.net/2025/05/07/iQW4DOth8NynmJC.png" alt="" /></p>
<p><strong>CAN BUS</strong>（右边那一块）上的总线电平称为<strong>隐形电平和显性电平</strong>。</p>
<h3 id="ios11898标准"><a class="markdownIt-Anchor" href="#ios11898标准"></a> <strong>IOS11898标准</strong></h3>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">性质</th>
<th style="text-align:center">逻辑</th>
<th style="text-align:center">CAN_H</th>
<th style="text-align:center">CAN_L</th>
<th style="text-align:center">两条线上的电压差</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Recessive</td>
<td style="text-align:center">隐性</td>
<td style="text-align:center">逻辑1</td>
<td style="text-align:center">2.5V</td>
<td style="text-align:center">2.5V</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">Dominant</td>
<td style="text-align:center">显性</td>
<td style="text-align:center">逻辑0</td>
<td style="text-align:center">3.5V</td>
<td style="text-align:center">1.5V</td>
<td style="text-align:center">2V</td>
</tr>
</tbody>
</table>
<p>多个节点一起开始发送，会涉及到<strong>总线仲裁</strong>。</p>
<h3 id="can帧的种类"><a class="markdownIt-Anchor" href="#can帧的种类"></a> CAN帧的种类</h3>
<table>
<thead>
<tr>
<th style="text-align:center">序号</th>
<th style="text-align:center">名称</th>
<th style="text-align:center">帧用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">数据帧</td>
<td style="text-align:center">用于发送单元向接收单元传送数据的帧。</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">遥控帧</td>
<td style="text-align:center">用于接收单元向具有相同 ID 的发送单元请求数据的帧。</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">错误帧</td>
<td style="text-align:center">用于当检测出错误时向其它单元通知错误的帧。 （硬件自动完成）</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">过载帧</td>
<td style="text-align:center">当一个节点正忙于处理接收的信息,可以通知其它节点暂缓发送新报文。（硬件自动完成）</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">帧间隔</td>
<td style="text-align:center">用于将数据帧及远程帧与前面的帧分离开来的帧（硬件自动完成）</td>
</tr>
</tbody>
</table>
<p>每个节点都可以自己发送帧（<strong>帧是CAN协议规定发送或接收的单位</strong>）</p>
<p><img src="https://s2.loli.net/2025/05/07/zBLUehdCMscOtR3.png" alt="" /></p>
<p><img src="https://s2.loli.net/2025/05/07/El7tqDN9u3SCAs5.png" alt="" /></p>
<table>
<thead>
<tr>
<th>序号</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>帧起始</td>
<td>表示帧的开始，产生一个bit的显性电平</td>
</tr>
<tr>
<td>2</td>
<td>仲裁段</td>
<td>表示帧的优先级， 由标识符（ID）和传送帧类型(RTR)组成</td>
</tr>
<tr>
<td>3</td>
<td>控制段</td>
<td>表示数据的字节数，由6个bit构成</td>
</tr>
<tr>
<td>4</td>
<td>数据段</td>
<td>数据的具体内容，可发送0～8 个字节的数据</td>
</tr>
<tr>
<td>5</td>
<td>CRC段</td>
<td>用于校验传输是否正确</td>
</tr>
<tr>
<td>6</td>
<td>ACK段</td>
<td>表示确认是否正常接收（0为应答）</td>
</tr>
<tr>
<td>7</td>
<td>帧结束</td>
<td>表示此帧结束</td>
</tr>
</tbody>
</table>
<p><img src="https://s2.loli.net/2025/05/07/QPHtCxUK7IW2z4c.png" alt="" /></p>
<ul>
<li>
<p><strong>仲裁段</strong>：可以根据配置好的设置，自动判断要不要接收报文，该方案也叫作过滤，判断依据是每个报文的ID。</p>
</li>
<li>
<p>标准格式的标识符长度为11位，拓展格式是29位</p>
</li>
<li>
<p><strong>RTR</strong>位，它来<strong>表明是数据帧（0）还是远程帧（1）</strong></p>
</li>
<li>
<p><strong>IDE</strong>表明<strong>此帧是标准帧（0）还是拓展帧（1）</strong>。</p>
</li>
<li>
<p><strong>控制段</strong>：控制段表示数据段的字节数。</p>
</li>
<li>
<p><strong>保留位（r0、r1）</strong>，必须<strong>全部以显性电平发送</strong>，但接收方可以接收显性、隐性的各种组合。</p>
</li>
<li>
<p><strong>数据长度码（Data Link Control）</strong>，数据字节必须为0-8字节，但接收方对数据字节数=9~15的情况并不视为错误。</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2025/05/07/s74bY1mifvpLBSP.png" alt="" /></p>
<p><strong>数据段</strong>：0-8个字节数据，CAN控制器有对应的寄存器。</p>
<p><strong>位填充机制：<strong>当检测到</strong>五个连续相同的位信号</strong>，实际发送会<strong>自动插入一个补码</strong>，<strong>位填充区域为SOF到CRC结束之间</strong></p>
<h3 id="仲裁方案"><a class="markdownIt-Anchor" href="#仲裁方案"></a> 仲裁方案</h3>
<ol>
<li>
<p><strong>在总线空闲时，最先开始发送的节点获得发送权</strong>，一旦开始发送，不会被其他节点抢占。</p>
</li>
<li>
<p><strong>多个节点同时开始发送时，各发送节点从仲裁段的第一位开始进行仲裁。连续输出显性电平最多的节点可继续发送</strong>。(从左到右，Dominant ：显性优先)</p>
</li>
<li>
<p><strong>具有相同ID的数据帧和远程帧在总线上竞争时，仲裁段的最后一位（RTR）为显性位的数据帧具有优先权可继续发送。</strong></p>
</li>
<li>
<p><strong>标准格式ID与具有相同ID的远程帧或者扩展格式的数据帧在总线上竞争时，标准格式的RTR 位为显性位的具有优先权可继续发送。</strong></p>
</li>
</ol>
<h3 id="can过滤器配置"><a class="markdownIt-Anchor" href="#can过滤器配置"></a> CAN过滤器配置</h3>
<p>过滤模式：<strong>列表模式和掩码模式</strong></p>
<p><strong>列表模式</strong>：<strong>列出ID名称</strong>，判断ID是否一致来判断是否接受或者丢弃，<strong>受到列表容量大小限制</strong>。</p>
<p><strong>掩码模式</strong>：确定ID特定位的值来判断是否接受或丢弃，<strong>不受列表容量大小限制</strong>。</p>
<p>配置过滤器，有三个重要的寄存器：CAN_FSIR、CAN_FxR1、CAN_FxR2</p>
<h3 id="can总线错误分类"><a class="markdownIt-Anchor" href="#can总线错误分类"></a> CAN总线错误分类</h3>
<p><img src="https://s2.loli.net/2025/05/07/sMQwR1hOJdrpWy6.png" alt="" /></p>
<h3 id="cubemx配置"><a class="markdownIt-Anchor" href="#cubemx配置"></a> CubeMX配置</h3>
<p>1、配置波特率</p>
<p>位数据段：同步段----传播段（补偿CAN网络的物理延迟）----相位缓冲段1----相位缓冲段2（补偿相位误差）</p>
<p>可能会有早到的，也可能会有晚到的，通过上面的四段可以进行拉长缩小来操作。</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mi>A</mi><mi>N</mi><mtext>波特率</mtext><mo>=</mo><mi>T</mi><mi>Q</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>T</mi><mi>B</mi><mi>S</mi><mn>1</mn><mo>+</mo><mi>T</mi><mi>B</mi><mi>S</mi><mn>2</mn><mo>+</mo><mi>S</mi><mi>J</mi><mi>Y</mi><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mspace linebreak="newline"></mspace><mo>=</mo><mfrac><mrow><mi>A</mi><mi>P</mi><mi>B</mi><mtext>总线频率</mtext><mo>∗</mo><mo stretchy="false">(</mo><mi>T</mi><mi>B</mi><mi>S</mi><mn>1</mn><mo>+</mo><mi>T</mi><mi>B</mi><mi>S</mi><mn>2</mn><mo>+</mo><mi>S</mi><mi>J</mi><mi>Y</mi><mo stretchy="false">)</mo></mrow><mtext>分频系数</mtext></mfrac></mrow><annotation encoding="application/x-tex">
CAN波特率=TQ*(TBS1 + TBS2 + SJY)   \\
\\
= \frac{APB总线频率 * (TBS1 + TBS2 + SJY)}{分频系数}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord cjk_fallback">波特率</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord mathnormal">TQ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">TBS</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7667em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">TBS</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.3669em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.113em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord cjk_fallback">分频系数</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.05017em;">PB</span><span class="mord cjk_fallback">总线频率</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">TBS</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">TBS</span><span class="mord">2</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mord mathnormal" style="margin-right:0.09618em;">J</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>
<p>2、打开CAN的接受中断，两个接收邮箱、三个发送邮箱。</p>
<h2 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h2>
<p><a href="https://blog.csdn.net/w237838/article/details/133916583">Stm32最小系统板的构成详解-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_29350001/article/details/116021595">嵌入式面试知识点总结 – STM32篇_stm32 112+16+64-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/weixin_51084418/article/details/141829654?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~Ctr-3-141829654-blog-116021595.235%5Ev43%5Epc_blog_bottom_relevance_base9&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~Ctr-3-141829654-blog-116021595.235%5Ev43%5Epc_blog_bottom_relevance_base9&amp;utm_relevant_index=6">嵌入式知识点（STM32、uart、spi、iic等总线）_i2c dma hardfault-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/weixin_56102526/article/details/128368370">flash基础知识_flash擦除最小单位-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/laifengyuan1/article/details/107481945">STM32: ADC采样频率及相应时间的确定_adc采样频率计算公式-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_39829913/article/details/104718185">基础通信协议之 IIC (I2C) 详细讲解_i2c通信的详细讲解-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/as480133937/article/details/105764119">SPI原理超详细讲解—值得一看-CSDN博客</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/678943329">(11 封私信) 【I2S】数字音频接口—I2S总线协议基本概念 - 知乎</a></p>
<p><a href="https://blog.csdn.net/qq_35057766/article/details/135580884">一文读懂CAN总线协议 (超详细配34张高清图)_can总线协议详解-CSDN博客</a></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>STM32</tag>
      </tags>
  </entry>
  <entry>
    <title>嘉立创画板</title>
    <url>/2025/08/25/%E5%98%89%E7%AB%8B%E5%88%9B%E7%94%BB%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="嘉立创画板"><a class="markdownIt-Anchor" href="#嘉立创画板"></a> 嘉立创画板</h1>
<p><s>复习，继续复习；学不完，根本学不完</s>~~~</p>
<ul>
<li>电容通交阻直</li>
</ul>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>X</mi><mi>C</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi>w</mi><mi>C</mi></mrow></mfrac><mo>=</mo><mfrac><mn>1</mn><mrow><mn>2</mn><mi>π</mi><mi>f</mi><mi>C</mi></mrow></mfrac></mrow><annotation encoding="application/x-tex">
X_C=\frac{1}{wC}=\frac{1}{2 \pi fC}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.07153em;">C</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.0074em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">wC</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.2019em;vertical-align:-0.8804em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3214em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.8804em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>
<p>频率越<strong>高</strong>，<strong>电容阻抗越小</strong>，越容易通过。</p>
<ul>
<li>电感通直阻交</li>
</ul>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>X</mi><mi>L</mi></msub><mo>=</mo><mi>w</mi><mi>L</mi><mo>=</mo><mn>2</mn><mi>π</mi><mi>f</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">
X_L=wL=2 \pi fL
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3283em;"><span style="top:-2.55em;margin-left:-0.0785em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">L</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mord mathnormal">L</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord">2</span><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">L</span></span></span></span></span>
<p>频率越<strong>低</strong>，<strong>电感阻抗越小</strong>，越容易通过。</p>
<h2 id="需求"><a class="markdownIt-Anchor" href="#需求"></a> 需求</h2>
<p>设计一款基于STM32的开发板。</p>
<h2 id="选型"><a class="markdownIt-Anchor" href="#选型"></a> 选型</h2>
<img src="https://s2.loli.net/2025/08/11/OF6TiVxm9qoBLG2.png" style="zoom:90%;" />
<h3 id="电源设计"><a class="markdownIt-Anchor" href="#电源设计"></a> 电源设计</h3>
<p><img src="https://s2.loli.net/2025/08/11/MJ84TnQicYKgWXH.png" alt="" /></p>
<h3 id="ldo"><a class="markdownIt-Anchor" href="#ldo"></a> LDO</h3>
<p>Low dropout regulator，低压差线性稳压器</p>
<ul>
<li>外围器件少，电路简单，成本低</li>
<li>负载响应快，输出纹波小，噪声少</li>
<li>效率低，输入输出压差不能太大</li>
<li><strong>只能降压</strong></li>
</ul>
<p><a href="https://blog.csdn.net/qq_36347513/article/details/121019508">电子电路学习笔记（14）——LDO(低压差线性稳压器)_ldo电路-CSDN博客</a></p>
<img src="https://s2.loli.net/2025/08/11/nM45vBIUGFSRuWX.png" style="zoom:67%;" />
<h3 id="dcdc转换器"><a class="markdownIt-Anchor" href="#dcdc转换器"></a> DC/DC转换器</h3>
<ul>
<li>外围器件多，电路复杂，成本高</li>
<li>负载响应比LDO慢，输出纹波大，噪声大</li>
<li>效率高，输入电压范围宽泛</li>
<li><strong>既能升压，也能降压</strong></li>
</ul>
<p>开关电源稳压器，利用电容、电感的储能特性，通过可控开关，进行高频开关动作，将输入的电能存储在电容（感）里，当开关断开，电能再释放给负载，提供能量。</p>
<ul>
<li>
<p><strong>降压</strong>DCDC被称为<strong>BUCK</strong>电路</p>
</li>
<li>
<p><strong>升压</strong>DCDC被称为<strong>BOOST</strong>电路</p>
</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/669118603">(11 封私信) 一文搞懂DCDC基础知识 - 知乎</a></p>
<h4 id="buck"><a class="markdownIt-Anchor" href="#buck"></a> BUCK</h4>
<img src="https://s2.loli.net/2025/08/11/O7xfzaCAtnIg56T.png" style="zoom:60%;" />
<h4 id="boost"><a class="markdownIt-Anchor" href="#boost"></a> BOOST</h4>
<img src="https://s2.loli.net/2025/08/11/UKZvDpq7ncMWPTs.png" style="zoom:60%;" />
<h2 id="纹波"><a class="markdownIt-Anchor" href="#纹波"></a> 纹波</h2>
<p>纹波是电源的<strong>交流</strong>分量；纹波大小看峰值在多少，就是多少。</p>
<p><img src="https://s2.loli.net/2025/08/11/zRVKmk81wxnJONy.png" alt="" /></p>
<h2 id="pcb设计"><a class="markdownIt-Anchor" href="#pcb设计"></a> PCB设计</h2>
<p><img src="https://s2.loli.net/2025/08/11/PFI7gjU4KBMJ6we.png" alt="" /></p>
<h3 id="主控"><a class="markdownIt-Anchor" href="#主控"></a> 主控</h3>
<p><img src="https://s2.loli.net/2025/08/11/B5eGWlrEDL6X8Nh.png" alt="" /></p>
<h3 id="电源"><a class="markdownIt-Anchor" href="#电源"></a> 电源</h3>
<p><img src="https://s2.loli.net/2025/08/11/iPRYphT2rvFWa19.png" alt="" /></p>
<h3 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h3>
<p><img src="https://s2.loli.net/2025/08/11/BAOYa7rneQExWli.png" alt="" /></p>
<h2 id="pcb"><a class="markdownIt-Anchor" href="#pcb"></a> PCB</h2>
<h3 id="正面"><a class="markdownIt-Anchor" href="#正面"></a> 正面</h3>
<p><img src="https://s2.loli.net/2025/08/25/VqzAU7mRGbHrf2Y.png" alt="" /></p>
<h3 id="反面"><a class="markdownIt-Anchor" href="#反面"></a> 反面</h3>
<p><img src="https://s2.loli.net/2025/08/25/mCQjkGhHI1T5eFy.png" alt="" /></p>
<p>导出Gerber文件，进入下面网站领取优惠券，打板寄回！！！</p>
<p><a href="https://www.jlc.com/newOrder/#/collectCoupons?spm=JLC.MEMBER">嘉立创-领券专区</a></p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>本次画板花了两周左右，做了块STM32的最小单元板，相较于之前画的平衡车板子复杂了许多，想die…</p>
<p><strong>原理图</strong>，是真的好画；理解，也好理解，但太容易忘了，还是得记住电源电路用的是LDO和DC-DC</p>
<p><strong>PCB</strong>，是真的折磨；画完的那一刻，能够理解实习期间旁边的硬件工程师一直在那“发癫”的原因了（一边画，一边小嘴抹了蜜）</p>
<p><a href="https://www.bilibili.com/video/BV1fFAfeZEBE?spm_id_from=333.788.videopod.episodes&amp;vd_source=2686d8279192347a7d56afcb53bb00d9&amp;p=2">【大师篇】1-产品设计流程_哔哩哔哩_bilibili</a></p>
]]></content>
      <categories>
        <category>嘉立创</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>基于ESP32S3的智能终端系统</title>
    <url>/2025/02/22/%E5%9F%BA%E4%BA%8EESP32%E7%9A%84%E6%99%BA%E8%83%BD%E7%BB%88%E7%AB%AF%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="实物"><a class="markdownIt-Anchor" href="#实物"></a> 实物</h1>
<p>LVGL界面使用<strong>Gui Guider</strong>制作，使用LVGL 8.3；图标库来自<strong>iconfont</strong></p>
<p><a href="https://www.iconfont.cn/">iconfont-阿里巴巴矢量图标库</a></p>
<h3 id="界面预览"><a class="markdownIt-Anchor" href="#界面预览"></a> 界面预览</h3>
<p><img src="https://s2.loli.net/2025/08/04/JNpOYTuUInAGg57.png" alt="" /></p>
<p>其他功能参考立创和官方例程制作，使用ESP-IDF环境。</p>
<p><strong>暂时没空，后续整理。</strong></p>
<h2 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h2>
<p><strong>ESP32S3的FreeRTOS</strong>是<strong>自带的</strong>，但是<strong>STM32的FreeRTOS是移植的</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">项目</th>
<th style="text-align:center">官方 FreeRTOS</th>
<th style="text-align:center">ESP32-S3 的 FreeRTOS（ESP-IDF）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">来源</td>
<td style="text-align:center">AWS / FreeRTOS 官方</td>
<td style="text-align:center">基于 FreeRTOS，Espressif 定制</td>
</tr>
<tr>
<td style="text-align:center">支持内核数</td>
<td style="text-align:center"><strong>通常单核</strong></td>
<td style="text-align:center"><strong>支持多核</strong>（SMP）</td>
</tr>
<tr>
<td style="text-align:center">硬件集成</td>
<td style="text-align:center"><strong>不集成硬件</strong></td>
<td style="text-align:center"><strong>集成 Wi-Fi / BLE / 外设等</strong></td>
</tr>
<tr>
<td style="text-align:center">任务调度</td>
<td style="text-align:center">单核调度器</td>
<td style="text-align:center">双核调度器（支持亲和性）</td>
</tr>
<tr>
<td style="text-align:center">功耗管理</td>
<td style="text-align:center">需手动实现</td>
<td style="text-align:center">支持 Tickless Idle，低功耗优化</td>
</tr>
<tr>
<td style="text-align:center">API 接口</td>
<td style="text-align:center">标准 FreeRTOS API</td>
<td style="text-align:center">支持标准 + Espressif 自定义 API</td>
</tr>
<tr>
<td style="text-align:center">文件系统/网络等</td>
<td style="text-align:center">无</td>
<td style="text-align:center">ESP-IDF 提供完整网络、文件系统支持</td>
</tr>
<tr>
<td style="text-align:center">配置方式</td>
<td style="text-align:center"><code>FreeRTOSConfig.h</code></td>
<td style="text-align:center"><code>menuconfig</code> 菜单配置（Kconfig）</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>项目</tag>
        <tag>ESP32</tag>
        <tag>LVGL</tag>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Bootloader的简易桌面闹钟</title>
    <url>/2025/07/27/%E5%9F%BA%E4%BA%8EBootloader%E7%9A%84%E7%AE%80%E6%98%93%E6%A1%8C%E9%9D%A2%E9%97%B9%E9%92%9F/</url>
    <content><![CDATA[<p>在这份项目里，Bootloader使用之前Bootloader学习笔记里做的样例。</p>
<p><s><strong>可以说是为了这碗醋，包了这碗饺子</strong></s></p>
<h1 id="简易桌面闹钟"><a class="markdownIt-Anchor" href="#简易桌面闹钟"></a> 简易桌面闹钟</h1>
<p>FreeRTOS移植：<a href="https://blog.csdn.net/ba_wang_mao/article/details/127628185">超详细的FreeRTOS移植全教程——基于stm32_freertos移植教程-CSDN博客</a></p>
<p><strong>时钟方面需要改用FreeRTOS的SysTick，否则系统会卡死</strong></p>
<h2 id="实物"><a class="markdownIt-Anchor" href="#实物"></a> 实物</h2>
<p><img src="https://s2.loli.net/2025/07/27/W3SZJCmjdYwkrbf.png" alt="" /></p>
<h2 id="整体结构"><a class="markdownIt-Anchor" href="#整体结构"></a> 整体结构</h2>
<p><img src="https://s2.loli.net/2025/07/27/TY6NcmgS7hrGL4b.png" alt="" /></p>
<h2 id="oled示意图"><a class="markdownIt-Anchor" href="#oled示意图"></a> OLED示意图</h2>
<p>此处OTA的值存储在AT24C02的0xF0-0XF3字节处（AT24C02总共256字节）</p>
<h3 id="简易模式"><a class="markdownIt-Anchor" href="#简易模式"></a> 简易模式</h3>
<p><img src="https://s2.loli.net/2025/07/27/mhzNLnT6D4JRYyt.png" alt="" /></p>
<ul>
<li>PA2进入多功能模式</li>
<li>PA0调整城市显示</li>
<li>PC13调整OTA状态</li>
<li>PB10可以重启设备</li>
<li><strong>支持震动自动切换多功能模式</strong></li>
</ul>
<h2 id="多功能模式"><a class="markdownIt-Anchor" href="#多功能模式"></a> 多功能模式</h2>
<p><img src="https://s2.loli.net/2025/07/27/VsqnLypYDSm1iGO.png" alt="" /></p>
<ul>
<li>
<p>PA0进入简易模式</p>
</li>
<li>
<p>温湿度数据1s刷新一次</p>
</li>
<li>
<p>加速度0.5s刷新一次</p>
</li>
<li>
<p><strong>10s无操作自动进入简易模式</strong></p>
</li>
</ul>
<h2 id="systick-svc-pendsv"><a class="markdownIt-Anchor" href="#systick-svc-pendsv"></a> SysTick、SVC、PendSV</h2>
<h4 id="systick_handler-系统时钟"><a class="markdownIt-Anchor" href="#systick_handler-系统时钟"></a> SysTick_Handler - 系统时钟</h4>
<ul>
<li>
<p>就像心跳，定期检查是否需要切换任务</p>
</li>
<li>
<p>频率固定，系统运行期间持续工作</p>
</li>
<li>
<p>负责时间管理和调度触发</p>
</li>
</ul>
<h4 id="svc_handler-系统启动器"><a class="markdownIt-Anchor" href="#svc_handler-系统启动器"></a> SVC_Handler - 系统启动器</h4>
<ul>
<li>
<p>就像点火器，只负责启动第一个任务</p>
</li>
<li>
<p>只调用一次，启动后就不工作了</p>
</li>
<li>
<p>从特权模式切换到用户模式</p>
</li>
</ul>
<h4 id="pendsv_handler-任务切换器"><a class="markdownIt-Anchor" href="#pendsv_handler-任务切换器"></a> PendSV_Handler - 任务切换器</h4>
<ul>
<li>
<p>就像交通指挥员，负责安排哪个任务先运行</p>
</li>
<li>
<p>需要切换时才工作，优先级最低</p>
</li>
<li>
<p>在用户模式下进行任务切换</p>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">特性</th>
<th style="text-align:center">SysTick_Handler</th>
<th style="text-align:center">SVC_Handler</th>
<th style="text-align:center">PendSV_Handler</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">全称</td>
<td style="text-align:center">System Tick Handler</td>
<td style="text-align:center">Supervisor Call Handler</td>
<td style="text-align:center">Pending Service Handler</td>
</tr>
<tr>
<td style="text-align:center">中文名</td>
<td style="text-align:center">系统滴答中断</td>
<td style="text-align:center">超级调用中断</td>
<td style="text-align:center">挂起服务中断</td>
</tr>
<tr>
<td style="text-align:center">触发方式</td>
<td style="text-align:center">硬件定时器</td>
<td style="text-align:center">软件调用SVC指令</td>
<td style="text-align:center">软件触发PendSV</td>
</tr>
</tbody>
</table>
<h1 id="新添内容"><a class="markdownIt-Anchor" href="#新添内容"></a> 新添内容</h1>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 从AT24C02最后一页读取OTA_flag（4字节）</span></span><br><span class="line"><span class="type">uint32_t</span> <span class="title function_">AT24C02_ReadOTAFlag</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> addr = <span class="number">0xF0</span>; <span class="comment">// 最后一页开始地址</span></span><br><span class="line">	<span class="type">uint32_t</span> flag = <span class="number">0</span>;</span><br><span class="line">	<span class="type">uint8_t</span> *pflag = (<span class="type">uint8_t</span> *)&amp;flag;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 读取4字节的OTA_flag</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="type">uint8_t</span> data = <span class="number">0</span>;</span><br><span class="line">		AT24C02_ReadData(addr + i, &amp;data, <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">if</span>(data == <span class="number">0xFF</span>) <span class="comment">// 读取失败</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 返回0表示读取失败</span></span><br><span class="line">		&#125;</span><br><span class="line">		pflag[i] = data;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Bootloader跳转逻辑控制</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Bootloader_Jump</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 读取并打印OTA_flag</span></span><br><span class="line">	<span class="type">uint32_t</span> OTA_flag = AT24C02_ReadOTAFlag();<span class="comment">//处在AT24C02的最后一页</span></span><br><span class="line">	uprintf(<span class="string">&quot;OTA_flag: %d \r\n&quot;</span>, OTA_flag);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果OTA_flag == 1，直接跳转APP</span></span><br><span class="line">	<span class="keyword">if</span>(OTA_flag == <span class="number">1</span>) &#123;</span><br><span class="line">		uprintf(<span class="string">&quot;Direct jump to APP\r\n&quot;</span>);</span><br><span class="line">		LOAD_A(FLASH_A_SADDR);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 继续原有Bootloader逻辑</span></span><br><span class="line">	<span class="keyword">if</span>(Bootloader_Enter(<span class="number">20</span>) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(OTA_flag == OTA_SET_FLAG)</span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;OTA update \r\n&quot;</span>);</span><br><span class="line">			BootState |= UPDATA_A_FLAG;</span><br><span class="line">			Updata_A.W25Q64_BlockNM = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;Jump to Area A \r\n&quot;</span>);</span><br><span class="line">			LOAD_A(FLASH_A_SADDR);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	uprintf(<span class="string">&quot;Enter Bootloader command line \r\n&quot;</span>);</span><br><span class="line">	Bootloader_Info();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="one-wire协议"><a class="markdownIt-Anchor" href="#one-wire协议"></a> one-wire协议</h2>
<p>One Wire（单线）总线协议，<strong>它只需要一根数据线就能实现双向通信</strong>，大大简化了硬件连接。</p>
<ul>
<li>
<p><strong>上拉电阻</strong>： 通常4.7kΩ，确保总线空闲时为高电平</p>
</li>
<li>
<p><strong>开漏输出</strong>： <strong>支持线与逻辑</strong></p>
</li>
</ul>
<p><a href="https://blog.csdn.net/qq_53918631/article/details/124957478">【通信协议】单总线协议详解——以DHT11为例_单总线通信协议-CSDN博客</a></p>
<h2 id="delay"><a class="markdownIt-Anchor" href="#delay"></a> delay</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uint8_t</span> fac_us = <span class="number">0</span>;  <span class="comment">// us延时倍乘数</span></span><br><span class="line"><span class="type">static</span> <span class="type">uint16_t</span> fac_ms = <span class="number">0</span>; <span class="comment">// ms延时倍乘数,在RTOS下,代表每个节拍的ms数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 时钟初始化 - 参考例程版本</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> reload;</span><br><span class="line">    SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK); <span class="comment">// 选择外部时钟  HCLK</span></span><br><span class="line">    fac_us = SystemCoreClock / <span class="number">1000000</span>;              <span class="comment">// 不论是否使用OS,fac_us都需要使用</span></span><br><span class="line">    reload = SystemCoreClock / <span class="number">1000000</span>;              <span class="comment">// 每秒钟的计数次数 单位为M</span></span><br><span class="line">    reload *= <span class="number">1000000</span> / configTICK_RATE_HZ;          <span class="comment">// 根据configTICK_RATE_HZ设定溢出时间</span></span><br><span class="line">                                                     <span class="comment">// reload为24位寄存器,最大值:16777216,在72M下,约合0.233s左右</span></span><br><span class="line">    fac_ms = <span class="number">1000</span> / configTICK_RATE_HZ;              <span class="comment">// 代表OS可以延时的最少单位</span></span><br><span class="line"></span><br><span class="line">    SysTick-&gt;CTRL |= SysTick_CTRL_TICKINT_Msk; <span class="comment">// 开启SYSTICK中断</span></span><br><span class="line">    SysTick-&gt;LOAD = reload;                    <span class="comment">// 每1/configTICK_RATE_HZ秒中断一次</span></span><br><span class="line">    SysTick-&gt;CTRL |= SysTick_CTRL_ENABLE_Msk;  <span class="comment">// 开启SYSTICK</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 延时微妙</span></span><br><span class="line"><span class="comment"> * @param us 延时0~65536微秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_us</span><span class="params">(<span class="type">uint32_t</span> us)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> ticks;</span><br><span class="line">    <span class="type">uint32_t</span> told, tnow, tcnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> reload = SysTick-&gt;LOAD; <span class="comment">// LOAD的值</span></span><br><span class="line">    ticks = us * fac_us;            <span class="comment">// 需要的节拍数</span></span><br><span class="line">    told = SysTick-&gt;VAL;            <span class="comment">// 刚进入时的计数器值</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tnow = SysTick-&gt;VAL;</span><br><span class="line">        <span class="keyword">if</span> (tnow != told)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (tnow &lt; told)</span><br><span class="line">                tcnt += told - tnow; <span class="comment">// 这里注意一下SYSTICK是一个递减的计数器就可以了.</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tcnt += reload - tnow + told;</span><br><span class="line">            told = tnow;</span><br><span class="line">            <span class="keyword">if</span> (tcnt &gt;= ticks)</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 时间超过/等于要延迟的时间,则退出.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 延时毫秒</span></span><br><span class="line"><span class="comment"> * @param ms 延时0~65536毫秒</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_ms</span><span class="params">(<span class="type">uint32_t</span> ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED) <span class="comment">// 系统已经运行</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ms &gt;= fac_ms) <span class="comment">// 延时的时间大于OS的最少时间周期</span></span><br><span class="line">        &#123;</span><br><span class="line">            vTaskDelay(ms / fac_ms); <span class="comment">// FreeRTOS延时</span></span><br><span class="line">        &#125;</span><br><span class="line">        ms %= fac_ms; <span class="comment">// OS已经无法提供这么小的延时了,采用普通方式延时</span></span><br><span class="line">    &#125;</span><br><span class="line">    Delay_us((<span class="type">uint32_t</span>)(ms * <span class="number">1000</span>)); <span class="comment">// 普通方式延时</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_s</span><span class="params">(<span class="type">uint32_t</span> s)</span></span><br><span class="line">&#123;</span><br><span class="line">    Delay_ms(s * <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 延时ms,不会引起任务调度</span></span><br><span class="line"><span class="comment"> * @param ms 要延时的ms数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Delay_xms</span><span class="params">(<span class="type">uint16_t</span> ms)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ms; i++)</span><br><span class="line">        Delay_us(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="裁剪freertos"><a class="markdownIt-Anchor" href="#裁剪freertos"></a> 裁剪FreeRTOS</h2>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> FREERTOS_CONFIG_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FREERTOS_CONFIG_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;stm32f10x.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对不同的编译器，调用不同的stdint.h文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(__ICCARM__) || defined(__CC_ARM) || defined(__GNUC__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint32_t</span> SystemCoreClock;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 断言配置 - 用于调试，当条件为假时停止程序</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configASSERT(x)           \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span> ((x) == 0)                 \</span></span><br><span class="line"><span class="meta">    &#123;                             \</span></span><br><span class="line"><span class="meta">        taskDISABLE_INTERRUPTS(); \</span></span><br><span class="line"><span class="meta">        while (1)                 \</span></span><br><span class="line"><span class="meta">            ;                     \</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************************</span></span><br><span class="line"><span class="comment"> *               FreeRTOS基础配置选项</span></span><br><span class="line"><span class="comment"> *********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 调度器类型选择</span></span><br><span class="line"><span class="comment"> * 1: 抢占式调度器 - 高优先级任务可以抢占低优先级任务</span></span><br><span class="line"><span class="comment"> * 0: 协作式调度器 - 任务必须主动释放CPU才能切换</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 抢占式：就像急诊病人可以插队，高优先级任务立即执行</span></span><br><span class="line"><span class="comment"> * 协作式：就像排队，必须等前面的人办完事才能轮到下一个</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_PREEMPTION 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 时间片调度</span></span><br><span class="line"><span class="comment"> * 1: 启用时间片 - 同优先级任务轮流执行</span></span><br><span class="line"><span class="comment"> * 0: 禁用时间片 - 同优先级任务需要主动让出CPU</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TIME_SLICING 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务选择优化</span></span><br><span class="line"><span class="comment"> * 1: 使用硬件优化 - 更快找到最高优先级任务</span></span><br><span class="line"><span class="comment"> * 0: 使用软件查找 - 兼容性更好但速度较慢</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_PORT_OPTIMISED_TASK_SELECTION 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 无滴答空闲模式</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 空闲时停止系统滴答，省电</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 始终保持系统滴答运行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TICKLESS_IDLE 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CPU时钟频率</span></span><br><span class="line"><span class="comment"> * 写入实际的CPU主频，用于计算延时时间</span></span><br><span class="line"><span class="comment"> * 例如：72MHz = 72000000</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configCPU_CLOCK_HZ (SystemCoreClock)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 系统滴答频率</span></span><br><span class="line"><span class="comment"> * 每秒中断次数，决定任务调度的精度</span></span><br><span class="line"><span class="comment"> * 1000 = 1ms一次中断，精度较高</span></span><br><span class="line"><span class="comment"> * 100 = 10ms一次中断，精度较低但省电</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTICK_RATE_HZ ((TickType_t)1000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 最大优先级数量</span></span><br><span class="line"><span class="comment"> * 优先级范围：0 ~ (configMAX_PRIORITIES-1)</span></span><br><span class="line"><span class="comment"> * 数字越小优先级越高，0为最高优先级</span></span><br><span class="line"><span class="comment"> * 建议：根据实际任务数量设置，不要设置过大</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_PRIORITIES (16)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空闲任务栈大小</span></span><br><span class="line"><span class="comment"> * 空闲任务用于系统空闲时的处理</span></span><br><span class="line"><span class="comment"> * 单位：字（4字节）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMINIMAL_STACK_SIZE ((unsigned short)64)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务名称最大长度</span></span><br><span class="line"><span class="comment"> * 用于调试时显示任务名称</span></span><br><span class="line"><span class="comment"> * 建议：8-16个字符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_TASK_NAME_LEN (12)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 滴答计数器数据类型</span></span><br><span class="line"><span class="comment"> * 1: 16位 - 最大65535个滴答（约65秒）</span></span><br><span class="line"><span class="comment"> * 0: 32位 - 最大4294967295个滴答（约49天）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_16_BIT_TICKS 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空闲任务让出CPU</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 空闲时让出CPU给同优先级任务</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 空闲任务一直运行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configIDLE_SHOULD_YIELD 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列集功能</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 可以等待多个队列</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 只能等待单个队列</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_QUEUE_SETS 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务通知功能</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 轻量级任务间通信</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 只能使用队列和信号量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TASK_NOTIFICATIONS 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 互斥量功能</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 用于保护共享资源</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 无法使用互斥量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_MUTEXES 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 递归互斥量功能</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 同一任务可以多次获取同一个互斥量</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 只能获取一次</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_RECURSIVE_MUTEXES 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 计数信号量功能</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 用于资源计数</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 无法使用计数信号量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_COUNTING_SEMAPHORES 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 事件组功能</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 用于多任务同步</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 无法使用事件组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_EVENT_GROUPS 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 队列注册表大小</span></span><br><span class="line"><span class="comment"> * 用于调试时跟踪队列和信号量</span></span><br><span class="line"><span class="comment"> * 建议：根据实际使用的队列数量设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configQUEUE_REGISTRY_SIZE 6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务标签功能</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 可以为任务设置标签</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 无法使用任务标签</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_APPLICATION_TASK_TAG 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*****************************************************************</span></span><br><span class="line"><span class="comment">              FreeRTOS内存管理配置选项</span></span><br><span class="line"><span class="comment">*****************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态内存分配</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 可以使用xTaskCreate等动态创建函数</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 只能使用静态创建函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configSUPPORT_DYNAMIC_ALLOCATION 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内存分配</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 可以使用xTaskCreateStatic等静态创建函数</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 只能使用动态创建函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configSUPPORT_STATIC_ALLOCATION 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 堆内存大小</span></span><br><span class="line"><span class="comment"> * 用于动态内存分配，包括任务栈、队列等</span></span><br><span class="line"><span class="comment"> * 单位：字节</span></span><br><span class="line"><span class="comment"> * 建议：根据实际内存使用情况设置</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTOTAL_HEAP_SIZE ((size_t)(14 * 1024))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***************************************************************</span></span><br><span class="line"><span class="comment">             FreeRTOS钩子函数配置选项</span></span><br><span class="line"><span class="comment">**************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空闲钩子函数</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 空闲时调用用户定义的函数</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 不调用钩子函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_IDLE_HOOK 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 滴答钩子函数</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 每次系统滴答时调用用户定义的函数</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 不调用钩子函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TICK_HOOK 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内存分配失败钩子函数</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 内存分配失败时调用用户定义的函数</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 不调用钩子函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_MALLOC_FAILED_HOOK 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 栈溢出检查</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 不检查栈溢出</span></span><br><span class="line"><span class="comment"> * 1: 方法1 - 检查栈顶是否被覆盖</span></span><br><span class="line"><span class="comment"> * 2: 方法2 - 检查栈底是否被覆盖（更严格）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configCHECK_FOR_STACK_OVERFLOW 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************************</span></span><br><span class="line"><span class="comment">          FreeRTOS运行时间和任务状态收集配置选项</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运行时间统计</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 可以统计任务运行时间</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 不统计运行时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configGENERATE_RUN_TIME_STATS 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可视化跟踪调试</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 支持FreeRTOS+Trace等调试工具</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 不支持跟踪调试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TRACE_FACILITY 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 统计格式化函数</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 提供格式化统计信息的函数</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 不提供格式化函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_STATS_FORMATTING_FUNCTIONS 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/********************************************************************</span></span><br><span class="line"><span class="comment">                FreeRTOS协程配置选项</span></span><br><span class="line"><span class="comment">*********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 协程功能</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 可以使用协程（轻量级任务）</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 无法使用协程</span></span><br><span class="line"><span class="comment"> * 注意：启用后必须添加croutine.c文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_CO_ROUTINES 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 协程优先级数量</span></span><br><span class="line"><span class="comment"> * 协程的优先级范围：0 ~ (configMAX_CO_ROUTINE_PRIORITIES-1)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_CO_ROUTINE_PRIORITIES (2)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/***********************************************************************</span></span><br><span class="line"><span class="comment">                FreeRTOS软件定时器配置选项</span></span><br><span class="line"><span class="comment">**********************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 软件定时器功能</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 可以使用软件定时器</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 无法使用软件定时器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configUSE_TIMERS 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 软件定时器任务优先级</span></span><br><span class="line"><span class="comment"> * 建议：设置为较高优先级，确保定时器及时处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTIMER_TASK_PRIORITY (configMAX_PRIORITIES - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 软件定时器队列长度</span></span><br><span class="line"><span class="comment"> * 用于存储定时器命令的队列大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTIMER_QUEUE_LENGTH 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 软件定时器任务栈大小</span></span><br><span class="line"><span class="comment"> * 软件定时器服务任务的栈大小</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configTIMER_TASK_STACK_DEPTH (configMINIMAL_STACK_SIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/************************************************************</span></span><br><span class="line"><span class="comment">            FreeRTOS可选函数配置选项</span></span><br><span class="line"><span class="comment">************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务调度器状态查询函数</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 可以使用xTaskGetSchedulerState()</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 无法查询调度器状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTaskGetSchedulerState 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务优先级设置函数</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 可以使用vTaskPrioritySet()</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 无法动态修改任务优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskPrioritySet 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务优先级获取函数</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 可以使用uxTaskPriorityGet()</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 无法获取任务优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_uxTaskPriorityGet 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务删除函数</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 可以使用vTaskDelete()</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 无法删除任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelete 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务清理资源函数</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 可以使用vTaskCleanUpResources()</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 无法清理任务资源</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskCleanUpResources 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务挂起函数</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 可以使用vTaskSuspend()</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 无法挂起任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskSuspend 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务延时直到指定时间函数</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 可以使用vTaskDelayUntil()</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 无法使用绝对延时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelayUntil 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务延时函数</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 可以使用vTaskDelay()</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 无法使用相对延时</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_vTaskDelay 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务状态获取函数</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 可以使用eTaskGetState()</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 无法获取任务状态</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_eTaskGetState 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定时器挂起函数调用</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 可以使用xTimerPendFunctionCall()</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 无法使用定时器挂起函数调用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_xTimerPendFunctionCall 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 任务栈高水位标记函数</span></span><br><span class="line"><span class="comment"> * 1: 启用 - 可以使用uxTaskGetStackHighWaterMark()</span></span><br><span class="line"><span class="comment"> * 0: 禁用 - 无法检查栈使用情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INCLUDE_uxTaskGetStackHighWaterMark 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/******************************************************************</span></span><br><span class="line"><span class="comment">            FreeRTOS中断配置选项</span></span><br><span class="line"><span class="comment">******************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中断优先级位数</span></span><br><span class="line"><span class="comment"> * STM32F103使用4位优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __NVIC_PRIO_BITS</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configPRIO_BITS __NVIC_PRIO_BITS</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configPRIO_BITS 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 中断最低优先级</span></span><br><span class="line"><span class="comment"> * 数值越大优先级越低</span></span><br><span class="line"><span class="comment"> * 15 = 最低优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configLIBRARY_LOWEST_INTERRUPT_PRIORITY 15</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 系统可管理的最高中断优先级</span></span><br><span class="line"><span class="comment"> * 数值越小优先级越高</span></span><br><span class="line"><span class="comment"> * 1 = 较高优先级，可以被FreeRTOS管理</span></span><br><span class="line"><span class="comment"> * 0 = 最高优先级，不能被FreeRTOS管理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 内核中断优先级</span></span><br><span class="line"><span class="comment"> * 用于FreeRTOS内核的中断优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configKERNEL_INTERRUPT_PRIORITY (configLIBRARY_LOWEST_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS)) <span class="comment">/* 240 */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 系统调用最高中断优先级</span></span><br><span class="line"><span class="comment"> * 可以被FreeRTOS管理的中断最高优先级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> configMAX_SYSCALL_INTERRUPT_PRIORITY (configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY &lt;&lt; (8 - configPRIO_BITS))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/****************************************************************</span></span><br><span class="line"><span class="comment">            FreeRTOS中断服务函数配置选项</span></span><br><span class="line"><span class="comment">****************************************************************/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PendSV中断处理函数映射</span></span><br><span class="line"><span class="comment"> * 用于任务切换的中断处理函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> xPortPendSVHandler PendSV_Handler</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SVC中断处理函数映射</span></span><br><span class="line"><span class="comment"> * 用于启动第一个任务的中断处理函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vPortSVCHandler SVC_Handler</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* FREERTOS_CONFIG_H */</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="freertos"><a class="markdownIt-Anchor" href="#freertos"></a> FreeRTOS</h2>
<p>FreeRTOS<strong>高优先级优先，具有优先级反转机制</strong>，注意<strong>config里的总优先级不能低于4</strong>。</p>
<p><strong>Ucos和RT-Thread是低优先级优先</strong></p>
<p><img src="https://s2.loli.net/2025/07/27/cAtqrPeFfKxLyVU.png" alt="" /></p>
<h3 id="通信路径表"><a class="markdownIt-Anchor" href="#通信路径表"></a> 通信路径表</h3>
<p><img src="https://s2.loli.net/2025/07/27/69KnvkIZ34uawCV.png" alt="" /></p>
<h2 id="运行效果"><a class="markdownIt-Anchor" href="#运行效果"></a> 运行效果</h2>
<p><strong>Xmodem工具使用xcom</strong>（这东西老是丢包，下载操作还有BUG，丢包了再下载进去的是错的，以后再修改吧）</p>
<p>在简易模式和多功能模式均可以调整OTA_flag；<strong>若为0，可以进行OTA更新，若为1，则自动进入系统</strong>。</p>
<p>本实验通过【5】向外部FLASH的第1块下载简易模式（MODE=0），第2块下载简易+多功能模式（MODE=1）</p>
<p>后续借助【7】重启、PB10重启和【6】下载外部FLASH等功能，对第1块和第2块外部Flash片区内容进行实验测试，均符合预期效果。</p>
<p>【1】擦除和【2】下载，测得没有问题；【3】和【4】也是测试通过。</p>
<p><img src="https://s2.loli.net/2025/07/27/fQsLjGKltcuAvBa.png" alt="" /></p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>整体代码太冗长了，这里就只把核心部分贴上去了。</p>
<p>还有，记得调整两个0x5000，不然程序是运行不了的。</p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>Bootloader</tag>
        <tag>项目</tag>
        <tag>FreeRTOS</tag>
      </tags>
  </entry>
  <entry>
    <title>基于STM32F103的智能平衡车</title>
    <url>/2024/10/22/%E5%9F%BA%E4%BA%8ESTM32%E7%9A%84%E6%99%BA%E8%83%BD%E5%B9%B3%E8%A1%A1%E8%BD%A6/</url>
    <content><![CDATA[<p>主要实现基于STM32F103C8T6的HAL库编程PID平衡车项目。</p>
<h3 id="实物"><a class="markdownIt-Anchor" href="#实物"></a> 实物</h3>
<img src="https://s2.loli.net/2025/05/07/TxMlaK1JXH9bkht.png" style="zoom: 50%;" />
<img src="https://s2.loli.net/2025/05/07/mQK57dbLgnp2hDH.png" style="zoom: 67%;" />
<h3 id="硬件部分"><a class="markdownIt-Anchor" href="#硬件部分"></a> 硬件部分</h3>
<p><img src="https://s2.loli.net/2025/08/04/szDCFNqgZtowxBf.png" alt="" /></p>
<h3 id="layout布局"><a class="markdownIt-Anchor" href="#layout布局"></a> Layout布局</h3>
<img src="https://s2.loli.net/2025/08/04/CpjHcsJ6tAzZT2L.png" style="zoom: 50%;" />
<h3 id="stm32-cubemx配置"><a class="markdownIt-Anchor" href="#stm32-cubemx配置"></a> STM32 CubeMX配置</h3>
<img src="https://s2.loli.net/2025/05/07/WnLqhDk8pCvemtO.png" style="zoom: 80%;" />
<p><strong>使用外部高速时钟8MHz，通过PLL倍频到72MHz</strong></p>
<p>RCC----&gt;HSE、LSE = Crystal/Ceramic Resonator（晶振）----&gt;HCLK = 72MHz</p>
<h3 id="oled"><a class="markdownIt-Anchor" href="#oled"></a> OLED</h3>
<p>屏的大小为0.96寸，像素点为128*64。</p>
<p>4PIN分别为GND、VCC(3.3V/5V)、SCL(IIC的时钟信号)、SDA(IIC的数据总线)。</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">IO</th>
<th style="text-align:center">HAL配置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">I2C1_SDA</td>
<td style="text-align:center">PB9</td>
<td style="text-align:center">I2C1_SCL,OD模式</td>
</tr>
<tr>
<td style="text-align:center">I2C1_SCL</td>
<td style="text-align:center">PB8</td>
<td style="text-align:center">I2C1_SDA,OD模式</td>
</tr>
</tbody>
</table>
<h4 id="iic"><a class="markdownIt-Anchor" href="#iic"></a> IIC</h4>
<p><strong>硬件IIC：上拉输入，开漏输出。</strong>(直接用STM32的真实外设)</p>
<p><strong>软件IIC：上拉输入，推挽/开漏输出。</strong>（GPIO实现时序）</p>
<p>IIC支持一主多从，同步，半双工，每个从机都有其设备地址。</p>
<p><strong>起始信号</strong>：SCL高电平，SDA从高电平跳到低电平</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IIC_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 当SCL高电平时，SDA出现一个下跳沿表示IIC总线启动信号 */</span></span><br><span class="line">    IIC_SDA_1();</span><br><span class="line">    IIC_SCL_1();</span><br><span class="line">    IIC_Delay();</span><br><span class="line">    IIC_SDA_0();</span><br><span class="line">    IIC_Delay();</span><br><span class="line">    IIC_SCL_0();</span><br><span class="line">    IIC_Delay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>停止信号</strong>：SCL高电平，SDA从低电平跳到高电平</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IIC_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/* 当SCL高电平时，SDA出现一个上跳沿表示IIC总线停止信号 */</span></span><br><span class="line">    IIC_SCL_0();</span><br><span class="line">    IIC_SDA_0();</span><br><span class="line">    IIC_SCL_1();</span><br><span class="line">    IIC_Delay();</span><br><span class="line">    IIC_SDA_1();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>ACK信号</strong>：SCL高电平，SDA为<strong>低（ACK）</strong>，SDA为<strong>高（NACK）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IIC_Ack</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IIC_SDA_0();	<span class="comment">/* CPU驱动SDA = 0 */</span></span><br><span class="line">    IIC_Delay();</span><br><span class="line">    IIC_SCL_1();	<span class="comment">/* CPU产生1个时钟 */</span></span><br><span class="line">    IIC_Delay();</span><br><span class="line">    IIC_SCL_0();</span><br><span class="line">    IIC_Delay();</span><br><span class="line">    IIC_SDA_1();	<span class="comment">/* CPU释放SDA总线 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IIC_NAck</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    IIC_SDA_1();	<span class="comment">/* CPU驱动SDA = 1 */</span></span><br><span class="line">    IIC_Delay();</span><br><span class="line">    IIC_SCL_1();	<span class="comment">/* CPU产生1个时钟 */</span></span><br><span class="line">    IIC_Delay();</span><br><span class="line">    IIC_SCL_0();</span><br><span class="line">    IIC_Delay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>发送一个Byte</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">IIC_Send_Byte</span><span class="params">(<span class="type">uint8_t</span> Byte)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Byte &amp; <span class="number">0x80</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            IIC_SDA_1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            IIC_SDA_0();</span><br><span class="line">        &#125;</span><br><span class="line">        IIC_Delay();</span><br><span class="line">        IIC_SCL_1();</span><br><span class="line">        IIC_Delay();</span><br><span class="line">        IIC_SCL_0();</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">7</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            IIC_SDA_1();</span><br><span class="line">        &#125;</span><br><span class="line">        Byte &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        IIC_Delay();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>读取一个Byte</strong>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">IIC_Read_Byte</span><span class="params">(<span class="type">uint8_t</span> ack)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> i, value;</span><br><span class="line"></span><br><span class="line">    value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        value &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">        IIC_SCL_1();</span><br><span class="line">        IIC_Delay();</span><br><span class="line">        <span class="keyword">if</span> (IIC_SDA_READ())</span><br><span class="line">        &#123;</span><br><span class="line">            value++;</span><br><span class="line">        &#125;</span><br><span class="line">        IIC_SCL_0();</span><br><span class="line">        IIC_Delay();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(ack==<span class="number">0</span>)</span><br><span class="line">        IIC_NAck();</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        IIC_Ack();</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="取模软件pctolcd"><a class="markdownIt-Anchor" href="#取模软件pctolcd"></a> 取模软件（PCtoLCD）</h4>
<p>设置：“宋体”， 16 * 16，阴码，列行式，逆向，再修改前缀。</p>
<p><img src="https://s2.loli.net/2025/05/07/p7LobrlzdxPy6wW.png" alt="" /></p>
<h3 id="mpu6050"><a class="markdownIt-Anchor" href="#mpu6050"></a> MPU6050</h3>
<p><strong>MPU6050传感器</strong>可以同时检测出<strong>三轴加速度</strong>、<strong>三轴角速度</strong>以及温度数据，<strong>内部</strong>集成<strong>DMP</strong>（Digital Motion Processor数字运动处理器）模块，可以实现<strong>滤波</strong>、融合处理。</p>
<p>绕IMU的Z轴旋转：yaw，转动y角度</p>
<p>绕IMU的Y轴旋转：pitch，转动p角度</p>
<p>绕IMU的X轴旋转：roll，转动r角度</p>
<p><strong>通过IIC通信</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">IO</th>
<th style="text-align:center">HAL配置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SDA</td>
<td style="text-align:center">PB3</td>
<td style="text-align:center">GPIO_OUTPUT</td>
</tr>
<tr>
<td style="text-align:center">SCL</td>
<td style="text-align:center">PB4</td>
<td style="text-align:center">GPIO_OUTPUT</td>
</tr>
<tr>
<td style="text-align:center">INT</td>
<td style="text-align:center">PB5</td>
<td style="text-align:center">GPIO_EXIT5</td>
</tr>
</tbody>
</table>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">float</span> pitch, roll, yaw;</span><br><span class="line"><span class="type">uint8_t</span> display_buf[<span class="number">20</span>];</span><br><span class="line">mpu_dmp_get_data(&amp;pitch, &amp;roll, &amp;yaw);</span><br><span class="line"><span class="built_in">sprintf</span>((<span class="type">char</span>*)display_buf, <span class="string">&quot;row:%.2f&quot;</span>,row);</span><br></pre></td></tr></table></figure>
<p><em><strong>TIP:MPU6050内部有上拉电阻。</strong></em></p>
<p>MPU6050模块如果在最开始没有平稳放置，自检测后会进入return语句，导致初始化失效；注释掉其自检后的return，可<strong>临时</strong>解决问题</p>
<img src="https://s2.loli.net/2025/05/09/EGamhDHOqgJVLF9.png" style="zoom: 80%;" />
<h3 id="超声波"><a class="markdownIt-Anchor" href="#超声波"></a> 超声波</h3>
<p><strong>HC-SR04 超声波测距模块</strong>可提供<code>2cm-400cm</code>的非接触式距离感测功能，精度可达到3mm，模块包括<strong>超声波发射器、接收器和控制电路</strong>。</p>
<h4 id="工作原理"><a class="markdownIt-Anchor" href="#工作原理"></a> 工作原理</h4>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">IO</th>
<th style="text-align:center">HAL配置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">TRIG（输入触发，测距）</td>
<td style="text-align:center">PA3</td>
<td style="text-align:center">GPIO_OUTPUT</td>
</tr>
<tr>
<td style="text-align:center">ECHO（传回信号、计算时间差）</td>
<td style="text-align:center">PA2</td>
<td style="text-align:center">GPIO_EXTI2(外部中断2)，TIM3计数</td>
</tr>
</tbody>
</table>
<p><em>TIP：为什么上升沿和下降沿都中断（<strong>上升时开始计时，下降时结束计时</strong>）。</em></p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>I</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi><mi>n</mi><mi>a</mi><mi>l</mi><mi mathvariant="normal">_</mi><mi>C</mi><mi>l</mi><mi>o</mi><mi>c</mi><mi>k</mi><mo>=</mo><mfrac><mrow><mi>H</mi><mi>C</mi><mi>L</mi><mi>K</mi></mrow><mrow><mi>P</mi><mi>S</mi><mi>C</mi><mo>+</mo><mn>1</mn></mrow></mfrac></mrow><annotation encoding="application/x-tex">
Internal\_Clock=\frac{HCLK}{PSC + 1}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0044em;vertical-align:-0.31em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="mord mathnormal">n</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">er</span><span class="mord mathnormal">na</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord" style="margin-right:0.02778em;">_</span><span class="mord mathnormal" style="margin-right:0.01968em;">Cl</span><span class="mord mathnormal">oc</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1297em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">PSC</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>
<p>NVIC----&gt;EXTI line2 interrupt = ENABLE</p>
<p><strong>TIM3----&gt;PSC = 71，1MHz = 1us</strong></p>
<p>使用的自动重载器ARR是16位，因此65535us=0.065535s，再乘上340m/s  / 2远远超过4m，可用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、IO口TRIG触发测距，给最少10us的高电平信呈</span></span><br><span class="line"><span class="comment">//2、模块自动发送8个40KHz的方波，自动检测信号是否返回</span></span><br><span class="line"><span class="comment">//3、有信号返回，通过IO口ECHO输出一个高电平，高电平持续的时间是超声波从发送到返回的时间</span></span><br><span class="line"><span class="comment">//测试距离 = (高电平时间 * 声速 (340m/s) / 2</span></span><br><span class="line"><span class="comment">//测量周期 &gt; 60ms，防止上一个超声波与现在的有干扰</span></span><br><span class="line"></span><br><span class="line"><span class="type">uint16_t</span> count;</span><br><span class="line"><span class="type">float</span> distance;</span><br><span class="line"><span class="keyword">extern</span> TIM_HandleTypeDef htim3;</span><br><span class="line"></span><br><span class="line"><span class="comment">//触发信号，获取距离</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Get_Dist</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_SET);			<span class="comment">//设置Trig开启</span></span><br><span class="line">	RCCdelay_us(<span class="number">12</span>);</span><br><span class="line">	HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_RESET);		<span class="comment">//设置Trig关闭</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//外部中断2和中断5函数重写，通过PIN口判断</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HAL_GPIO_EXTI_Callback</span><span class="params">(<span class="type">uint16_t</span> GPIO_Pin)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(GPIO_Pin == GPIO_PIN_5)</span><br><span class="line">	&#123;</span><br><span class="line">		Control();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span>(GPIO_Pin == GPIO_PIN_2)									<span class="comment">//此为超声波接收到信号</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_2)==GPIO_PIN_SET)	<span class="comment">//Trig开启</span></span><br><span class="line">		&#123;</span><br><span class="line">			__HAL_TIM_SetCounter(&amp;htim3, <span class="number">0</span>);					<span class="comment">//设置htim3定时器值为0</span></span><br><span class="line">			HAL_TIM_Base_Start(&amp;htim3);							<span class="comment">//开启htim3定时器</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span>													<span class="comment">//Trig关闭</span></span><br><span class="line">		&#123;</span><br><span class="line">			HAL_TIM_Base_Stop(&amp;htim3);							<span class="comment">//停止htim3定时器</span></span><br><span class="line">			count = __HAL_TIM_GetCounter(&amp;htim3);				<span class="comment">//获取其值</span></span><br><span class="line">			distance = count * <span class="number">0.017</span>;							<span class="comment">//计算距离</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//计时函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RCCdelay_us</span><span class="params">(<span class="type">uint32_t</span> udelay)</span></span><br><span class="line">&#123;</span><br><span class="line">	__IO <span class="type">uint32_t</span> Delay = udelay * <span class="number">72</span> / <span class="number">8</span>;</span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		__NOP();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span>(Delay--);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="电机驱动"><a class="markdownIt-Anchor" href="#电机驱动"></a> 电机驱动</h3>
<h4 id="tb6612电机"><a class="markdownIt-Anchor" href="#tb6612电机"></a> TB6612电机</h4>
<table>
<thead>
<tr>
<th style="text-align:center">IN1</th>
<th style="text-align:center">IN2</th>
<th style="text-align:center">直流电机的状态</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">制动</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">正转</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">反转</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">制动</td>
</tr>
</tbody>
</table>
<h4 id="pwm"><a class="markdownIt-Anchor" href="#pwm"></a> PWM</h4>
<p>全称<strong>Pulse Width Modulation</strong>(脉宽调制)；实质是在一个方波中，高电平的占比。</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">IO</th>
<th style="text-align:center">HAL配置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">PWMA</td>
<td style="text-align:center">PA11</td>
<td style="text-align:center">TIM1_CH4，Pulse = 7200</td>
</tr>
<tr>
<td style="text-align:center">AIN2</td>
<td style="text-align:center">PB12</td>
<td style="text-align:center">GPIO_OUTPUT</td>
</tr>
<tr>
<td style="text-align:center">AIN1</td>
<td style="text-align:center">PB13</td>
<td style="text-align:center">GPIO_OUTPUT</td>
</tr>
<tr>
<td style="text-align:center">BIN1</td>
<td style="text-align:center">PB14</td>
<td style="text-align:center">GPIO_OUTPUT</td>
</tr>
<tr>
<td style="text-align:center">BIN2</td>
<td style="text-align:center">PB15</td>
<td style="text-align:center">GPIO_OUTPUT</td>
</tr>
<tr>
<td style="text-align:center">PWMB</td>
<td style="text-align:center">PA8</td>
<td style="text-align:center">TIM1_CH1，Pulse = 7200</td>
</tr>
</tbody>
</table>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mspace linebreak="newline"></mspace><mi>P</mi><mi>W</mi><mi>M</mi><mtext>的频率</mtext><mi>f</mi><mo>=</mo><mfrac><mrow><mi>H</mi><mi>C</mi><mi>L</mi><mi>K</mi></mrow><mrow><mo stretchy="false">(</mo><mi>P</mi><mi>S</mi><mi>C</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">(</mo><mi>A</mi><mi>R</mi><mi>R</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></mfrac><mspace linebreak="newline"></mspace><mspace linebreak="newline"></mspace><mtext>占空比</mtext><mi>D</mi><mi>u</mi><mi>t</mi><mi>y</mi><mo>=</mo><mfrac><mrow><mi>P</mi><mi>u</mi><mi>l</mi><mi>s</mi><mi>e</mi></mrow><mrow><mi>A</mi><mi>R</mi><mi>R</mi><mo>+</mo><mn>1</mn></mrow></mfrac><mspace linebreak="newline"></mspace><mspace linebreak="newline"></mspace><mi>f</mi><mo>=</mo><mn>5</mn><mi>K</mi><mi>H</mi><mi>z</mi><mtext>，</mtext><mi>H</mi><mi>C</mi><mi>L</mi><mi>K</mi><mo>=</mo><mn>72</mn><mi>M</mi><mi>H</mi><mi>z</mi><mtext>，则</mtext><mi>P</mi><mi>S</mi><mi>C</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>A</mi><mi>R</mi><mi>R</mi><mo>=</mo><mn>7199</mn><mspace linebreak="newline"></mspace><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">
\\
PWM的频率f = \frac{HCLK}{(PSC + 1)(ARR + 1)}\\
\\
占空比Duty=\frac{Pulse}{ARR + 1}\\
\\
f=5KHz，HCLK=72MHz，则PSC=1,ARR=7199 \\
\\
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord cjk_fallback">的频率</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.2963em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3603em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07153em;">PSC</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mopen">(</span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.00773em;">RR</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace newline"></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord cjk_fallback">占空比</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">u</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1408em;vertical-align:-0.7693em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.00773em;">RR</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">1</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal">u</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">se</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.7693em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span><span class="mspace newline"></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">5</span><span class="mord mathnormal" style="margin-right:0.04398em;">KHz</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">L</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord">72</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.04398em;">Hz</span><span class="mord cjk_fallback">，则</span><span class="mord mathnormal" style="margin-right:0.07153em;">PSC</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">A</span><span class="mord mathnormal" style="margin-right:0.00773em;">RR</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">7199</span></span><span class="mspace newline"></span><span class="mspace newline"></span></span></span></span>
<h4 id="实现函数"><a class="markdownIt-Anchor" href="#实现函数"></a> 实现函数</h4>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 占空比设置</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_MAX 7200</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PWM_MIN -7200</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">Load</span><span class="params">(<span class="type">int</span> motorL, <span class="type">int</span> motorR)</span>			<span class="comment">//-7200 ---- 7200</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(motorL &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, GPIO_PIN_SET);</span><br><span class="line">		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_RESET);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, GPIO_PIN_RESET);</span><br><span class="line">		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_SET);</span><br><span class="line">	&#125;</span><br><span class="line">	__HAL_TIM_SetCompare(&amp;htim1, TIM_CHANNEL_4, <span class="built_in">abs</span>(motorL));		<span class="comment">//加载占空比</span></span><br><span class="line">	<span class="keyword">if</span>(motorR &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, GPIO_PIN_SET);</span><br><span class="line">		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_15, GPIO_PIN_RESET);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, GPIO_PIN_RESET);</span><br><span class="line">		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_15, GPIO_PIN_SET);</span><br><span class="line">	&#125;</span><br><span class="line">	__HAL_TIM_SetCompare(&amp;htim1, TIM_CHANNEL_1, <span class="built_in">abs</span>(motorL));		<span class="comment">//加载占空比</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 需要限幅，防止跑飞</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Limit</span><span class="params">(<span class="type">int</span> *Motor1, <span class="type">int</span>* Motor2)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(*Motor1 &gt; PWM_MAX) *Motor1 = PWM_MAX;</span><br><span class="line">	<span class="keyword">if</span>(*Motor1 &lt; PWM_MIN) *Motor1 = PWM_MIN;</span><br><span class="line">	<span class="keyword">if</span>(*Motor2 &gt; PWM_MAX) *Motor2 = PWM_MAX;</span><br><span class="line">	<span class="keyword">if</span>(*Motor2 &lt; PWM_MIN) *Motor2 = PWM_MIN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="编码器"><a class="markdownIt-Anchor" href="#编码器"></a> 编码器</h3>
<p>速度通过脉冲波的方式测量，旋转一圈11个脉冲；两个霍尔传感器<strong>A相、B相，可以判断旋转方向</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">IO</th>
<th style="text-align:center">HAL配置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">编码器1</td>
<td style="text-align:center">PA0、PA1</td>
<td style="text-align:center">TIM2—Encoder Mode TI1 and TI2</td>
</tr>
<tr>
<td style="text-align:center">编码器2</td>
<td style="text-align:center">PB6、PB7</td>
<td style="text-align:center">TIM4—Encoder Mode TI1 and TI2</td>
</tr>
</tbody>
</table>
<p>Encoder Mode TI1只计算A相上升沿</p>
<p>Encoder Mode TI2只计算B相上升沿</p>
<p>Encoder Mode TI1 and TI2上升沿就计算</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Read_Speed</span><span class="params">(TIM_HandleTypeDef* htim)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> tmp;</span><br><span class="line">	<span class="comment">// </span></span><br><span class="line">	tmp = (<span class="type">short</span>)__HAL_TIM_GetCounter(htim);</span><br><span class="line">	__HAL_TIM_SetCounter(htim, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 用系统自带uwTick（1s自加）每10ms读取数值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Read</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(uwTick-sys_tic&lt;<span class="number">10</span>)			</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	sys_tic=uwTick;</span><br><span class="line">	Encoder_Left = Read_Speed(&amp;htim2);					<span class="comment">//读取htim2的值</span></span><br><span class="line">	Encoder_Right = -Read_Speed(&amp;htim4);				<span class="comment">//读取htim4的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>TIP：编码器不会出现负数，16位----&gt;-32768~32767，需要用short型，正数为n，负数为32767 - n。</strong></em></p>
<h3 id="蓝牙"><a class="markdownIt-Anchor" href="#蓝牙"></a> 蓝牙</h3>
<p>使用<strong>JDY-31蓝牙模块（从机）</strong>，通过<strong>蓝牙转串口通信</strong>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">名称</th>
<th style="text-align:center">IO</th>
<th style="text-align:center">HAL配置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">RXD</td>
<td style="text-align:center">PB10</td>
<td style="text-align:center">USART3_TX</td>
</tr>
<tr>
<td style="text-align:center">TXD</td>
<td style="text-align:center">PB11</td>
<td style="text-align:center">USART3_RX</td>
</tr>
</tbody>
</table>
<p>USART3设置MODE = Asynchronous，波特率为9600Bits/s，8位，无校验位，停止位1位</p>
<p>USART3 global interrupt = ENABLE</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> rx_buf[<span class="number">2</span>];</span><br><span class="line">HAL_UART_Receive_IT(&amp;huart3, rx_buf, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// USART3中断函数，小端存储</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART3_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	HAL_UART_IRQHandler(&amp;huart3);</span><br><span class="line">	Bluetooth_data = rx_buf[<span class="number">0</span>];</span><br><span class="line">	<span class="keyword">if</span>(Bluetooth_data == <span class="number">0x00</span>) 		Fore=<span class="number">0</span>,Back=<span class="number">0</span>,Left=<span class="number">0</span>,Right=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(Bluetooth_data == <span class="number">0x01</span>) Fore=<span class="number">1</span>,Back=<span class="number">0</span>,Left=<span class="number">0</span>,Right=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(Bluetooth_data == <span class="number">0x05</span>) Fore=<span class="number">0</span>,Back=<span class="number">1</span>,Left=<span class="number">0</span>,Right=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(Bluetooth_data == <span class="number">0x03</span>) Fore=<span class="number">0</span>,Back=<span class="number">0</span>,Left=<span class="number">0</span>,Right=<span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(Bluetooth_data == <span class="number">0x07</span>) Fore=<span class="number">0</span>,Back=<span class="number">0</span>,Left=<span class="number">1</span>,Right=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">else</span>														Fore=<span class="number">0</span>,Back=<span class="number">0</span>,Left=<span class="number">0</span>,Right=<span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//HAL_UART_Transmit(&amp;huart3, rx_buf, 1, 1000);</span></span><br><span class="line">	HAL_UART_Receive_IT(&amp;huart3, rx_buf, <span class="number">1</span>);</span><br><span class="line">  <span class="comment">/* USER CODE END USART3_IRQn 1 */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="pid"><a class="markdownIt-Anchor" href="#pid"></a> PID</h3>
<h4 id="原理"><a class="markdownIt-Anchor" href="#原理"></a> 原理</h4>
<p><img src="https://s2.loli.net/2025/05/07/mRJjfuqcPXVnWY1.png" alt="" /></p>
<p>本项目使用串级PID，<strong>速度环PI+直立环PD</strong>。</p>
<img src="https://s2.loli.net/2025/05/07/ost2fcr4yH5AkqT.png" style="zoom:67%;" />
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>θ</mi><mtext>为当前小车的倾角</mtext><mspace linebreak="newline"></mspace><msup><mi>θ</mi><msup><mrow></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msup><mtext>为倾角微分，即角速度</mtext><mspace linebreak="newline"></mspace><mi>e</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mtext>是速度环中目标速度与当前速度的偏差</mtext><mspace linebreak="newline"></mspace><mo>∑</mo><mrow><mi>e</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><mtext>为偏差的积分项。</mtext><mspace linebreak="newline"></mspace><mtext>假如速度环输出为</mtext><msub><mi>θ</mi><mn>1</mn></msub><mtext>，作为目标角度输入直立环，</mtext><mspace linebreak="newline"></mspace><mtext>直立环的输出</mtext><mi>a</mi><mtext>直接作用于电机，有如下关系式。</mtext><mspace linebreak="newline"></mspace><mtext>直立环输出</mtext><mi>a</mi><mo>=</mo><mi>k</mi><mi>p</mi><mo>∗</mo><mo stretchy="false">(</mo><mi>θ</mi><mo>−</mo><msub><mi>θ</mi><mn>1</mn></msub><mo stretchy="false">)</mo><mo>+</mo><mi>k</mi><mi>d</mi><mo>∗</mo><msup><mi>θ</mi><msup><mrow></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msup><mspace linebreak="newline"></mspace><mtext>速度环输出</mtext><msub><mi>θ</mi><mn>1</mn></msub><mo>=</mo><mi>k</mi><msub><mi>p</mi><mn>1</mn></msub><mo>∗</mo><mi>e</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>+</mo><mi>k</mi><msub><mi>i</mi><mn>1</mn></msub><mo>∗</mo><mo>∑</mo><mrow><mi>e</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><mspace linebreak="newline"></mspace><mtext>因此</mtext><mi>a</mi><mo>=</mo><mi>k</mi><mi>p</mi><mo>∗</mo><mi>θ</mi><mo>+</mo><mi>k</mi><mi>d</mi><mo>∗</mo><msup><mi>θ</mi><msup><mrow></mrow><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></msup><mo>−</mo><mi>k</mi><mi>p</mi><mo>∗</mo><mo stretchy="false">[</mo><mi>k</mi><msub><mi>p</mi><mn>1</mn></msub><mo>∗</mo><mi>e</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo><mo>+</mo><mi>k</mi><msub><mi>i</mi><mn>1</mn></msub><mo>∗</mo><mo>∑</mo><mrow><mi>e</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><mo stretchy="false">]</mo><mspace linebreak="newline"></mspace></mrow><annotation encoding="application/x-tex">
\theta为当前小车的倾角 \\
\theta^{&#x27;}为倾角微分，即角速度 \\
e(k)是速度环中目标速度与当前速度的偏差 \\ 
\sum{e(k)}为偏差的积分项。\\
假如速度环输出为\theta_1，作为目标角度输入直立环，\\
直立环的输出a直接作用于电机，有如下关系式。\\
直立环输出 a= kp * (\theta - \theta_1) + kd *\theta^{&#x27;} \\
速度环输出\theta_1 = kp_1 * e(k) + ki_1 * \sum{e(k)}\\
因此a= kp * \theta + kd *\theta^{&#x27;} - kp * [kp_1 * e(k) + ki_1 * \sum{e(k)}] \\
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mord cjk_fallback">为当前小车的倾角</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.9925em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9925em;"><span style="top:-2.9925em;margin-right:0.05em;"><span class="pstrut" style="height:2.5795em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mord cjk_fallback">为倾角微分，即角速度</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mord cjk_fallback">是速度环中目标速度与当前速度的偏差</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.6em;vertical-align:-0.55em;"></span><span class="mop op-symbol large-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span><span class="mord cjk_fallback">为偏差的积分项。</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">假如速度环输出为</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord cjk_fallback">，作为目标角度输入直立环，</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">直立环的输出</span><span class="mord mathnormal">a</span><span class="mord cjk_fallback">直接作用于电机，有如下关系式。</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">直立环输出</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.9925em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9925em;"><span style="top:-2.9925em;margin-right:0.05em;"><span class="pstrut" style="height:2.5795em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">速度环输出</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0278em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.6em;vertical-align:-0.55em;"></span><span class="mop op-symbol large-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord cjk_fallback">因此</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.0833em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">d</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0758em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9925em;"><span style="top:-2.9925em;margin-right:0.05em;"><span class="pstrut" style="height:2.5795em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8278em;"><span style="top:-2.931em;margin-right:0.0714em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">p</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathnormal">p</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord"><span class="mord mathnormal">i</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.6em;vertical-align:-0.55em;"></span><span class="mop op-symbol large-op" style="position:relative;top:0em;">∑</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord"><span class="mord mathnormal">e</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span><span class="mclose">]</span></span><span class="mspace newline"></span></span></span></span>
<h4 id="调整p-i-d的效果"><a class="markdownIt-Anchor" href="#调整p-i-d的效果"></a> 调整P、I、D的效果</h4>
<p><strong>调整比例P看什么时候跌倒，主要依靠倾斜角度。</strong></p>
<p><strong>调整微分D看什么时候振荡，若KD过大，则会振荡地严重。其效果就是阻尼，越大越慢。</strong></p>
<p><strong>调整积分I看什么情况下平衡地快，其主要用于消除稳态误差，提高控制精度。</strong></p>
<h4 id="调整pid"><a class="markdownIt-Anchor" href="#调整pid"></a> 调整PID</h4>
<p>1、确定<strong>机械中值</strong>，通过它来中和计算出的theta，这个需要自己<strong>手动测量</strong>。</p>
<p>2、调参P、I、D</p>
<h5 id="直立环pd"><a class="markdownIt-Anchor" href="#直立环pd"></a> 直立环PD</h5>
<p>（输入期望角度、真实角度和角速度）</p>
<p>直立环直接调用公式。</p>
<p>首要要看下希望在什么角度让平衡车返回，以此保持平衡，计算出KP的范围（7200 / 30）；通过将KP置0后，得到此时的gyro_x，计算出KD（7200/2000）</p>
<p><strong>确定极性：向前倾斜时，轮子也向前，则为正确极性。</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">double</span> Vertical_Kp = <span class="number">-120</span>, Vertical_Kd = <span class="number">-0.6</span>;</span><br><span class="line"><span class="comment">//不滤波的原因是MPU6050滤过了。</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Vertical_PD</span><span class="params">(<span class="type">float</span> Med, <span class="type">float</span> Angle, <span class="type">float</span> gyro_y)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp = Vertical_Kp * (Angle - Med) + Vertical_Kd * gyro_y;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="速度环pi"><a class="markdownIt-Anchor" href="#速度环pi"></a> 速度环PI</h5>
<p>（输入期望速度、左编码器、右编码器）</p>
<p>1、计算偏差值：误差值 = （左+右）- 期望速度</p>
<p>2、低通滤波：误差A = (1-a)×偏差值 + a×上一次的偏差值，再更新上一次的偏差值</p>
<p>3、积分：Encoder_S += 误差A （STM32是离散的数字信号，求积分就是求和）</p>
<p>4、限幅Encoder_S</p>
<p>5、速度环套用公式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//速度环PI控制器</span></span><br><span class="line"><span class="comment">//输入：期望速度、真实速度（左编码、右编码）</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Velocity_PI</span><span class="params">(<span class="type">int</span> Target, <span class="type">int</span> Left_Encoder, <span class="type">int</span> Right_Encoder)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">//Encoder_S是偏差累加</span></span><br><span class="line">	<span class="type">static</span> <span class="type">int</span> Err_Lowout_Last, Encoder_S;</span><br><span class="line">	<span class="type">static</span> <span class="type">float</span> a = <span class="number">0.7</span>;</span><br><span class="line">	<span class="comment">//1、计算偏差值</span></span><br><span class="line">	<span class="type">int</span> Err, Err_Lowout;</span><br><span class="line">	Err = (Left_Encoder + Right_Encoder) - Target;</span><br><span class="line">	<span class="comment">//2、低通滤波</span></span><br><span class="line">	Err_Lowout = (<span class="number">1</span> - a) * Err + a * Err_Lowout_Last;</span><br><span class="line">	Err_Lowout_Last = Err_Lowout;</span><br><span class="line">	<span class="comment">//3、积分</span></span><br><span class="line">	Encoder_S += Err_Lowout;</span><br><span class="line">	<span class="comment">//4、限幅</span></span><br><span class="line">	Encoder_S = Encoder_S &gt; <span class="number">10000</span> ? <span class="number">10000</span> : (Encoder_S &lt; (<span class="number">-10000</span>) ? (<span class="number">-10000</span>) : Encoder_S);</span><br><span class="line">	<span class="keyword">if</span>(stop == <span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Encoder_S=<span class="number">0</span>;</span><br><span class="line">		stop=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//5、速度环计算</span></span><br><span class="line">	Velocity_Ki = Velocity_Kp / <span class="number">200</span>;</span><br><span class="line">	<span class="type">int</span> tmp = Velocity_Kp * Err_Lowout + Velocity_Ki * Encoder_S;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>KP通过公式换算，KI一般为KP/200；</p>
<p><strong>确定极性：向前倾斜时，轮子速度加快，则为正确极性，反之速度升不上去，则为错误极性。</strong></p>
<h5 id="转向环pd"><a class="markdownIt-Anchor" href="#转向环pd"></a> 转向环PD</h5>
<p>（用于转向操作，输入角速度、角度值）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Turn_PD</span><span class="params">(<span class="type">int</span> gyro_Z, <span class="type">int</span> Target_Turn)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> tmp = Turn_Kp * Target_Turn + Turn_Kd * gyro_Z;</span><br><span class="line">	<span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="蓝牙控制"><a class="markdownIt-Anchor" href="#蓝牙控制"></a> 蓝牙控制</h4>
<p>通过蓝牙APP发送0x01（上）、0x05（左）、0x03（右）、0x07（下）等数据分别控制方向。</p>
<h4 id="跌倒保护"><a class="markdownIt-Anchor" href="#跌倒保护"></a> 跌倒保护</h4>
<p>通过MPU6050的roll值，若其值超过设定的界限，则将PWM设为0。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Stop</span><span class="params">(<span class="type">float</span> *Med_Jiaodu,<span class="type">float</span> *Jiaodu)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="built_in">abs</span>((<span class="type">int</span>)(*Jiaodu-*Med_Jiaodu))&gt;<span class="number">60</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Load(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">		stop=<span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="物体跟随"><a class="markdownIt-Anchor" href="#物体跟随"></a> 物体跟随</h4>
<p><strong>仅实现直线跟随</strong>，方案是借助超声波传回的距离，设置在10-20mm时可以跟随，若超过，则小车保持平衡不动。</p>
<h3 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h3>
<p><em><strong>TIP1:TIM1-TIM4用完了，如何10ms调用一次呢？答：MPU6050中的INT引脚，修改其采样率为100HZ即可</strong></em></p>
<p><em><strong>TIP2:MPU6050会进行自检，若陀螺仪不在水平状态最初状态不为平衡，则不通过，导致其计算结果一直为0，注释掉</strong></em></p>
<h4 id="pid各种算法"><a class="markdownIt-Anchor" href="#pid各种算法"></a> PID各种算法</h4>
<p>1、<strong>位置式PID</strong>（本方式实际应用）</p>
<p>优点：静态误差小，溢出的影响小。</p>
<p>缺点：计算量很大，累积误差相对大，在系统出现错误的情况下，容易使系统失控，积分饱和。</p>
<p>使用：一般需要结合输出限幅和积分限幅使用。</p>
<p>2、<strong>增量式PID</strong></p>
<p>优点：溢出的影响小，在系统出现错误的情况下,影响相对较小（因为只与过去的三次误差有关）,运算量也相对较小。</p>
<p>缺点：有静态误差（因为没有累积误差）。</p>
<p>3、<strong>积分分离式PID</strong></p>
<p>积分分离式PID主要是针对<strong>位置式PID的积分</strong>，<strong>引入判断误差大小条件，是否使用积分项。</strong></p>
<p>4、<strong>变速积分PID</strong></p>
<p><strong>积分分离式</strong>PID 积分的的<strong>权重是1或者0</strong>，而<strong>变积分PID积分的权重会动态变化</strong>。取决于偏差，偏差越大，积分越慢。</p>
<p>5、不完全微分PID</p>
<p><strong>微分通过低通滤波。</strong></p>
<p>6、<strong>微分先行</strong></p>
<p>微分的作用是预测未来，能够预知变化，做出调整。其实就是<strong>先操作微分。</strong></p>
<p>7、<strong>死区</strong></p>
<p>输出了量，但是不执行任何动作，也就是输出的量不起作用。</p>
<p>8、<strong>梯形积分</strong></p>
<p><strong>积分有余差，消除不了，为了减少余差</strong>，提高运算的精度，便有了<strong>梯形积分PID</strong>。</p>
<h3 id="查漏补缺"><a class="markdownIt-Anchor" href="#查漏补缺"></a> 查漏补缺</h3>
<p>某次面试，HR问我在操作IIC时，MPU6050的地址是多少，平常操作只想着用封装库，反而忘了最基础的东西，结束后去速速学习。</p>
<p>I2C使用7 + 1的格式（12位另外讨论）</p>
<p><strong>I2C设备的写地址 = I2C设备地址 &lt;&lt; 1 + 0</strong><br />
<strong>I2C设备的读地址 = (I2C设备地址 &lt;&lt; 1) + 1</strong></p>
<p>比如MPU6050<br />
如果AD0脚(9脚)接地,设备地址为<strong>0x68</strong><br />
如果接V3.3,则设备地址为<strong>0x69</strong></p>
<p><strong>使用0x68套用式子</strong><br />
<strong>MPU6050写地址（0110 1000&lt;&lt;1 ） =1101 0000，即0xD0</strong><br />
<strong>MPU6050读地址（0110 1000&lt;&lt;1+1） =1101 0001，即0xD1</strong></p>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>STM32</tag>
        <tag>项目</tag>
        <tag>PID</tag>
      </tags>
  </entry>
  <entry>
    <title>如何做一个这样的网站</title>
    <url>/2024/01/15/%E5%A6%82%E4%BD%95%E5%81%9A%E4%B8%80%E4%B8%AA%E8%BF%99%E6%A0%B7%E7%9A%84%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h2 id="这个人太懒了根本就妹写正文呀还是来看看可爱猫猫吧"><a class="markdownIt-Anchor" href="#这个人太懒了根本就妹写正文呀还是来看看可爱猫猫吧"></a> 这个人太懒了，根本就妹写正文呀！还是来看看可爱猫猫吧！</h2>
<p><img src="https://s2.loli.net/2025/05/07/ytoMgCnpV7PU4wm.png" alt="" /></p>
<h2 id="学习参考"><a class="markdownIt-Anchor" href="#学习参考"></a> 学习参考</h2>
<ul>
<li>搭建1：<a href="https://blog.csdn.net/sinat_37781304/article/details/82729029">hexo史上最全搭建教程-CSDN博客</a></li>
<li>搭建2：<a href="https://www.jianshu.com/p/c9295bacd98b">使用Hexo在GitHub Pages上搭建部署免费的个人博客网站（下：Hexo部署）——最详细全面解读教程（没有之一） - 简书</a></li>
<li>hexo主题：<a href="https://hexo.io/themes/">Themes | Hexo</a></li>
<li>处理公式问题：<a href="https://blog.luzy.top/posts/2968289947/">Hexo折腾系列（六）数学公式渲染优化 - 江风引雨の小po站</a></li>
<li>图床工具参考1：<a href="https://sm.ms/home/">Home - SM.MS | Dashboard</a></li>
<li>图床工具参考2：<a href="https://blog.csdn.net/qq_38140292/article/details/118885686?spm=1001.2014.3001.5501">【Typora】github-与PicGO搭建图床-CSDN博客</a></li>
<li>添加音乐：<a href="https://yelog.org/2019/10/08/3-hexo-add-music/">3-hexo 添加音乐插件 | 叶落阁</a></li>
<li><strong>表格未居中问题暂未解决，CSS美化？</strong></li>
</ul>
<h2 id="关于上传hexo-d出现err-error-spawn-failed报错问题"><a class="markdownIt-Anchor" href="#关于上传hexo-d出现err-error-spawn-failed报错问题"></a> 关于上传hexo d出现err: Error: Spawn failed报错问题</h2>
<p>打开博客目录内的_config.yml配置文件，将<strong>自己的github的https仓库地址</strong>修改为<strong>自己github的SSH地址</strong></p>
<h2 id="怎么更新blog"><a class="markdownIt-Anchor" href="#怎么更新blog"></a> 怎么更新BLOG</h2>
<p>2025.7.24留，好久没用，把更新文章的命令忘完，记录一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 传上服务器</span></span><br><span class="line">hexo g -d</span><br><span class="line"><span class="comment">// 本地 localhost:4000</span></span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网页</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>蓝桥杯第十二届心得</title>
    <url>/2022/04/28/%E8%93%9D%E6%A1%A5%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%B1%8A%E5%8D%95%E7%89%87%E6%9C%BA%E5%BF%83%E5%BE%97/</url>
    <content><![CDATA[<h1 id="感悟"><a class="markdownIt-Anchor" href="#感悟"></a> 感悟</h1>
<p>今年的蓝桥杯单片机难吗，不是很难，但注重细心。一分付出，一分收获。今年我有幸参加了第十二届的比赛，但因为自己操作不当，优化代码的过程中删了定时器，没在主函数删了调用函数，导致已经完成的大厦轰然倒塌。自己也很难受，但没办法，希望看到文章的你们不要犯这种低级问题。<br />
Emmmm…，不过后来拿了省一，挺意外的。</p>
<h1 id="新手上路"><a class="markdownIt-Anchor" href="#新手上路"></a> 新手上路</h1>
<p>基础部分的内容，推荐大家去看小蜜蜂老师的视频，讲的很好，网址: <a href="https://www.xmf393.com/2019/06/11/2019061103">https://www.xmf393.com/2019/06/11/2019061103</a>.</p>
<h1 id="学习思路"><a class="markdownIt-Anchor" href="#学习思路"></a> 学习思路</h1>
<p>以下是我的学习思路<br />
首先：先学会LED、蜂鸣器、继电器、按键、数码管、数码管位选、串口等基本操作。<br />
其次：ds1302，ds18b20，eeprom(24C02)，PCF8591等。<br />
然后：PWM呼吸灯，DA(因为我刚开始一直没找到)、超声波。<br />
最关键的是一定要做省赛题！实操很重要！</p>
<p>赛题链接：<a href="https://pan.baidu.com/s/1ULZzd9nSA8l21VQQiDYvuQ">https://pan.baidu.com/s/1ULZzd9nSA8l21VQQiDYvuQ </a>.<br />
提取码：1234</p>
<h1 id="一些需要注意的点"><a class="markdownIt-Anchor" href="#一些需要注意的点"></a> 一些需要注意的点！！</h1>
<h2 id="led"><a class="markdownIt-Anchor" href="#led"></a> LED</h2>
<p>首先要说的是LED灯，比如第10届省赛题目中，如果单独点亮LED，会出现原先没有定义的灯跟着一起亮，我的解决方法如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">led</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> key1,key2,key3,key4;</span><br><span class="line">	<span class="keyword">if</span>(s4_stat == <span class="number">0</span>)										key1 = <span class="number">0x01</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(s4_stat == <span class="number">1</span>)									key1 = <span class="number">0x02</span>;</span><br><span class="line">	<span class="keyword">if</span>((dat_sz&gt;=<span class="number">0</span>&amp;&amp;dat_sz&lt;<span class="number">150</span>)||(dat_sz&gt;=<span class="number">250</span>&amp;&amp;dat_sz&lt;<span class="number">350</span>))	key2 = <span class="number">0x04</span>;</span><br><span class="line">	<span class="keyword">else</span>													key2 = <span class="number">0x00</span>;</span><br><span class="line">	<span class="keyword">if</span>(dat_f&gt;=<span class="number">0</span>&amp;&amp;dat_f&lt;<span class="number">1000</span>||dat_f&gt;=<span class="number">5000</span>&amp;&amp;dat_f&lt;<span class="number">10000</span>)		key3 = <span class="number">0x08</span>;</span><br><span class="line">	<span class="keyword">else</span>													key3 = <span class="number">0x00</span>;</span><br><span class="line">	<span class="keyword">if</span>(DA_dy == <span class="number">103</span>)										key4 = <span class="number">0x10</span>;</span><br><span class="line">	<span class="keyword">else</span>													key4 = <span class="number">0x00</span>;</span><br><span class="line">	P2 = (P2 &amp; <span class="number">0x1f</span>) | <span class="number">0x80</span>;P0 = ~(key1|key2|key3|key4);P2 = <span class="number">0x00</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="延迟delay"><a class="markdownIt-Anchor" href="#延迟delay"></a> 延迟delay</h2>
<p>本来不想单独拿出来讲的，实在是初学者这里出问题的太多了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个t是0-255</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> t)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(t--)；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个t是0-65536</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> t)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(t--)；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这个不影响数码管显示</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> t)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(t--)</span><br><span class="line">	&#123;数码管显示&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="按键消抖"><a class="markdownIt-Anchor" href="#按键消抖"></a> 按键消抖</h2>
<p>有时候题目会让你只加1，但你按了按键会出现加的好多，这里推荐一种解决方法</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(key == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	delay(<span class="number">100</span>);</span><br><span class="line">	<span class="keyword">if</span>(key == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		相关操作;</span><br><span class="line">		<span class="keyword">while</span>(key == <span class="number">0</span>)&#123;数码管操作;&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="矩阵按键"><a class="markdownIt-Anchor" href="#矩阵按键"></a> 矩阵按键</h2>
<p>我参考的B站一位UP主，写的很好，这里用的是reg52</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sbit P42 = P4^<span class="number">2</span>;</span><br><span class="line">sbit P44 = P4^<span class="number">4</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> key_value;</span><br><span class="line"><span class="type">void</span> <span class="title function_">scan_key</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	P3 = <span class="number">0x0f</span>;P42 = <span class="number">0</span>;P44 = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">if</span>(P3 != <span class="number">0x0f</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		delay(<span class="number">100</span>);</span><br><span class="line">		<span class="keyword">if</span>(P3 != <span class="number">0x0f</span>)</span><br><span class="line">		&#123;</span><br><span class="line">		<span class="keyword">switch</span>(P3)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0x0e</span>:key_value = <span class="number">0</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0x0d</span>:key_value = <span class="number">4</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0x0b</span>:key_value = <span class="number">8</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0x07</span>:key_value = <span class="number">12</span>;<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		P3 = <span class="number">0xf0</span>;P42 = <span class="number">1</span>;P44 = <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">switch</span>(P3)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0xe0</span>:key_value += <span class="number">3</span>;<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="number">0xd0</span>:key_value += <span class="number">2</span>;<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span>(P42 == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			key_value += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	<span class="comment">//	！！这里可以根据key_value的值做其他的按键操作！！</span></span><br><span class="line">		<span class="keyword">while</span>(P3 != <span class="number">0xf0</span>);</span><br><span class="line">		<span class="keyword">while</span>(P42 != <span class="number">1</span>);</span><br><span class="line">		<span class="keyword">while</span>(P44 != <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ds13b20"><a class="markdownIt-Anchor" href="#ds13b20"></a> DS13B20</h2>
<p>关于ds13b20读取温度，onewire里面的延迟都要增大10-12倍。特别注意的就是，蜜蜂老师那的temp是16位的，LSB、MSB是8位的，还有就是老师那的delay(700)是unsigned int的而不是unsigned char，要特别注意一下。两位小数的读法我建议大家去找找相关内容看看，以免考到。</p>
<h2 id="iic"><a class="markdownIt-Anchor" href="#iic"></a> IIC</h2>
<p>IIC这一块除了DA输出，其他没啥可说的，DA输出参考代码如下(只需要这样然后主函数调用就行，接着你去拿万用表测J3的D/A与GND两个位置就可以得到差不多的数值)：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">write_DA</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	IIC_Start(); </span><br><span class="line">	IIC_SendByte(<span class="number">0x90</span>);</span><br><span class="line">	IIC_WaitAck();</span><br><span class="line">	IIC_SendByte(<span class="number">0x40</span>);		<span class="comment">//0100 0000 这里的第二位置为1为DA，0为AD</span></span><br><span class="line">	IIC_WaitAck();</span><br><span class="line">	IIC_SendByte(DA_dy1);	<span class="comment">//DA_dy1的值是0-255，换算5V电压</span></span><br><span class="line">	IIC_WaitAck();			<span class="comment">//你只需要乘以500/255.0f = 1.96可到就行</span></span><br><span class="line">	IIC_Stop(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一个点就是应答和非应答。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">IIC_SendAck(x);	<span class="comment">//0的话值0-128,1的话值是0-255.</span></span><br></pre></td></tr></table></figure>
<h2 id="pwm"><a class="markdownIt-Anchor" href="#pwm"></a> PWM</h2>
<p>有些小伙伴可能学了很久都没搞懂PWM是怎么搞的，我举个例子。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> count,time,pwm_duty,led_light;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Init</span><span class="params">()</span>				<span class="comment">//定时器</span></span><br><span class="line">&#123;</span><br><span class="line">	TMOD = <span class="number">0x01</span>;</span><br><span class="line">	TH0 = (<span class="number">65536</span> - <span class="number">100</span>) / <span class="number">256</span>;</span><br><span class="line">	TL0 = (<span class="number">65536</span> - <span class="number">100</span>) % <span class="number">256</span>;</span><br><span class="line">	TR0 = <span class="number">1</span>;</span><br><span class="line">	ET0 = <span class="number">1</span>;</span><br><span class="line">	EA = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> 函数名() interrupt <span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">	TH0 = (<span class="number">65536</span> - <span class="number">100</span>) / <span class="number">256</span>;</span><br><span class="line">	TL0 = (<span class="number">65536</span> - <span class="number">100</span>) % <span class="number">256</span>;</span><br><span class="line">	count++;</span><br><span class="line">	<span class="keyword">if</span>(count &lt;= pwm_duty)</span><br><span class="line">	&#123;P2 = (P2 &amp; <span class="number">0x1f</span>) | <span class="number">0x80</span>;P0 = <span class="number">0xfe</span>;P2 = <span class="number">0x00</span>;&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(count &lt; <span class="number">10</span>)</span><br><span class="line">	&#123;P2 = (P2 &amp; <span class="number">0x1f</span>) | <span class="number">0x80</span>;P0 = <span class="number">0xff</span>;P2 = <span class="number">0x00</span>;&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;count = <span class="number">0</span>;time++;P2 = (P2 &amp; <span class="number">0x1f</span>) | <span class="number">0x80</span>;P0 = <span class="number">0xfe</span>;P2 = <span class="number">0x00</span>;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">pwm</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(time == <span class="number">5</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		time = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">if</span>(led_light == <span class="number">0</span>) <span class="comment">//0是亮、1是暗</span></span><br><span class="line">		<span class="keyword">if</span>(pwm_duty == <span class="number">10</span>)	pwm_duty = <span class="number">10</span>,led_light = <span class="number">1</span>;	<span class="keyword">else</span>	pwm_duty++;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span>(led_light == <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">if</span>(pwm_duty == <span class="number">0</span>)   pwm_duty = <span class="number">0</span>,led_light = <span class="number">0</span>;		<span class="keyword">else</span> 	pwm_duty--;	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>首先我们要的是小灯缓慢亮0.5s，缓慢灭0.5s，先定义一个100us的定时器，先经过count走了10次后，time++了，五次后也就是count加了50次(换算也就是50ms)，然后led灯会变一次pwm_duty，也就是小灯的亮度，总共要变10次，也就是0.5s，达到效果。</p>
<h2 id="io和mm模式"><a class="markdownIt-Anchor" href="#io和mm模式"></a> IO和MM模式</h2>
<p>省赛我还没看到要求用MM模式的，大多数都是要求IO模式，最好都学一下，MM模式比IO模式多用一个absacc.h的头文件。</p>
<h1 id="结尾"><a class="markdownIt-Anchor" href="#结尾"></a> 结尾</h1>
<p>希望看到这篇文章的你，不会和我刚考完一样，感觉自己的付出和回报不成正比，自己的心态很受打击。当我知道没删那个的时候，我当时人直接懵了，手机也摔地上碎屏了，自己付出了很多，和老师与陪自己一起走过来经常交流的赛友们学到了很多，但最后因为一个很小的问题导致这样，自己真的完全接受不了。不过人生总有得有失吧，唉，大家国赛加油！<br />
最后记得根据题目意思交压缩包，而不是只交了一份hex文件！！！</p>
<h1 id="最后青山不改碧水长流"><a class="markdownIt-Anchor" href="#最后青山不改碧水长流"></a> 最后，青山不改，碧水长流</h1>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>比赛</tag>
      </tags>
  </entry>
  <entry>
    <title>调试BUG与一些说明</title>
    <url>/2025/05/08/%E8%B0%83%E8%AF%95BUG%E4%B8%8E%E4%B8%80%E4%BA%9B%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<p>这里记录了调试过程中遇到的一些调试问题，往往一困就是几天，人麻了。</p>
<h1 id="调试bug"><a class="markdownIt-Anchor" href="#调试bug"></a> 调试BUG</h1>
<h2 id="stm32芯片被锁"><a class="markdownIt-Anchor" href="#stm32芯片被锁"></a> STM32芯片被锁</h2>
<p>有一段时间没用STM32芯片，发现<strong>ST-LINK读不到</strong>，毫无头绪。</p>
<p><strong>解决办法</strong>：使用软件<strong>STM32 ST-LINK Utility</strong>，<strong>点击Connect + 按住STM32上芯片复位键</strong>才能连接，连接后将程序给清除掉，成功解决。</p>
<h2 id="串口通信出现乱码"><a class="markdownIt-Anchor" href="#串口通信出现乱码"></a> 串口通信出现乱码</h2>
<p>编码格式、波特率、主频都可能是问题原因；</p>
<p><strong>如果输入英文和数字都出现问题，那大概率晶振问题，看一下是不是焊错了。</strong></p>
<h2 id="esp32的新版i2c驱动不了摄像头"><a class="markdownIt-Anchor" href="#esp32的新版i2c驱动不了摄像头"></a> ESP32的新版I2C驱动不了摄像头</h2>
<p>这个问题来自于<strong>旧I2C不支持新版摄像头驱动</strong>，一直报错，ESP IDF 5.4<strong>降低</strong>到ESP IDF 5.2即可。</p>
<p>更新过驱动，也实现了摄像头，但是配合其他外设也需要修改对应的旧版I2C（液晶屏触摸等），暂不操作。</p>
<h1 id="一些说明"><a class="markdownIt-Anchor" href="#一些说明"></a> 一些说明</h1>
<ul>
<li><code>#pragma once</code>，表示本头文件只可以包含一次，相当于 <code>#ifndef #define #endif</code></li>
</ul>
<h2 id="为什么编码器要用short来表示16位"><a class="markdownIt-Anchor" href="#为什么编码器要用short来表示16位"></a> 为什么编码器要用short来表示16位</h2>
<p>STM32平衡车项目中处理编码器的计数使用short；</p>
<p><strong>计算机存的是补码</strong>，short字节范围：-32768~ 32767，负数会变成32768 - n</p>
<p><strong>正数的原码 = 反码 = 补码</strong></p>
<p><strong>负数的反码是原码除了符号位其他位取反，补码是反码加1</strong></p>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title>颜色、图片、文字、图标设置</title>
    <url>/2025/01/10/%E9%A2%9C%E8%89%B2%E3%80%81%E5%9B%BE%E7%89%87%E3%80%81%E6%96%87%E5%AD%97%E3%80%81%E5%9B%BE%E6%A0%87%E8%AE%BE%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="颜色-图片-文字-图标"><a class="markdownIt-Anchor" href="#颜色-图片-文字-图标"></a> 颜色、图片、文字、图标</h1>
<h2 id="设置颜色"><a class="markdownIt-Anchor" href="#设置颜色"></a> 设置颜色</h2>
<ol>
<li><a href="https://vuetifyjs.com/en/styles/colors/#material-colors">Material color palette — Vuetify</a></li>
</ol>
<h2 id="设置图片"><a class="markdownIt-Anchor" href="#设置图片"></a> 设置图片</h2>
<ol>
<li>借助<strong>Image2LCD</strong>软件，按照如下图配置</li>
</ol>
<p><img src="https://s2.loli.net/2025/05/09/AV3Xr4FYEbSt1pL.png" style="zoom: 80%;" />将输出的数组存入.h中，加上static，在主函数调用。</p>
<ol start="2">
<li><a href="https://lvgl.io/tools/imageconverter">Image Converter — LVGL</a></li>
</ol>
<h2 id="设置文字"><a class="markdownIt-Anchor" href="#设置文字"></a> 设置文字</h2>
<ol>
<li>
<p><a href="https://www.zitijia.com/i/250417369808129081.html">阿里巴巴普惠体系列打包免费字体下载 - 字体打包免费下载尽在字体家</a></p>
</li>
<li>
<p><a href="https://fontconverter.com/zh/">字体转换器 – 免费在线转换字体</a></p>
</li>
<li>
<p><a href="https://lvgl.io/tools/fontconverter">Font Converter — LVGL</a></p>
</li>
</ol>
<h2 id="设置图标"><a class="markdownIt-Anchor" href="#设置图标"></a> 设置图标</h2>
<ol>
<li>
<p><a href="https://fontawesome.com/">Font Awesome</a></p>
</li>
<li>
<p><a href="https://www.iconfont.cn/">iconfont-阿里巴巴矢量图标库</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>嵌入式</category>
      </categories>
      <tags>
        <tag>学习笔记</tag>
      </tags>
  </entry>
</search>

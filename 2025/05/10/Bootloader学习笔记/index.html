<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
    
    <meta name="referrer" content="no-referrer-when-downgrade">
    
    <meta name="renderer" content="webkit"/>
    <meta name="force-rendering" content="webkit"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <script>if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode)) window.location.href="https://support.dmeng.net/upgrade-your-browser.html?referrer="+encodeURIComponent(window.location.href); </script>
    
    
        <link rel="shortcut icon" href="/icons/favicon.ico">
    
     
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="https://cdn.bootcdn.net/ajax/libs/font-awesome/5.13.1/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/vuetify@2.2.30/dist/vuetify.min.css" rel="stylesheet">
    
<link rel="stylesheet" href="/css/main.css">

    
    







    
    
          

    
    
    
    
    <title>
        
            Bootloader学习笔记 | Ben Shu &#39;s Blog
        
    </title>
    
    
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha512-fHwaWebuwA7NSF5Qg/af4UeDx9XqUpYpOGgubo3yWu+b2IQR4UeQwbb42Ti7gVAjNtVoI/I9TEoYeu9omwcC6g==" crossorigin="anonymous" referrerpolicy="no-referrer" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="app">
        <v-app>
            <v-content id="page">
                <v-container fluid>
                    <v-row>
                        <v-col cols="2" class="d-none d-md-block">
                            <div id="sidebar" class="float-right">
    <a href="/" rel="home">
        <v-avatar size=96>
            <img id="logo" src="/image/pic.jpg">     
        </v-avatar> 
    </a>
    <v-divider></v-divider>
    <div class="mini-menu">
        <v-btn icon href="/">
            <v-icon>home</v-icon>
        </v-btn>
        <v-btn icon href="/categories/">
            <v-icon>folder</v-icon>
        </v-btn>
        <v-btn icon href="/tags/">
            <v-icon>bookmark</v-icon>
        </v-btn>
        <v-btn icon @click="SetNightMode">
            <v-icon>{{ nightMode }}</v-icon>
        </v-btn>
    </div>
    <v-list id="main-menu" class="font-weight-bold" flat>
        
            
            <v-list-item href="/archives/" link>
            <v-list-item-icon><v-icon>archive</v-icon></v-list-item-icon>
            <v-list-item-content>
                Archives
            </v-list-item-content>
            </v-list-item>
        
            
            <v-list-item href="/about/" link>
            <v-list-item-icon><v-icon>account_circle</v-icon></v-list-item-icon>
            <v-list-item-content>
                About
            </v-list-item-content>
            </v-list-item>
        
    </v-list>
    <v-divider></v-divider>
    
        <div class="post-toc">
            <a href="/2025/05/10/Bootloader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" class="toc-header">Table of Contents</a>
            <div class="toc-content">
                <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#bootloaderiap"><span class="toc-number">1.</span> <span class="toc-text"> Bootloader+IAP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E8%A6%81%E8%AF%B4%E6%98%8E"><span class="toc-number">1.1.</span> <span class="toc-text"> 简要说明</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 说明</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B%E5%9B%BE"><span class="toc-number">1.2.</span> <span class="toc-text"> 整体流程图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%8C%BA"><span class="toc-number">1.3.</span> <span class="toc-text"> 分区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%A1%88"><span class="toc-number">1.4.</span> <span class="toc-text"> 方案</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A8%8B"><span class="toc-number">1.5.</span> <span class="toc-text"> 编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E4%B8%8Edma"><span class="toc-number">1.5.1.</span> <span class="toc-text"> 串口与DMA</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#h%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.1.0.1.</span> <span class="toc-text"> .h程序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E4%B8%B2%E5%8F%A3%E5%92%8Cdma"><span class="toc-number">1.5.1.1.</span> <span class="toc-text"> 配置串口和DMA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%B2%E5%8F%A3%E7%A9%BA%E9%97%B2%E4%B8%AD%E6%96%AD%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.1.2.</span> <span class="toc-text"> 串口空闲中断函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%96%E5%86%99%E6%96%B0%E7%9A%84printf%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.1.3.</span> <span class="toc-text"> 编写新的Printf函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#i2c"><span class="toc-number">1.5.2.</span> <span class="toc-text"> I2C</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#h%E7%A8%8B%E5%BA%8F-2"><span class="toc-number">1.5.2.1.</span> <span class="toc-text"> .h程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#delay"><span class="toc-number">1.5.2.2.</span> <span class="toc-text"> Delay</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96-start%E5%92%8Cstop%E4%BF%A1%E5%8F%B7"><span class="toc-number">1.5.2.3.</span> <span class="toc-text"> 初始化、START和STOP信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E9%80%81%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82"><span class="toc-number">1.5.2.4.</span> <span class="toc-text"> 发送一个字节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E4%B8%80%E4%B8%AA%E5%AD%97%E8%8A%82"><span class="toc-number">1.5.2.5.</span> <span class="toc-text"> 读取一个字节</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AD%89%E5%BE%85%E4%BB%8E%E6%9C%BAack"><span class="toc-number">1.5.2.6.</span> <span class="toc-text"> 等待从机ACK</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#at24c02"><span class="toc-number">1.5.3.</span> <span class="toc-text"> AT24C02</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%85%A5"><span class="toc-number">1.5.3.1.</span> <span class="toc-text"> 写入</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#byte-write"><span class="toc-number">1.5.3.1.1.</span> <span class="toc-text"> Byte Write</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#page-write"><span class="toc-number">1.5.3.1.2.</span> <span class="toc-text"> Page Write</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96"><span class="toc-number">1.5.3.2.</span> <span class="toc-text"> 读取</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#spi"><span class="toc-number">1.5.4.</span> <span class="toc-text"> SPI</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%94%B6%E5%8F%91"><span class="toc-number">1.5.4.1.</span> <span class="toc-text"> 数据收发</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#w25q64"><span class="toc-number">1.5.5.</span> <span class="toc-text"> W25Q64</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.5.5.1.</span> <span class="toc-text"> 状态寄存器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E8%A1%A8"><span class="toc-number">1.5.5.2.</span> <span class="toc-text"> 指令表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.5.3.</span> <span class="toc-text"> 相关程序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%A6%E9%99%A464kb"><span class="toc-number">1.5.5.4.</span> <span class="toc-text"> 擦除64KB</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%B5%E5%86%99%E5%85%A5256byte"><span class="toc-number">1.5.5.5.</span> <span class="toc-text"> 页写入256Byte</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">1.5.5.6.</span> <span class="toc-text"> 读取数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stm32%E7%9A%84flash"><span class="toc-number">1.5.6.</span> <span class="toc-text"> STM32的FLASH</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%A6%E9%99%A4flash"><span class="toc-number">1.5.6.1.</span> <span class="toc-text"> 擦除Flash</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%99%E5%85%A5flash"><span class="toc-number">1.5.6.2.</span> <span class="toc-text"> 写入Flash</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bootloader%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.6.</span> <span class="toc-text"> Bootloader功能实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ab%E5%88%86%E5%8C%BA%E8%A7%84%E5%88%92"><span class="toc-number">1.6.1.</span> <span class="toc-text"> AB分区规划</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">1.6.2.</span> <span class="toc-text"> 注意点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ota%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.6.3.</span> <span class="toc-text"> OTA宏定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ota%E8%AF%BB%E5%8F%96%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="toc-number">1.6.4.</span> <span class="toc-text"> OTA读取标志位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ota%E4%BF%9D%E5%AD%98%E5%85%B3%E9%94%AE%E5%8F%98%E9%87%8F%E5%88%B0at24c02"><span class="toc-number">1.6.5.</span> <span class="toc-text"> OTA保存关键变量到AT24C02</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E5%AF%BC%E6%9B%B4%E6%96%B0ota"><span class="toc-number">1.6.6.</span> <span class="toc-text"> 引导更新OTA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bootloader%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.6.7.</span> <span class="toc-text"> BootLoader事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BB%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.7.</span> <span class="toc-text"> 主程序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#xmodem%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.</span> <span class="toc-text"> Xmodem协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%BC%E5%BC%8F"><span class="toc-number">2.1.</span> <span class="toc-text"> 格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4"><span class="toc-number">2.2.</span> <span class="toc-text"> 指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%8B%E5%AD%90"><span class="toc-number">2.3.</span> <span class="toc-text"> 例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#crc16%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.4.</span> <span class="toc-text"> CRC16程序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">3.</span> <span class="toc-text"> 参考</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A1%A5%E5%85%85724"><span class="toc-number">4.</span> <span class="toc-text"> 补充（7.24）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bootloader%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="toc-number">4.1.</span> <span class="toc-text"> Bootloader执行流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sram%E5%9C%A8%E6%AD%A4%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">4.2.</span> <span class="toc-text"> SRAM在此的意义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#app%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE"><span class="toc-number">4.3.</span> <span class="toc-text"> APP程序配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dma%E9%85%8D%E7%BD%AErx_buffer-1%E9%85%8D%E5%90%88idle%E5%AE%9E%E7%8E%B0%E6%8E%A5%E6%94%B6%E4%B8%8D%E5%AE%9A%E9%95%BF%E6%95%B0%E6%8D%AE"><span class="toc-number">4.4.</span> <span class="toc-text"> DMA配置RX_BUFFER + 1配合IDLE实现接收不定长数据</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88dma%E4%B8%8D%E4%BD%BF%E7%94%A8%E5%BE%AA%E7%8E%AF%E6%A8%A1%E5%BC%8F%E8%80%8C%E6%98%AF%E6%99%AE%E9%80%9A%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.5.</span> <span class="toc-text"> 为什么DMA不使用循环模式，而是普通模式</span></a></li></ol></li></ol>
            </div>
        </div>
    

    <div id="footer">
        <div class="footer-social">
            
                
                <v-btn icon href="mailto:kb1000fx@gmail.com" target="_blank">
                    <v-icon>fas fa-envelope</v-icon>
                </v-btn>
            
                
                <v-btn icon href="https://github.com/kb1000fx" target="_blank">
                    <v-icon>fab fa-github</v-icon>
                </v-btn>
            
                
                <v-btn icon href="https://steamcommunity.com/profiles/76561198346798163" target="_blank">
                    <v-icon>fab fa-steam</v-icon>
                </v-btn>
            
                
                <v-btn icon href="https://weibo.com/kb1000fx" target="_blank">
                    <v-icon>fab fa-weibo</v-icon>
                </v-btn>
            
        </div>
        <v-divider></v-divider>
        <div class="footer-content">
            
                <span id="busuanzi_container_site_uv" style="display: none;"> 
                    Total Visitors <span id="busuanzi_value_site_uv"></span>
                </span>
                <br>
            
            <span>Theme: <a target="_blank" rel="noopener" href="https://github.com/kb1000fx/hexo-theme-insulin">Insulin</a></span><br>
            <span>Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a></span><br>
            <span>
                &copy; 2021 - 2025 
                Big Ben
            </span>
        </div>
    </div>
</div>

                        </v-col>
                        <v-col cols="12" md="10">
                            <v-row>
  <v-col cols="12" md="8" align-self="end">
    <div id="site-header">
      <div id="site-title">
        <a href="/" rel="home">Ben Shu &#39;s Blog</a>
      </div>
      <div id="site-description"></div>
      <div id="mobile-menu" class="d-block d-md-none">
        <v-text-field label="请输入关键字" data-src="/search.xml" v-model="searchHeaderValue" prepend-inner-icon="search" clearable clear-icon="clear" @keydown.enter="EnterSearch(searchHeaderValue,true)"></v-text-field>
        <div class="mobile-mini-menu">
          <v-btn icon href="/">
              <v-icon>home</v-icon>
          </v-btn>
          <v-btn icon href="/categories/">
              <v-icon>folder</v-icon>
          </v-btn>
          <v-btn icon href="/tags/">
              <v-icon>bookmark</v-icon>
          </v-btn>
          <v-btn icon @click="SetNightMode">
              <v-icon>{{ nightMode }}</v-icon>
          </v-btn>
          
            
            <v-btn icon href="/archives/">
              <v-icon>archive</v-icon>
            </v-btn>
          
            
            <v-btn icon href="/about/">
              <v-icon>account_circle</v-icon>
            </v-btn>
          
        </div>
      </div>    
    </div>
  </v-col>  
  <v-col cols="4" align-self="end" class="d-none d-md-block">
    <v-col align-self="end">
      <v-text-field label="请输入关键字" data-src="/search.xml" v-model="searchHeaderValue" prepend-icon="search" clearable clear-icon="clear" @keydown.enter="EnterSearch(searchHeaderValue,true)"></v-text-field>
    </v-col> 
  </v-col>
</v-row>

                            <v-card class="elevation-2 post-card">
    
    
        <div class="post-header">
  <a class="post-header-title font-weight-medium" href="/2025/05/10/Bootloader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">Bootloader学习笔记</a>
  <div class="post-header-meta">   
    <span>
      <v-icon color="">event</v-icon>
      Posted on:&nbsp;2025-05-10
    </span>
    <span>
      <v-icon color="">event_available</v-icon>
      Edited on:&nbsp;2025-07-26
    </span>
    <span>
      <v-icon color="">folder</v-icon>
      In:&nbsp;<a class="category-link" href="/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a>
    </span>
    
    <span>
      <v-icon color="">visibility</v-icon>
      Views:&nbsp;<span id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv"></span></span>
    </span>
    
  </div>
</div>

    
    
    
    
    <div class="post-content typo">
        <h1 id="bootloaderiap"><a class="markdownIt-Anchor" href="#bootloaderiap"></a> Bootloader+IAP</h1>
<h2 id="简要说明"><a class="markdownIt-Anchor" href="#简要说明"></a> 简要说明</h2>
<p>本学习笔记主要包括<strong>STM32F103C8T6</strong>下的Bootloader+IAP</p>
<p><strong>Bootloader</strong>：用于更新APP的程序</p>
<p><strong>IAP</strong>：在设备运行时，由Bootloader引导对自身程序擦写</p>
<p><strong>OTA</strong>：无线通信将新的固件下载到设备中（Over The Air）</p>
<h3 id="说明"><a class="markdownIt-Anchor" href="#说明"></a> 说明</h3>
<p><strong>使用的APP数据，OTA标志位，版本号存储在AT24C02</strong></p>
<p><strong>多个备份APP数据存储在W25Q64</strong></p>
<p>Q：已经操作了AT24C02和W25Q64，为什么还要操作单片机上的SRAM？</p>
<p>A：AT24C02和Flash读写太慢，跟不上CPU的速度，<strong>SRAM是临时、高速的数据交换区</strong>。</p>
<h2 id="整体流程图"><a class="markdownIt-Anchor" href="#整体流程图"></a> 整体流程图</h2>
<p><img src="https://s2.loli.net/2025/05/10/ADCErlteIk9JBR4.png" alt="" /></p>
<h2 id="分区"><a class="markdownIt-Anchor" href="#分区"></a> 分区</h2>
<p>A区存放APP，B区存放Bootloader程序。<strong>OTA_Flag表示是否更新APP，存放在AT24C02中</strong></p>
<ol>
<li>
<p>❌️**| A | B |**------&gt;程序运行后，先进入A区；若OTA_Flag=1开始更新数据，当正在更新的A区出现异常退出，下一次上电后运行A发现程序不全，无法再进入B区进行后续更新A区的操作，并且之前的A区程序有出现问题，<strong>悲报，成砖头了</strong>。</p>
</li>
<li>
<p>✔️**| B | A |**------&gt;程序运行后，先进入B区，观测到OTA_Flag=1后对A区进行数据更新，即使异常退出，后续仍然可以进入B区对A区进行更新，更新完成后置OTA_Flag=0。</p>
</li>
</ol>
<h2 id="方案"><a class="markdownIt-Anchor" href="#方案"></a> 方案</h2>
<p>🦝<strong>DMA + 空闲中断</strong></p>
<p>在无需CPU帮助下，<strong>DMA</strong>负责外设与寄存器之间<strong>数据传输</strong></p>
<p><strong>空闲中断</strong>（IDLE）是串口通信中<strong>判断“接收完成”的经典方式</strong></p>
<p><strong>环形缓冲区</strong>：<strong>数据传输</strong>过程中，<strong>接收速度和处理速度不一定一致</strong>，因此<strong>需要缓冲区先保存数据，防止数据丢失</strong>；一维数组，确认<strong>单次接收最大量</strong>，防止出现越界问题</p>
<p><strong>缓冲区的意义</strong>：DMA会一直等待缓冲区被填满才能完成接收；而实际通信中数据往往长度不定，因此需要配合 UART 的空闲中断来识别数据结束，提前处理接收缓冲区内容，防止数据滞留或丢失。</p>
<p><strong>SE指针对（环形缓冲）</strong>：缓冲区是一维数组，总长度为 2048 Byte，划分为10个数据块，每个数据块200 Byte。通过两个指针 IN（生产者指针）和 OUT（消费者指针）管理缓冲区的读写操作。当 IN ≠ OUT 时，表示缓冲区中存在待处理的数据包。指针每次移动一个数据块（200字节），当指针到达缓冲区末尾时自动回卷到起始位置，实现环形缓冲机制。</p>
<p><img src="https://s2.loli.net/2025/07/26/ic8CNdYyWEVsgkx.png" alt="" /></p>
<p>❗TIP：每次接收后，都<strong>需要判断剩余空间</strong>，以防内存不足，及时回卷；需要记录已经存放的<strong>累加值</strong></p>
<h2 id="编程"><a class="markdownIt-Anchor" href="#编程"></a> 编程</h2>
<p>STM32F103C8T6使用外部高速时钟HSE，8MHz；通过PLL（倍频锁相环）可以达到72MHz</p>
<h3 id="串口与dma"><a class="markdownIt-Anchor" href="#串口与dma"></a> 串口与DMA</h3>
<h5 id="h程序"><a class="markdownIt-Anchor" href="#h程序"></a> .h程序</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 缓冲区大小定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> URx_SIZE 2048           <span class="comment">// 接收缓冲区总大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UTx_SIZE 2048           <span class="comment">// 发送缓冲区大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> URx_MAX 256             <span class="comment">// 单次DMA接收最大字节数</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NUM 8                  <span class="comment">// 接收数据包队列深度</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">uint8_t</span> URx_Buff[URx_SIZE];</span><br><span class="line"><span class="type">uint8_t</span> UTx_Buff[UTx_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 某一组数据接收开始与结束， start：开始， end：结尾</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">uint8_t</span> *start;             <span class="comment">// 数据包起始地址</span></span><br><span class="line">	<span class="type">uint8_t</span> *end;               <span class="comment">// 数据包结束地址</span></span><br><span class="line">&#125;UCB_URxBuff;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 管理串口接收数据</span></span><br><span class="line"><span class="comment">   URxCounter	当前缓冲区中未处理的数据量</span></span><br><span class="line"><span class="comment">   URxDataPtr	缓冲区存储数组序号</span></span><br><span class="line"><span class="comment">   URxDataIN	指向下一组可写入数据的位置</span></span><br><span class="line"><span class="comment">   URxDataOUT	指向下一个待读取数据的位置</span></span><br><span class="line"><span class="comment">   URxDataEND	指向数组末尾	*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="type">uint16_t</span> URxCounter;        <span class="comment">// 接收计数器，记录当前接收位置</span></span><br><span class="line">	UCB_URxBuff URxDataPtr[NUM]; <span class="comment">// 数据包指针数组（环形队列）</span></span><br><span class="line">	UCB_URxBuff *URxDataIN;     <span class="comment">// 输入指针（生产者）</span></span><br><span class="line">	UCB_URxBuff *URxDataOUT;    <span class="comment">// 输出指针（消费者）</span></span><br><span class="line">	UCB_URxBuff *URxDataEND;    <span class="comment">// 队列末尾指针</span></span><br><span class="line">&#125;UCB_CB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> UCB_CB UCB;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint8_t</span> URx_Buff[URx_SIZE];</span><br></pre></td></tr></table></figure>
<h4 id="配置串口和dma"><a class="markdownIt-Anchor" href="#配置串口和dma"></a> 配置串口和DMA</h4>
<ol>
<li>设置相关<strong>外设时钟</strong></li>
<li>初始化<strong>GPIO(IO分区,MODE,频率,IO口)</strong></li>
<li>配置<strong>串口（初始化，波特率，校验，数据位长度，停止位个数，接收发情况）</strong></li>
<li>配置<strong>串口DMA</strong></li>
<li>打开<strong>串口中断（IDLE为空闲中断）</strong></li>
<li><strong>调用其他功能函数</strong></li>
<li><strong>使能串口</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">RCC_USART_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_USART1, ENABLE);</span><br><span class="line">	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);		<span class="comment">// 配置DMA</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">GPIO_USART_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;<span class="comment">// 配置PA9为TX（复用推挽输出）</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;</span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;<span class="comment">// 配置PA10为RX（浮空输入）</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">NVIC_USART_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 配置中断</span></span><br><span class="line">	NVIC_SetPriorityGrouping(NVIC_PriorityGroup_2);</span><br><span class="line">		</span><br><span class="line">	NVIC_InitTypeDef NVIC_InitStructure;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannel = USART1_IRQn;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = <span class="number">0</span>;</span><br><span class="line">	NVIC_InitStructure.NVIC_IRQChannelSubPriority = <span class="number">0</span>;</span><br><span class="line">	NVIC_Init(&amp;NVIC_InitStructure);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">DMA_USART_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	DMA_InitTypeDef DMA_InitStructure;</span><br><span class="line">    <span class="comment">//URx_Buff长度为URx_MAX，此处+1是为了配合IDLE实现中断</span></span><br><span class="line">	DMA_InitStructure.DMA_BufferSize = URx_MAX + <span class="number">1</span>;</span><br><span class="line">	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;</span><br><span class="line">	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;</span><br><span class="line">	DMA_InitStructure.DMA_MemoryBaseAddr = (<span class="type">uint32_t</span>)URx_Buff;</span><br><span class="line">	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;</span><br><span class="line">	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;</span><br><span class="line">	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;</span><br><span class="line">	DMA_InitStructure.DMA_PeripheralBaseAddr = (<span class="type">uint32_t</span>)&amp;USART1-&gt;DR;</span><br><span class="line">	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_Byte;</span><br><span class="line">	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;</span><br><span class="line">	DMA_InitStructure.DMA_Priority = DMA_Priority_High;</span><br><span class="line">	DMA_Init(DMA1_Channel5, &amp;DMA_InitStructure);</span><br><span class="line">	</span><br><span class="line">	DMA_Cmd(DMA1_Channel5, ENABLE);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// USART1初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_Init</span><span class="params">(<span class="type">uint32_t</span> band)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 使能时钟</span></span><br><span class="line">	RCC_USART_Init();</span><br><span class="line">	GPIO_USART_Init();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 配置USART1参数</span></span><br><span class="line">	USART_InitTypeDef USART_InitStructure;</span><br><span class="line">	USART_InitStructure.USART_BaudRate = band;</span><br><span class="line">	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;</span><br><span class="line">	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;</span><br><span class="line">	USART_InitStructure.USART_Parity = USART_Parity_No;</span><br><span class="line">	USART_InitStructure.USART_StopBits = USART_StopBits_1;</span><br><span class="line">	USART_InitStructure.USART_WordLength = USART_WordLength_8b;</span><br><span class="line">	USART_Init(USART1, &amp;USART_InitStructure);</span><br><span class="line">	</span><br><span class="line">	USART_DMACmd(USART1, USART_DMAReq_Rx, ENABLE);</span><br><span class="line">	USART_ITConfig(USART1, USART_IT_IDLE, ENABLE);</span><br><span class="line">	</span><br><span class="line">	NVIC_USART_Init();</span><br><span class="line">	DMA_USART_Init();</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 初始化串口控制块</span></span><br><span class="line">	UCB.URxCounter = <span class="number">0</span>;</span><br><span class="line">	UCB.URxDataIN = &amp;UCB.URxDataPtr[<span class="number">0</span>];</span><br><span class="line">	UCB.URxDataOUT = &amp;UCB.URxDataPtr[<span class="number">0</span>];</span><br><span class="line">	UCB.URxDataEND = &amp;UCB.URxDataPtr[NUM - <span class="number">1</span>];</span><br><span class="line">	UCB.URxDataIN-&gt;start = URx_Buff;</span><br><span class="line">	</span><br><span class="line">	USART_Cmd(USART1, ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="串口空闲中断函数"><a class="markdownIt-Anchor" href="#串口空闲中断函数"></a> 串口空闲中断函数</h4>
<ol>
<li><strong>检测空闲中断</strong></li>
<li><strong>消除空闲中断标志位</strong>（只有读标志位寄存器和数据位寄存器才能将空闲标志位清除）</li>
<li>在空闲中断中<strong>读取串口DMA增添数据的长度</strong>(DMA,通道) — counter += (总量 - 剩余空闲值)</li>
<li><strong>设置缓冲区的IN指针</strong></li>
<li>Disable DMA，重新配置DMA（DMA，通道，大小，地址），保证不出现完成状态，再使能DMA</li>
</ol>
<p><strong>要一直让DMA读取数据，直到出现空闲中断才会停止，因此不会出现完成状态</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief USART1中断处理函数</span></span><br><span class="line"><span class="comment"> * @param 无</span></span><br><span class="line"><span class="comment"> * @return 无</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 处理USART1的IDLE（空闲）中断：</span></span><br><span class="line"><span class="comment"> * 1. 检测到串口空闲时，表示一个数据包接收完成</span></span><br><span class="line"><span class="comment"> * 2. 计算实际接收的数据长度</span></span><br><span class="line"><span class="comment"> * 3. 更新环形缓冲区指针</span></span><br><span class="line"><span class="comment"> * 4. 重新配置DMA为下一次接收做准备</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 工作流程：</span></span><br><span class="line"><span class="comment"> * - IDLE中断触发 -&gt; 数据包接收完成</span></span><br><span class="line"><span class="comment"> * - 计算接收长度 -&gt; 更新数据包结束指针</span></span><br><span class="line"><span class="comment"> * - 移动输入指针 -&gt; 处理环形缓冲区绕回</span></span><br><span class="line"><span class="comment"> * - 重启DMA接收 -&gt; 准备接收下一个数据包</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">USART1_IRQHandler</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 检查IDLE中断标志位</span></span><br><span class="line">	<span class="keyword">if</span>(USART_GetFlagStatus(USART1, USART_FLAG_IDLE) != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 清除IDLE中断标志位</span></span><br><span class="line">		USART_ClearFlag(USART1, USART_FLAG_IDLE);</span><br><span class="line">		<span class="comment">// 读取数据寄存器以清除IDLE标志（必须操作）</span></span><br><span class="line">		USART_ReceiveData(USART1);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 计算本次接收的数据长度并更新接收计数器</span></span><br><span class="line">		UCB.URxCounter += (URx_MAX + <span class="number">1</span>) - DMA_GetCurrDataCounter(DMA1_Channel5);</span><br><span class="line">		<span class="comment">// 设置当前数据包的结束地址</span></span><br><span class="line">		UCB.URxDataIN-&gt;end = &amp;URx_Buff[UCB.URxCounter - <span class="number">1</span>];</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 移动输入指针到下一个数据包位置</span></span><br><span class="line">		UCB.URxDataIN++;</span><br><span class="line">		<span class="comment">// 检查是否到达队列末尾，进行环形处理</span></span><br><span class="line">		<span class="keyword">if</span>(UCB.URxDataIN == UCB.URxDataEND)</span><br><span class="line">		&#123;</span><br><span class="line">			UCB.URxDataIN = &amp;UCB.URxDataPtr[<span class="number">0</span>];     <span class="comment">// 回到队列开头</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 检查剩余缓冲区空间，决定下一次DMA接收的起始地址</span></span><br><span class="line">		<span class="keyword">if</span>(URx_SIZE - UCB.URxCounter &gt;= URx_MAX)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 剩余空间足够，继续在当前位置接收</span></span><br><span class="line">			UCB.URxDataIN-&gt;start = &amp;URx_Buff[UCB.URxCounter];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 剩余空间不足，回到缓冲区开头</span></span><br><span class="line">			UCB.URxDataIN-&gt;start = URx_Buff;</span><br><span class="line">			UCB.URxCounter = <span class="number">0</span>;                     <span class="comment">// 重置接收计数器</span></span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// 重新配置DMA为下一次接收</span></span><br><span class="line">		DMA_Cmd(DMA1_Channel5, DISABLE);                           <span class="comment">// 禁用DMA</span></span><br><span class="line">		DMA_SetCurrDataCounter(DMA1_Channel5, URx_MAX + <span class="number">1</span>);        <span class="comment">// 设置传输计数</span></span><br><span class="line">		DMA1_Channel5-&gt;CMAR = (<span class="type">uint32_t</span>)UCB.URxDataIN-&gt;start;      <span class="comment">// 设置内存地址</span></span><br><span class="line">		DMA_Cmd(DMA1_Channel5, ENABLE);                            <span class="comment">// 重新启用DMA</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="编写新的printf函数"><a class="markdownIt-Anchor" href="#编写新的printf函数"></a> 编写新的Printf函数</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式化打印函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uprintf</span><span class="params">(<span class="type">char</span> *format, ...)</span></span><br><span class="line">&#123;</span><br><span class="line">    va_list list_data;</span><br><span class="line">    va_start(list_data, format);</span><br><span class="line"></span><br><span class="line">    vsnprintf((<span class="type">char</span> *)UTx_Buff, <span class="keyword">sizeof</span>(UTx_Buff), format, list_data);</span><br><span class="line">    va_end(list_data);</span><br><span class="line"></span><br><span class="line">    <span class="type">uint16_t</span> len = <span class="built_in">strlen</span>((<span class="type">const</span> <span class="type">char</span> *)UTx_Buff);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint16_t</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TXE) != <span class="number">1</span>);</span><br><span class="line">        USART_SendData(USART1, UTx_Buff[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (USART_GetFlagStatus(USART1, USART_FLAG_TC) != <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="i2c"><a class="markdownIt-Anchor" href="#i2c"></a> I2C</h3>
<p><strong>软件I2C</strong>，延时部分需要自己重新设计</p>
<h4 id="h程序-2"><a class="markdownIt-Anchor" href="#h程序-2"></a> .h程序</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SCL_H GPIO_SetBits(GPIOB, GPIO_Pin_3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SCL_L GPIO_ResetBits(GPIOB, GPIO_Pin_3)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDA_H GPIO_SetBits(GPIOB, GPIO_Pin_4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SDA_L GPIO_ResetBits(GPIOB, GPIO_Pin_4)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Read_SDA GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_4)</span></span><br></pre></td></tr></table></figure>
<h4 id="delay"><a class="markdownIt-Anchor" href="#delay"></a> Delay</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 延时功能初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	SysTick_CLKSourceConfig(SysTick_CLKSource_HCLK);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 微秒级延时</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_us</span><span class="params">(<span class="type">uint16_t</span> us)</span></span><br><span class="line">&#123;</span><br><span class="line">	SysTick_Config(SystemCoreClock / <span class="number">1000000</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(us--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(!((SysTick-&gt;CTRL) &amp; (SysTick_CTRL_COUNTFLAG)));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 毫秒级延时</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delay_ms</span><span class="params">(<span class="type">uint16_t</span> ms)</span></span><br><span class="line">&#123;</span><br><span class="line">	SysTick_Config(SystemCoreClock / <span class="number">1000</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span>(ms--)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">while</span>(!((SysTick-&gt;CTRL) &amp; (SysTick_CTRL_COUNTFLAG)));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	SysTick-&gt;CTRL &amp;= ~SysTick_CTRL_ENABLE_Msk;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="初始化-start和stop信号"><a class="markdownIt-Anchor" href="#初始化-start和stop信号"></a> 初始化、START和STOP信号</h4>
<ol>
<li>
<p>硬件I2C，开启<strong>时钟</strong></p>
</li>
<li>
<p>配置<strong>GPIO</strong>（PB6，PB7，开漏模式）</p>
</li>
<li>
<p>配置<strong>SCL和SDA</strong>两条线</p>
</li>
</ol>
<p><strong>起始信号</strong>：SCL高电平，SDA从高电平变为低电平</p>
<p><strong>停止信号</strong>：SCL高电平，SDA从低电平变为高电平</p>
<p><strong>数据信号</strong>：SCL高电平，SDA保持不变；<strong>SCL低电平，SDA电平可以修改</strong></p>
<p><strong>应答信号</strong>：SCL高电平，SDA<strong>低电平</strong>，<strong>应答</strong>，否则，非应答</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C1_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 使能GPIOB时钟</span></span><br><span class="line">	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);</span><br><span class="line">	</span><br><span class="line">	GPIO_InitTypeDef GPIO_InitStructure;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 配置SCL引脚（PB3）为开漏输出</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;   <span class="comment">// 开漏输出模式</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 配置SDA引脚（PB4）为开漏输出</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;   <span class="comment">// 开漏输出模式</span></span><br><span class="line">	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;</span><br><span class="line">	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 设置总线初始状态为高电平（空闲状态）</span></span><br><span class="line">	SCL_H;</span><br><span class="line">	SDA_H;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Start信号 */</span></span><br><span class="line"><span class="comment">// 一旦 Start 产生后，数据传输必须在 SCL 为低时开始。</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Start</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	SCL_H;                              <span class="comment">// 确保SCL为高电平</span></span><br><span class="line">	SDA_H;                              <span class="comment">// 确保SDA为高电平</span></span><br><span class="line">	delay_us(<span class="number">2</span>);                        <span class="comment">// 延时等待信号稳定</span></span><br><span class="line">	SDA_L;                              <span class="comment">// SDA变为低电平（起始条件）</span></span><br><span class="line">	SCL_L;                              <span class="comment">// SCL变为低电平，准备发送数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* End信号 */</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2C_Stop</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	SCL_L;                              <span class="comment">// 确保SCL为低电平</span></span><br><span class="line">	SDA_L;                              <span class="comment">// 确保SDA为低电平</span></span><br><span class="line">	delay_us(<span class="number">2</span>);                        <span class="comment">// 延时等待信号稳定</span></span><br><span class="line">	SCL_H;                              <span class="comment">// SCL变为高电平</span></span><br><span class="line">	SDA_H;                              <span class="comment">// SDA变为高电平（停止条件）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="发送一个字节"><a class="markdownIt-Anchor" href="#发送一个字节"></a> 发送一个字节</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">I2C_SendByte</span><span class="params">(<span class="type">uint8_t</span> tx)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 从最高位开始发送（MSB first）</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int8_t</span> i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		SCL_L;                              <span class="comment">// SCL置低，准备设置数据</span></span><br><span class="line">		<span class="keyword">if</span>(tx &amp; (<span class="number">1</span> &lt;&lt; i))                   <span class="comment">// 检查当前位是否为1</span></span><br><span class="line">		&#123;</span><br><span class="line">			SDA_H;                          <span class="comment">// 发送逻辑1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			SDA_L;                          <span class="comment">// 发送逻辑0</span></span><br><span class="line">		&#125;</span><br><span class="line">		delay_us(<span class="number">2</span>);                        <span class="comment">// 延时等待数据稳定</span></span><br><span class="line">		SCL_H;                              <span class="comment">// SCL置高，让从机读取数据</span></span><br><span class="line">		delay_us(<span class="number">2</span>);                        <span class="comment">// 延时保持时钟高电平</span></span><br><span class="line">	&#125;</span><br><span class="line">	SCL_L;                                  <span class="comment">// 发送完成，SCL置低</span></span><br><span class="line">	SDA_H;                                  <span class="comment">// 释放SDA线，准备接收ACK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读取一个字节"><a class="markdownIt-Anchor" href="#读取一个字节"></a> 读取一个字节</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">I2C_ReadByte</span><span class="params">(<span class="type">uint8_t</span> ack)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> rx = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// 从最高位开始接收（MSB first）</span></span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int8_t</span> i = <span class="number">7</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">	&#123;</span><br><span class="line">		SCL_L;                              <span class="comment">// SCL置低，准备读取数据</span></span><br><span class="line">		delay_us(<span class="number">2</span>);</span><br><span class="line">		SCL_H;                              <span class="comment">// SCL置高，读取数据</span></span><br><span class="line">		<span class="keyword">if</span>(Read_SDA)                        <span class="comment">// 读取SDA上的数据</span></span><br><span class="line">		&#123;</span><br><span class="line">			rx |= (<span class="number">1</span> &lt;&lt; i);                 <span class="comment">// 如果SDA为高，设置对应位</span></span><br><span class="line">		&#125;</span><br><span class="line">		delay_us(<span class="number">2</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	SCL_L;                                  <span class="comment">// 数据接收完成，SCL置低</span></span><br><span class="line">	<span class="comment">// 发送应答或非应答</span></span><br><span class="line">	<span class="keyword">if</span>(ack)</span><br><span class="line">	&#123;</span><br><span class="line">		SDA_L;                              <span class="comment">// 发送ACK（应答）</span></span><br><span class="line">		SCL_H;</span><br><span class="line">		delay_us(<span class="number">2</span>);</span><br><span class="line">		SCL_L;</span><br><span class="line">		SDA_H;                              <span class="comment">// 释放SDA线</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		SDA_H;</span><br><span class="line">		SCL_H;</span><br><span class="line">		delay_us(<span class="number">2</span>);</span><br><span class="line">		SCL_L;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> rx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="等待从机ack"><a class="markdownIt-Anchor" href="#等待从机ack"></a> 等待从机ACK</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint8_t</span> <span class="title function_">I2C_Wait_ACK</span><span class="params">(<span class="type">int16_t</span> timeout)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 等待SDA变为低电平（从机应答）</span></span><br><span class="line">	<span class="keyword">do</span></span><br><span class="line">	&#123;</span><br><span class="line">		timeout--;</span><br><span class="line">		delay_us(<span class="number">2</span>);</span><br><span class="line">	&#125;<span class="keyword">while</span>(Read_SDA &amp;&amp; timeout &gt;= <span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(timeout &lt; <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;                           <span class="comment">// 等待超时</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	SCL_H;                                  <span class="comment">// SCL置高，读取应答信号</span></span><br><span class="line">	delay_us(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">if</span>(Read_SDA != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">2</span>;                           <span class="comment">// 应答信号无效</span></span><br><span class="line">	&#125;</span><br><span class="line">	SCL_L;                                  <span class="comment">// SCL置低，应答读取完成</span></span><br><span class="line">	delay_us(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;                               <span class="comment">// 成功接收应答</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="at24c02"><a class="markdownIt-Anchor" href="#at24c02"></a> AT24C02</h3>
<p><strong>I2C通信</strong>，设备地址：1 0 1 0  E2 E1 E0 R/非W；读R=1，0XA1；写W=0;0XA0，<strong>按字节写入</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> AT24C02_WADDR 0xA0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> AT24C02_RADDR 0xA1</span></span><br></pre></td></tr></table></figure>
<p>AT24C02共<strong>16页</strong>，<strong>一页16字节</strong>，共256字节；<strong>存在回卷问题</strong></p>
<h4 id="写入"><a class="markdownIt-Anchor" href="#写入"></a> 写入</h4>
<img src="https://s2.loli.net/2025/05/09/4LQS8qFYM3cmdbp.png" style="zoom:80%;" />
<h5 id="byte-write"><a class="markdownIt-Anchor" href="#byte-write"></a> Byte Write</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addr:写入的EEPROM内存地址</span></span><br><span class="line"><span class="comment">// wdata:写入的数据</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">AT24C02_WriteByte</span><span class="params">(<span class="type">uint8_t</span> addr, <span class="type">uint8_t</span> wdata)</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C_Start();</span><br><span class="line">    I2C_SendByte(AT24C02_WADDR); 			<span class="comment">// 发送写入信号</span></span><br><span class="line">    <span class="keyword">if</span> (I2C_Wait_ACK(<span class="number">100</span>) != <span class="number">0</span>)  			<span class="comment">// 100为等待应答的信号</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;                			<span class="comment">// 芯片无应答</span></span><br><span class="line">    </span><br><span class="line">    I2C_SendByte(addr);</span><br><span class="line">    <span class="keyword">if</span> (I2C_Wait_ACK(<span class="number">100</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>; 							<span class="comment">// 写入地址失败</span></span><br><span class="line">    </span><br><span class="line">    I2C_SendByte(wdata);</span><br><span class="line">    <span class="keyword">if</span> (I2C_Wait_ACK(<span class="number">100</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>; 							<span class="comment">// 写入数据失败</span></span><br><span class="line">    I2C_Stop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; 								<span class="comment">// 成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="page-write"><a class="markdownIt-Anchor" href="#page-write"></a> Page Write</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addr：写入地址</span></span><br><span class="line"><span class="comment">// wdata：写入数据</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">AT24C02_WritePage</span><span class="params">(<span class="type">uint8_t</span> addr, <span class="type">uint8_t</span> *wdata)</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C_Start();</span><br><span class="line">    I2C_SendByte(AT24C02_WADDR); 			<span class="comment">// 发送写入信号</span></span><br><span class="line">    <span class="keyword">if</span> (I2C_Wait_ACK(<span class="number">100</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; 							<span class="comment">// 芯片无应答</span></span><br><span class="line"></span><br><span class="line">    I2C_SendByte(addr);</span><br><span class="line">    <span class="keyword">if</span> (I2C_Wait_ACK(<span class="number">100</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>; 							<span class="comment">// 写入地址失败</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        I2C_SendByte(wdata[i]);</span><br><span class="line">        <span class="keyword">if</span> (I2C_Wait_ACK(<span class="number">100</span>) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">3</span> + i; 					<span class="comment">// 写入数据失败</span></span><br><span class="line">    &#125;</span><br><span class="line">    I2C_Stop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; 								<span class="comment">// 成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读取"><a class="markdownIt-Anchor" href="#读取"></a> 读取</h4>
<img src="https://s2.loli.net/2025/05/09/74nb8woeaplzTcr.png" style="zoom:67%;" />
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// addr：读取的起始地址</span></span><br><span class="line"><span class="comment">// rdata：指向存储读取数据的缓冲区的指针</span></span><br><span class="line"><span class="comment">// datalen:读取数据长度</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">AT24C02_ReadData</span><span class="params">(<span class="type">uint8_t</span> addr, <span class="type">uint8_t</span> *rdata, <span class="type">uint16_t</span> datalen)</span></span><br><span class="line">&#123;</span><br><span class="line">    I2C_Start();</span><br><span class="line">    I2C_SendByte(AT24C02_WADDR); 			<span class="comment">// 发送写入信号</span></span><br><span class="line">    <span class="keyword">if</span> (I2C_Wait_ACK(<span class="number">100</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; 							<span class="comment">// 芯片无应答</span></span><br><span class="line"></span><br><span class="line">    I2C_SendByte(addr); 					<span class="comment">// 写入读取地址</span></span><br><span class="line">    <span class="keyword">if</span> (I2C_Wait_ACK(<span class="number">100</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>; 							<span class="comment">// 写入读取地址失败</span></span><br><span class="line"></span><br><span class="line">    I2C_Start();</span><br><span class="line">    I2C_SendByte(AT24C02_RADDR); 			<span class="comment">// 发送读取信号</span></span><br><span class="line">    <span class="keyword">if</span> (I2C_Wait_ACK(<span class="number">100</span>) != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>; 							<span class="comment">// 切换读模式时芯片无应答</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; datalen - <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rdata[i] = I2C_ReadByte(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    rdata[datalen - <span class="number">1</span>] = I2C_ReadByte(<span class="number">0</span>); 	<span class="comment">// 读取最后一个字节时不发送ACK信号</span></span><br><span class="line">    I2C_Stop();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; 								<span class="comment">// 成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="spi"><a class="markdownIt-Anchor" href="#spi"></a> SPI</h3>
<p>外部FLASH型号为W25Q64，使用<strong>硬件SPI</strong></p>
<img src="https://s2.loli.net/2025/05/09/WoTtsqaOecy1FAw.png" style="zoom:50%;" />
<ol>
<li>
<p>配置<strong>SPI0时钟</strong>，相关<strong>GPIO开启</strong></p>
</li>
<li>
<p><strong>复位SPI外设</strong></p>
</li>
<li>
<p>配置<strong>SPI结构体成员（主从模式，发送类型（全双工），一帧大小，硬件/软件，大端/小端（大端），工作方式（极性（上下）/相位（一二），从机决定），传输速度）</strong></p>
</li>
<li>
<p><strong>初始化SPI</strong></p>
</li>
<li>
<p><strong>使能SPI</strong></p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化SPI1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI1_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使能GPIOA和SPI1时钟</span></span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_SPI1, ENABLE);</span><br><span class="line"></span><br><span class="line">    GPIO_InitTypeDef GPIO_StructInit;</span><br><span class="line">    GPIO_StructInit.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_7;	<span class="comment">// 配置SCK和MOSI引脚(PA5,PA7)</span></span><br><span class="line">    GPIO_StructInit.GPIO_Mode = GPIO_Mode_AF_PP; 		<span class="comment">// 复用推挽输出</span></span><br><span class="line">    GPIO_StructInit.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_StructInit);</span><br><span class="line"></span><br><span class="line">    GPIO_StructInit.GPIO_Pin = GPIO_Pin_6;				<span class="comment">// 配置MISO引脚(PA6)</span></span><br><span class="line">    GPIO_StructInit.GPIO_Mode = GPIO_Mode_IN_FLOATING;	<span class="comment">// 浮空输入</span></span><br><span class="line">    GPIO_StructInit.GPIO_Speed = GPIO_Speed_50MHz;</span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_StructInit);</span><br><span class="line">    </span><br><span class="line">    SPI_I2S_DeInit(SPI1);					<span class="comment">// 复位SPI1外设</span></span><br><span class="line">    </span><br><span class="line">    SPI_InitTypeDef SPI_InitStructure;		<span class="comment">// 配置SPI参数</span></span><br><span class="line">    <span class="comment">/* SPI初始化结构体配置 */</span></span><br><span class="line">    <span class="comment">// SPI工作模式：主模式（控制时钟信号）</span></span><br><span class="line">    SPI_InitStructure.SPI_Mode = SPI_Mode_Master;</span><br><span class="line">    <span class="comment">// SPI通信方向：双线全双工（同时发送和接收）</span></span><br><span class="line">    SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;</span><br><span class="line">    <span class="comment">// 数据帧格式：8位数据</span></span><br><span class="line">    SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;</span><br><span class="line">    <span class="comment">// 时钟极性：高电平空闲（CPOL=1）</span></span><br><span class="line">    SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;</span><br><span class="line">    <span class="comment">// 时钟相位：第二个边沿采样（CPHA=1）</span></span><br><span class="line">    SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;</span><br><span class="line">    <span class="comment">// 片选控制：软件NSS管理（手动控制片选）</span></span><br><span class="line">    SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;</span><br><span class="line">    <span class="comment">// 波特率预分频：系统时钟2分频（fPCLK/2）</span></span><br><span class="line">    SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;</span><br><span class="line">    <span class="comment">// 数据传输顺序：高位先发送（MSB first）</span></span><br><span class="line">    SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;</span><br><span class="line">    <span class="comment">// CRC多项式：7,大部分SPI设备用不到，随便给个值</span></span><br><span class="line">    SPI_InitStructure.SPI_CRCPolynomial = <span class="number">7</span>;</span><br><span class="line">    SPI_Init(SPI1, &amp;SPI_InitStructure);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使能SPI1</span></span><br><span class="line">    SPI_Cmd(SPI1, ENABLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="https://s2.loli.net/2025/05/09/TlW7HSEm5eXfPBD.png" style="zoom: 50%;" />
<h4 id="数据收发"><a class="markdownIt-Anchor" href="#数据收发"></a> 数据收发</h4>
<p><strong>SPI_I2S_FLAG_TXE</strong>表示<strong>发送区空了</strong>，<strong>SPI_SPI_FLAG_RXNE</strong>表示<strong>接收区不为空</strong>。切记<strong>全双工，有发就有收！</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SPI单字节读写，tx是要发送的数据字节</span></span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">SPI1_ReadWrite_Byte</span><span class="params">(<span class="type">uint16_t</span> tx)</span></span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">while</span> (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) != <span class="number">1</span>);	<span class="comment">// 等待发送缓冲区空</span></span><br><span class="line">    SPI_I2S_SendData(SPI1, tx);									<span class="comment">// 发送数据</span></span><br><span class="line">    <span class="keyword">while</span> (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) != <span class="number">1</span>);<span class="comment">// 等待接收缓冲区非空</span></span><br><span class="line">    <span class="keyword">return</span> SPI_I2S_ReceiveData(SPI1);							<span class="comment">// 返回接收到的数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多字节写入SPI，wdata要发送的数据缓冲区指针，datalen要发送的数据长度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI1_Write</span><span class="params">(<span class="type">uint8_t</span> *wdata, <span class="type">uint16_t</span> datalen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; datalen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        SPI1_ReadWrite_Byte(wdata[i]); 			<span class="comment">// 只发送数据，忽略接收内容</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 多字节读取SPI，rdata接收数据缓冲区指针，datalen要读取的数据长度</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SPI1_Read</span><span class="params">(<span class="type">uint8_t</span> *rdata, <span class="type">uint16_t</span> datalen)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; datalen; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rdata[i] = SPI1_ReadWrite_Byte(<span class="number">0xff</span>); <span class="comment">// 发送dummy数据(0xFF)来读取，想想Flash清零</span></span><br><span class="line">    &#125;							</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="w25q64"><a class="markdownIt-Anchor" href="#w25q64"></a> W25Q64</h3>
<h4 id="状态寄存器"><a class="markdownIt-Anchor" href="#状态寄存器"></a> <strong>状态寄存器</strong></h4>
<p>主要看<strong>S0 — BUSY</strong></p>
<img src="https://s2.loli.net/2025/05/09/KWenVOwYPLpoXaz.png" style="zoom:67%;" />
<h4 id="指令表"><a class="markdownIt-Anchor" href="#指令表"></a> <strong>指令表</strong></h4>
<img src="https://s2.loli.net/2025/05/09/piZ37vGDV6htqL8.png" style="zoom: 80%;" />
<h4 id="相关程序"><a class="markdownIt-Anchor" href="#相关程序"></a> <strong>相关程序</strong></h4>
<p>SPI+Flash需等待<strong>Busy状态</strong>，先读取状态寄存器地址，后随便写入其它（此时写入什么都不重要，主要获取寄存器中的数值），<strong>打开片选，使能Write再关闭</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CS_ENABLE GPIO_ResetBits(GPIOA, GPIO_Pin_4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CS_DISABLE GPIO_SetBits(GPIOA, GPIO_Pin_4)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// W25Q64初始化</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);</span><br><span class="line">    GPIO_InitTypeDef GPIO_StructInit;</span><br><span class="line">    GPIO_StructInit.GPIO_Pin = GPIO_Pin_4;         	<span class="comment">// CS片选引脚（低电平有效）</span></span><br><span class="line">    GPIO_StructInit.GPIO_Mode = GPIO_Mode_Out_PP;  	<span class="comment">// 推挽输出模式</span></span><br><span class="line">    GPIO_StructInit.GPIO_Speed = GPIO_Speed_50MHz; 	<span class="comment">// 50MHz速度</span></span><br><span class="line">    GPIO_Init(GPIOA, &amp;GPIO_StructInit);</span><br><span class="line">    CS_DISABLE;  									<span class="comment">// 默认禁用片选</span></span><br><span class="line">    SPI1_Init(); 									<span class="comment">// 初始化SPI1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 等待芯片空闲</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_WaitBusy</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> res;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        CS_ENABLE;                       			<span class="comment">// 使能片选</span></span><br><span class="line">        SPI1_ReadWrite_Byte(<span class="number">0x05</span>);       			<span class="comment">// 发送读取状态寄存器命令</span></span><br><span class="line">        res = SPI1_ReadWrite_Byte(<span class="number">0xff</span>); 			<span class="comment">// 读取状态寄存器值</span></span><br><span class="line">        CS_DISABLE;                      			<span class="comment">// 禁用片选</span></span><br><span class="line">    &#125; <span class="keyword">while</span> ((res &amp; <span class="number">0x01</span>) == <span class="number">0x01</span>); 				<span class="comment">// 检查BUSY位（bit0）</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使能写操作</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Enable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    W25Q64_WaitBusy(); 								<span class="comment">// 等待空闲</span></span><br><span class="line">    CS_ENABLE;</span><br><span class="line">    SPI1_ReadWrite_Byte(<span class="number">0x06</span>); 						<span class="comment">// 发送写使能指令</span></span><br><span class="line">    CS_DISABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="擦除64kb"><a class="markdownIt-Anchor" href="#擦除64kb"></a> 擦除64KB</h4>
<p>W25Q64总共<strong>8MB</strong> = 8 * 1024KB，<strong>一次擦除64KB</strong>，可得共计8 * 1024 / 64 = <strong>128个Block</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 擦除64KB的块，block: 要擦除的块编号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Erase_64k</span><span class="params">(<span class="type">uint8_t</span> block)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> wdata[<span class="number">4</span>];</span><br><span class="line">    wdata[<span class="number">0</span>] = <span class="number">0xD8</span>;                      		<span class="comment">// 块擦除指令</span></span><br><span class="line">    wdata[<span class="number">1</span>] = (block * <span class="number">64</span> * <span class="number">1024</span>) &gt;&gt; <span class="number">16</span>; 		<span class="comment">// 计算块起始地址（高字节）</span></span><br><span class="line">    wdata[<span class="number">2</span>] = (block * <span class="number">64</span> * <span class="number">1024</span>) &gt;&gt; <span class="number">8</span>;  		<span class="comment">// 中字节</span></span><br><span class="line">    wdata[<span class="number">3</span>] = (block * <span class="number">64</span> * <span class="number">1024</span>) &gt;&gt; <span class="number">0</span>;  		<span class="comment">// 低字节</span></span><br><span class="line">    W25Q64_WaitBusy();							<span class="comment">// 等待BUSY</span></span><br><span class="line">    W25Q64_Enable(); 							<span class="comment">// 使能写操作</span></span><br><span class="line">    CS_ENABLE;</span><br><span class="line">    SPI1_Write(wdata, <span class="number">4</span>); 						<span class="comment">// 发送擦除指令和地址</span></span><br><span class="line">    CS_DISABLE;</span><br><span class="line">    W25Q64_WaitBusy(); 							<span class="comment">// 等待擦除完成</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="页写入256byte"><a class="markdownIt-Anchor" href="#页写入256byte"></a> 页写入256Byte</h4>
<p><strong>页地址 = page * 256 Byte，每次从页地址开始写入256 Byte，页地址总长24位</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按页写入数据</span></span><br><span class="line"><span class="comment">// wbuff: 待写入数据的缓冲区指针</span></span><br><span class="line"><span class="comment">// page: 目标页号</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_PageWrite</span><span class="params">(<span class="type">uint8_t</span> *wbuff, <span class="type">uint16_t</span> page)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint8_t</span> wdata[<span class="number">4</span>];</span><br><span class="line">    wdata[<span class="number">0</span>] = <span class="number">0x02</span>;               				<span class="comment">// 页写指令</span></span><br><span class="line">    wdata[<span class="number">1</span>] = (page * <span class="number">256</span>) &gt;&gt; <span class="number">16</span>; 				<span class="comment">// 计算页起始地址（高字节）</span></span><br><span class="line">    wdata[<span class="number">2</span>] = (page * <span class="number">256</span>) &gt;&gt; <span class="number">8</span>;  				<span class="comment">// 中字节</span></span><br><span class="line">    wdata[<span class="number">3</span>] = (page * <span class="number">256</span>) &gt;&gt; <span class="number">0</span>;  				<span class="comment">// 低字节</span></span><br><span class="line">    W25Q64_WaitBusy();</span><br><span class="line">    W25Q64_Enable(); 							<span class="comment">// 使能写操作</span></span><br><span class="line">    CS_ENABLE;</span><br><span class="line">    SPI1_Write(wdata, <span class="number">4</span>);   					<span class="comment">// 发送写指令和地址</span></span><br><span class="line">    SPI1_Write(wbuff, <span class="number">256</span>); 					<span class="comment">// 写入256字节数据</span></span><br><span class="line">    CS_DISABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="读取数据"><a class="markdownIt-Anchor" href="#读取数据"></a> 读取数据</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line"><span class="comment">// rbuff: 数据读取缓冲区指针</span></span><br><span class="line"><span class="comment">// addr: 起始地址</span></span><br><span class="line"><span class="comment">// datalen: 要读取的字节数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">W25Q64_Read</span><span class="params">(<span class="type">uint8_t</span> *rbuff, <span class="type">uint32_t</span> addr, <span class="type">uint32_t</span> datalen)</span> <span class="comment">// 地址只用24位</span></span><br><span class="line">&#123;</span><br><span class="line">    W25Q64_WaitBusy();</span><br><span class="line">    CS_ENABLE;</span><br><span class="line">    SPI1_ReadWrite_Byte(<span class="number">0x03</span>);</span><br><span class="line">    SPI1_ReadWrite_Byte((<span class="type">uint16_t</span>)(addr &gt;&gt; <span class="number">16</span>));</span><br><span class="line">    SPI1_ReadWrite_Byte((<span class="type">uint16_t</span>)(addr &gt;&gt; <span class="number">8</span>));</span><br><span class="line">    SPI1_ReadWrite_Byte((<span class="type">uint16_t</span>)(addr &gt;&gt; <span class="number">0</span>));</span><br><span class="line">    SPI1_Read(rbuff, datalen);</span><br><span class="line">    CS_DISABLE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="stm32的flash"><a class="markdownIt-Anchor" href="#stm32的flash"></a> STM32的FLASH</h3>
<p>Flash<strong>擦除后为0xFF</strong></p>
<h4 id="擦除flash"><a class="markdownIt-Anchor" href="#擦除flash"></a> 擦除Flash</h4>
<p>Flash<strong>一页1KB</strong>，下面函数实现<strong>一次擦除num页</strong>数据</p>
<p><strong>流程</strong>：</p>
<ol>
<li>
<p>Flash开锁</p>
</li>
<li>
<p><strong>确认地址，擦除地址数据</strong></p>
</li>
<li>
<p>Flash锁定</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start	起始页号</span></span><br><span class="line"><span class="comment">// num		需要擦除的页数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_Erase</span><span class="params">(<span class="type">uint16_t</span> start, <span class="type">uint16_t</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint16_t</span> i;</span><br><span class="line">    FLASH_Unlock(); 					<span class="comment">// 解锁FLASH操作</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 计算目标页地址：FLASH起始地址 + 起始页号 * 页大小 + 当前页偏移</span></span><br><span class="line">        FLASH_ErasePage((FLASH_SADDR + start * <span class="number">1024</span>) + (<span class="number">1024</span> * i));</span><br><span class="line">    &#125;</span><br><span class="line">    FLASH_Lock(); 						<span class="comment">// 锁定FLASH</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="写入flash"><a class="markdownIt-Anchor" href="#写入flash"></a> 写入Flash</h4>
<p>一次写入<strong>num个4字节数据</strong>，地址自动递增</p>
<p><strong>流程</strong>：</p>
<ol>
<li>
<p>Flash开锁</p>
</li>
<li>
<p><strong>将数据写入对应地址</strong></p>
</li>
<li>
<p>Flash锁定</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//	saddr	目标起始地址（必须为4的倍数）</span></span><br><span class="line"><span class="comment">//	wdata	待写入数据的指针</span></span><br><span class="line"><span class="comment">//	wnum	需要写入的字节数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">FLASH_Write</span><span class="params">(<span class="type">uint32_t</span> saddr, <span class="type">uint32_t</span> *wdata, <span class="type">uint32_t</span> wnum)</span></span><br><span class="line">&#123;</span><br><span class="line">    FLASH_Unlock(); 						<span class="comment">// 解锁FLASH操作</span></span><br><span class="line">    <span class="keyword">while</span> (wnum)</span><br><span class="line">    &#123;</span><br><span class="line">        FLASH_ProgramWord(saddr, *wdata); 	<span class="comment">// 按uint32_t写入数据</span></span><br><span class="line">        wnum -= <span class="number">4</span>;                        	<span class="comment">// 剩余字节数减4</span></span><br><span class="line">        saddr += <span class="number">4</span>;                       	<span class="comment">// 地址指针递增4字节</span></span><br><span class="line">        wdata++;                          	<span class="comment">// 数据指针指向下一个32位数据</span></span><br><span class="line">    &#125;</span><br><span class="line">    FLASH_Lock(); 							<span class="comment">// 锁定FLASH</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="bootloader功能实现"><a class="markdownIt-Anchor" href="#bootloader功能实现"></a> Bootloader功能实现</h2>
<img src="https://s2.loli.net/2025/05/10/NkZvJ52acX16gfT.png" style="zoom:50%;" />
<h3 id="ab分区规划"><a class="markdownIt-Anchor" href="#ab分区规划"></a> AB分区规划</h3>
<p><strong>1个扇页1KB</strong>，A区起始位置：0x 0800 5000， 单片机RAM位置：0x20000000 ~ 0x2000FFFF</p>
<table>
<thead>
<tr>
<th style="text-align:center">STM32F103C8T6</th>
<th style="text-align:center">64KB</th>
<th style="text-align:center">扇页</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B区</td>
<td style="text-align:center">20KB</td>
<td style="text-align:center">0 ~ 19</td>
</tr>
<tr>
<td style="text-align:center">A区</td>
<td style="text-align:center">44KB</td>
<td style="text-align:center">20 ~ 63</td>
</tr>
</tbody>
</table>
<h3 id="注意点"><a class="markdownIt-Anchor" href="#注意点"></a> 注意点</h3>
<table>
<thead>
<tr>
<th style="text-align:center">问题</th>
<th style="text-align:center">解答</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>谁将OTA_Flag打勾？</strong></td>
<td style="text-align:center">A区负责控制，标志位存放在24C02</td>
</tr>
<tr>
<td style="text-align:center"><strong>什么时候OTA_flag打勾</strong></td>
<td style="text-align:center">A区下载完毕之后</td>
</tr>
<tr>
<td style="text-align:center"><strong>OTA时，最新版本的程序文件下载到哪？</strong></td>
<td style="text-align:center">分片下载，共计256片塞入W25Q64（一页256Byte，共256页）</td>
</tr>
<tr>
<td style="text-align:center"><strong>OTA时，最新版本的程序文件如何下载？下载多少？</strong></td>
<td style="text-align:center">服务器下发程序大小，分片下载到W25Q64</td>
</tr>
<tr>
<td style="text-align:center"><strong>下载多少这个变量用不用保存？</strong></td>
<td style="text-align:center">需要，保存到24C02之中</td>
</tr>
<tr>
<td style="text-align:center"><strong>发生OTA事件时，B区如何更新A区</strong></td>
<td style="text-align:center">从W25Q64读取数据，写入A区Flash</td>
</tr>
</tbody>
</table>
<h3 id="ota宏定义"><a class="markdownIt-Anchor" href="#ota宏定义"></a> OTA宏定义</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> FLASH_SADDR 0x08000000                                     <span class="comment">// FLASH起始地址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLASH_PAGE_SIZE 1024                                       <span class="comment">// Flash页大小</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLASH_NUM 64                                               <span class="comment">// FLASH总页数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLASH_B_NUM 20                                             <span class="comment">// B区页数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLASH_A_NUM FLASH_NUM - FLASH_B_NUM                        <span class="comment">// A区页数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLASH_A_SPAGE FLASH_B_NUM                                  <span class="comment">// A区起始页数</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLASH_A_SADDR FLASH_SADDR + FLASH_A_SPAGE *FLASH_PAGE_SIZE <span class="comment">// A区起始地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UPDATA_A_FLAG 0x00000001     <span class="comment">// A区更新标志</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IAP_XMODEM_FLAG 0x00000002   <span class="comment">// 使用Xmodem协议的标志</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IAP_XMODEMD_FLAG 0x00000004  <span class="comment">// Xmodem协议传输数据的标志</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SET_VERSION_FLAG 0x00000008  <span class="comment">// 设置版本号的命令标志</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_5_FLAG 0x000000010       <span class="comment">// 向外部FLASH下载程序的命令标志</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD5_XMODEM_FLAG 0x000000020 <span class="comment">// 标记使用命令5后，Xmodem协议传输</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMD_6_FLAG 0x000000040       <span class="comment">// 使用外部FLASH内程序</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OTA_SET_FLAG 0xAABBCCDD</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 关于数组大小是11的原因，一个uint32_t为4位，(1+11)*4=48 Byte，对应24C02存储中每页16Byte，只需要3页就能存储</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint32_t</span> OTA_flag;    			<span class="comment">// OTA标志位</span></span><br><span class="line">    <span class="type">uint32_t</span> FireLen[<span class="number">11</span>]; 			<span class="comment">// 用于存储固件各部分的大小,0号成员固定W25Q64</span></span><br><span class="line">    <span class="type">uint8_t</span> OTA_Ver[<span class="number">32</span>];  			<span class="comment">// 版本号</span></span><br><span class="line">&#125; OTA_CB;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint8_t</span> UpDataBuff[FLASH_PAGE_SIZE]; <span class="comment">// 临时存储外部接收的固件数据块</span></span><br><span class="line">    <span class="type">uint32_t</span> W25Q64_BlockNM;             <span class="comment">// 记录当前固件写入哪个块</span></span><br><span class="line">    <span class="type">uint32_t</span> XmodemTimer;                <span class="comment">// 记录延时</span></span><br><span class="line">    <span class="type">uint32_t</span> XmodemNB;                   <span class="comment">// 数据包接收数量</span></span><br><span class="line">    <span class="type">uint32_t</span> XmodemCRC;                  <span class="comment">// 存放CRC校验</span></span><br><span class="line">&#125; UpData;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> OTA_CB OTA;</span><br><span class="line"><span class="keyword">extern</span> UpData Updata_A;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OTA_INFO_SIZE sizeof(OTA_CB)</span></span><br></pre></td></tr></table></figure>
<h3 id="ota读取标志位"><a class="markdownIt-Anchor" href="#ota读取标志位"></a> OTA读取标志位</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取OTA标志位,判断是否有数据需要更新</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AT24C02_ReadOTA</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;OTA, <span class="number">0</span>, OTA_INFO_SIZE); 	<span class="comment">// 开辟一个OTA_INFO_SIZE大小的地址，初始化为0</span></span><br><span class="line">    <span class="comment">// 从AT24C02读取OTA_INFO_SIZE的数据到结构体中</span></span><br><span class="line">    AT24C02_ReadData(<span class="number">0</span>, (<span class="type">uint8_t</span> *)&amp;OTA, OTA_INFO_SIZE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ota保存关键变量到at24c02"><a class="markdownIt-Anchor" href="#ota保存关键变量到at24c02"></a> OTA保存关键变量到AT24C02</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写入OTA配置到EEPROM</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AT24C02_WriteOTA</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> *pdata = (<span class="type">uint8_t</span> *)&amp;OTA;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">uint8_t</span> i = <span class="number">0</span>; i &lt; (OTA_INFO_SIZE + <span class="number">7</span>) / <span class="number">8</span>; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		AT24C02_WritePage(i * <span class="number">8</span>, pdata + i * <span class="number">8</span>);</span><br><span class="line">    	delay_ms(<span class="number">10</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="引导更新ota"><a class="markdownIt-Anchor" href="#引导更新ota"></a> 引导更新OTA</h3>
<p><strong>(从下面向上看)</strong></p>
<p><strong>分区跳转</strong>两大关键<strong>SP、PC</strong>设定</p>
<p>Cortex-M3有<strong>R0-R12通用寄存器，R13有MSP（主堆栈指针）和PSP（进程堆栈指针）(保存现场和恢复现场的指针)，R14是LR（连接寄存器，保存子函数之间跳转的返回值），R15是PC（程序计数器）</strong></p>
<ul>
<li>
<p>20(A区起始页) * 1024 = 20480 —&gt; 0x00005000 + 0x08000000 = <strong>0x08005000</strong>，此为A区开始时SP<strong>地址</strong></p>
</li>
<li>
<p>A区起始位置<strong>0x08005000 + 4</strong>(32位的指针是4Byte)，此为A区开始时<strong>PC地址</strong></p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RAM ： 0x20000000 ~ 0x2000FFFF</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FLASH_A_SADDR FLASH_SADDR + FLASH_A_SPAGE * FLASH_PAGE_SIZE <span class="comment">// A区起始地址</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(*load_a)</span><span class="params">(<span class="type">void</span>)</span>; 	<span class="comment">// 回调函数，函数指针，指向一个无参数、无返回值的函数</span></span><br><span class="line">load_a load_A;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于修改主堆栈指针(MSP)</span></span><br><span class="line">__ASM <span class="type">void</span> <span class="title function_">MSR_SP</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;				 				</span><br><span class="line">	MSR MSP, r0;<span class="comment">// MSR指令用于将程序状态寄存器的内容传送到通用寄存器中，R0=addr</span></span><br><span class="line">	BX r14;<span class="comment">// 通过链接寄存器LR(r14)返回调用者，等同于return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转到A区应用程序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LOAD_A</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> ((*(<span class="type">uint32_t</span> *)addr &gt;= <span class="number">0x20000000</span>) &amp;&amp; (*(<span class="type">uint32_t</span> *)addr &lt;= <span class="number">0x2000FFFF</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 设置A区起始地址,因为MSR_SP函数接收uint32_t的数据，所以先强制转换，再指针取地址</span></span><br><span class="line">		MSR_SP(*(<span class="type">uint32_t</span> *)addr);</span><br><span class="line">		load_A = (load_a) * (<span class="type">uint32_t</span> *)(addr + <span class="number">4</span>); <span class="comment">// 获取复位中断处理程序地址</span></span><br><span class="line">		load_A();									<span class="comment">// 实际执行的是Reset_Handler</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		uprintf(<span class="string">&quot;跳转A分区失败\r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引导OTA函数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BootLoader_Jump</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="comment">// 等待20*100ms检测是否进入命令行模式</span></span><br><span class="line">	<span class="keyword">if</span> (BootLoader_Enter(<span class="number">20</span>) == <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">// 检查OTA更新标志</span></span><br><span class="line">		<span class="keyword">if</span> (OTA.OTA_flag == OTA_SET_FLAG)</span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;OTA更新 \r\n&quot;</span>);</span><br><span class="line">			BootState |= UPDATA_A_FLAG;	 <span class="comment">// 设置A区更新标志</span></span><br><span class="line">			UpDATA_A.W25Q64_BlockNM = <span class="number">0</span>; <span class="comment">// 默认使用W25Q64的块0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;跳转A分区 \r\n&quot;</span>);</span><br><span class="line">			LOAD_A(FLASH_A_SADDR); <span class="comment">// 跳转到A区应用程序</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	uprintf(<span class="string">&quot;进入BootLoader命令行 \r\n&quot;</span>);</span><br><span class="line">	BootLoader_Info();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 复位外设，没用到</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BootLoader_Clear</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	USART_DeInit(USART1);</span><br><span class="line">	GPIO_DeInit(GPIOA);</span><br><span class="line">	GPIO_DeInit(GPIOB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bootloader事件"><a class="markdownIt-Anchor" href="#bootloader事件"></a> BootLoader事件</h3>
<p><strong>(从上面向下看)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">uint32_t</span> BootState; 			<span class="comment">// 系统启动状态标志位</span></span><br><span class="line"><span class="type">uint8_t</span> wdata[<span class="number">2048</span>];</span><br><span class="line"><span class="type">uint8_t</span> rdata[<span class="number">2048</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*	显示BootLoader命令行帮助信息	*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BootLoader_Info</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	uprintf(<span class="string">&quot; \r\n&quot;</span>);</span><br><span class="line">	uprintf(<span class="string">&quot;[1]擦除A区 \r\n&quot;</span>);</span><br><span class="line">	uprintf(<span class="string">&quot;[2]串口IAP下载A区 \r\n&quot;</span>);</span><br><span class="line">	uprintf(<span class="string">&quot;[3]设置OTA版本号 \r\n&quot;</span>);</span><br><span class="line">	uprintf(<span class="string">&quot;[4]查询OTA版本号 \r\n&quot;</span>);</span><br><span class="line">	uprintf(<span class="string">&quot;[5]向外部FLASH下载程序 \r\n&quot;</span>);</span><br><span class="line">	uprintf(<span class="string">&quot;[6]使用外部FLASH内程序 \r\n&quot;</span>);</span><br><span class="line">	uprintf(<span class="string">&quot;[7]重启 \r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*	检测是否进入命令行模式，timeout 超时时间，1-进入命令行，0-不进入	*/</span></span><br><span class="line"><span class="type">uint8_t</span> <span class="title function_">BootLoader_Enter</span><span class="params">(<span class="type">uint8_t</span> timeout)</span></span><br><span class="line">&#123;</span><br><span class="line">	uprintf(<span class="string">&quot;输入小写字母w,进入BootLoader命令行 \r\n&quot;</span>);</span><br><span class="line">	<span class="keyword">while</span> (timeout--)</span><br><span class="line">	&#123;</span><br><span class="line">		Delay_ms(<span class="number">200</span>);</span><br><span class="line">		<span class="keyword">if</span> (U1_RX_Buff[<span class="number">0</span>] == <span class="string">&#x27;w&#x27;</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>; 							<span class="comment">// 进入命令行</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; 									<span class="comment">// 不进入</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Bootloader事件组</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BootLoader_Event</span><span class="params">(<span class="type">uint8_t</span> *data, <span class="type">uint16_t</span> datalen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> temp, i;</span><br><span class="line">	<span class="keyword">if</span> (BootState == <span class="number">0</span>)<span class="comment">// BootState=0：不进行其他操作，显示界面</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> ((datalen == <span class="number">1</span>) &amp;&amp; (data[<span class="number">0</span>] == <span class="string">&#x27;1&#x27;</span>))<span class="comment">//	擦除A区</span></span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;[1]擦除A区 \r\n&quot;</span>);</span><br><span class="line">			FLASH_Erase(FLASH_A_SPAGE, FLASH_A_NUM);</span><br><span class="line">			Delay_ms(<span class="number">100</span>);</span><br><span class="line">			BootLoader_Info();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((datalen == <span class="number">1</span>) &amp;&amp; (data[<span class="number">0</span>] == <span class="string">&#x27;2&#x27;</span>))<span class="comment">//	通过Xmodem下载固件到A区</span></span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;通过Xmodem协议,串口IAP下载A区程序,使用bin文件 \r\n&quot;</span>);</span><br><span class="line">			FLASH_Erase(FLASH_A_SPAGE, FLASH_A_NUM);		   <span class="comment">// 擦除目标区域</span></span><br><span class="line">			BootState |= (IAP_XMODEM_FLAG | IAP_XMODEMD_FLAG); <span class="comment">// 设置Xmodem标志</span></span><br><span class="line">			UpDATA_A.XmodemTimer = <span class="number">0</span>;						   <span class="comment">// 重置计时器</span></span><br><span class="line">			UpDATA_A.XmodemNB = <span class="number">0</span>;							   <span class="comment">// 重置数据包计数器</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((datalen == <span class="number">1</span>) &amp;&amp; (data[<span class="number">0</span>] == <span class="string">&#x27;3&#x27;</span>))	<span class="comment">//	设置版本号</span></span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;设置版本号 \r\n&quot;</span>);</span><br><span class="line">			BootState |= SET_VERSION_FLAG;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((datalen == <span class="number">1</span>) &amp;&amp; (data[<span class="number">0</span>] == <span class="string">&#x27;4&#x27;</span>))	<span class="comment">//	查询版本号</span></span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;查询版本号 \r\n&quot;</span>);</span><br><span class="line">			AT24C02_ReadOTA();							</span><br><span class="line">			uprintf(<span class="string">&quot;版本号:%s \r\n&quot;</span>, OTA.OTA_Ver);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((datalen == <span class="number">1</span>) &amp;&amp; (data[<span class="number">0</span>] == <span class="string">&#x27;5&#x27;</span>))	<span class="comment">//向外部FLASH传输程序</span></span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;向外部FLASH传输程序,输入需要使用的块编号(1~9) \r\n&quot;</span>);</span><br><span class="line">			BootState |= CMD_5_FLAG;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((datalen == <span class="number">1</span>) &amp;&amp; (data[<span class="number">0</span>] == <span class="string">&#x27;6&#x27;</span>))	<span class="comment">//使用外部FLASH下载程序</span></span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;使用外部FLASH下载程序,输入需要使用的块编号(1~9) \r\n&quot;</span>);</span><br><span class="line">			BootState |= CMD_6_FLAG;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> ((datalen == <span class="number">1</span>) &amp;&amp; (data[<span class="number">0</span>] == <span class="string">&#x27;7&#x27;</span>))	<span class="comment">// Reset</span></span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;重启中 \r\n&quot;</span>);</span><br><span class="line">			__set_FAULTMASK(<span class="number">1</span>);</span><br><span class="line">			Delay_ms(<span class="number">100</span>);</span><br><span class="line">			NVIC_SystemReset();							<span class="comment">//NVIC重启</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (BootState &amp; IAP_XMODEMD_FLAG)				<span class="comment">// Xmodem协议数据处理</span></span><br><span class="line">	&#123;</span><br><span class="line">        <span class="comment">// 接收数据包（133字节：1个字节+128字节+2CRC+2Byte序号）</span></span><br><span class="line">		<span class="keyword">if</span> ((datalen == <span class="number">133</span>) &amp;&amp; (data[<span class="number">0</span>] == <span class="number">0x01</span>))</span><br><span class="line">		&#123;</span><br><span class="line">			BootState &amp;= ~IAP_XMODEM_FLAG;	</span><br><span class="line">			UpDATA_A.XmodemCRC = Xmodem_CRC16(&amp;data[<span class="number">3</span>], <span class="number">128</span>);<span class="comment">// 计算接收数据的CRC校验值</span></span><br><span class="line">			<span class="keyword">if</span> (UpDATA_A.XmodemCRC == data[<span class="number">131</span>] * <span class="number">256</span> + data[<span class="number">132</span>])	<span class="comment">// 校验通过处理</span></span><br><span class="line">			&#123;</span><br><span class="line">				UpDATA_A.XmodemNB++;<span class="comment">// Xmodem接收数据包增加					</span></span><br><span class="line">				<span class="comment">// 将数据拷贝到缓冲区</span></span><br><span class="line">                <span class="built_in">memcpy</span>(&amp;UpDATA_A.UpDataBuff[((UpDATA_A.XmodemNB - <span class="number">1</span>) % (FLASH_PAGE_SIZE / <span class="number">128</span>)) * <span class="number">128</span>], &amp;data[<span class="number">3</span>], <span class="number">128</span>); </span><br><span class="line">                <span class="comment">//&amp;data[3]：Xmodem包的数据部分从第4字节开始（跳过1字节头+2字节序号）</span></span><br><span class="line">                <span class="comment">//(FLASH_PAGE_SIZE(1024) / 128)计算一页可以存下的包数，对该取模，当超过一页重新计算</span></span><br><span class="line">				<span class="keyword">if</span> ((UpDATA_A.XmodemNB % (FLASH_PAGE_SIZE / <span class="number">128</span>)) == <span class="number">0</span>) <span class="comment">// 1024/128=8，每8个数据包发送一次</span></span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">if</span> (BootState &amp; CMD5_XMODEM_FLAG)<span class="comment">// 选择写入W25Q64或FLASH</span></span><br><span class="line">					&#123;							</span><br><span class="line">						<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)<span class="comment">// 写入外部W25Q64，每次写入256字节，写4次为一页</span></span><br><span class="line">						&#123;</span><br><span class="line">							W25Q64_PageWrite(&amp;UpDATA_A.UpDataBuff[i * <span class="number">256</span>], </span><br><span class="line">							(UpDATA_A.XmodemNB / <span class="number">8</span> - <span class="number">1</span>) * <span class="number">4</span> + i + UpDATA_A.W25Q64_BlockNM * <span class="number">64</span> * <span class="number">4</span>);</span><br><span class="line">							<span class="comment">//(x/8-1)*4+i,x表示接收到的数据包个数，4表示写入W25Q64的页数,i用来定位页数</span></span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span></span><br><span class="line">					&#123;</span><br><span class="line">						<span class="comment">// FLASH_A_SADDR + ((UpDATA_A.XmodemNB / (FLASH_PAGE_SIZE / 128)) - 1) * FLASH_PAGE_SIZE</span></span><br><span class="line">						<span class="comment">// A区的起始地址+((接收的8个Xmodem协议包 / (一页占据的协议包数量)) -1(索引从0开始) * 当前页偏移地址</span></span><br><span class="line">                        <span class="comment">// 通过Xmodem协议传输的写入到缓冲区的数据</span></span><br><span class="line">						FLASH_Write(FLASH_A_SADDR + ((UpDATA_A.XmodemNB / (FLASH_PAGE_SIZE / <span class="number">128</span>)) - <span class="number">1</span>) * FLASH_PAGE_SIZE,</span><br><span class="line">						(<span class="type">uint32_t</span> *)UpDATA_A.UpDataBuff, FLASH_PAGE_SIZE);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				uprintf(<span class="string">&quot;\x06&quot;</span>); 			<span class="comment">// 表示Xmodem协议包读取成功</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				uprintf(<span class="string">&quot;\x15&quot;</span>); 			<span class="comment">// 表示Xmodem协议包读取失败</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> ((datalen == <span class="number">1</span>) &amp;&amp; (data[<span class="number">0</span>] == <span class="number">0x04</span>)) 					<span class="comment">// 读取Xmodem协议包剩余的数据</span></span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;\x06&quot;</span>);</span><br><span class="line">			<span class="keyword">if</span> ((UpDATA_A.XmodemNB % (FLASH_PAGE_SIZE / <span class="number">128</span>)) != <span class="number">0</span>) <span class="comment">// 如果有剩余的数据</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">if</span> (BootState &amp; CMD5_XMODEM_FLAG)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">					&#123;</span><br><span class="line">						W25Q64_PageWrite(&amp;UpDATA_A.UpDataBuff[i * <span class="number">256</span>],</span><br><span class="line">						(UpDATA_A.XmodemNB / <span class="number">8</span>) * <span class="number">4</span> + i + UpDATA_A.W25Q64_BlockNM * <span class="number">64</span> * <span class="number">4</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span></span><br><span class="line">				&#123;</span><br><span class="line">					FLASH_Write(FLASH_A_SADDR + ((UpDATA_A.XmodemNB / (FLASH_PAGE_SIZE / <span class="number">128</span>))) * FLASH_PAGE_SIZE,</span><br><span class="line">					(<span class="type">uint32_t</span> *)UpDATA_A.UpDataBuff,</span><br><span class="line">					(UpDATA_A.XmodemNB % (FLASH_PAGE_SIZE / <span class="number">128</span>)) * <span class="number">128</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			BootState &amp;= ~IAP_XMODEMD_FLAG;</span><br><span class="line">			<span class="keyword">if</span> (BootState &amp; CMD5_XMODEM_FLAG) 		<span class="comment">// 将数据下载到W25Q64</span></span><br><span class="line">			&#123;</span><br><span class="line">				BootState &amp;= ~CMD5_XMODEM_FLAG;		<span class="comment">// 将标志位复位</span></span><br><span class="line">				OTA.FireLen[UpDATA_A.W25Q64_BlockNM] = UpDATA_A.XmodemNB * <span class="number">128</span>; <span class="comment">// 将Xmodem数据存入W25Q64中</span></span><br><span class="line">				AT24C02_WriteOTA();					<span class="comment">// 存储数据,掉电不丢失</span></span><br><span class="line">				Delay_ms(<span class="number">100</span>);</span><br><span class="line">				BootLoader_Info();					<span class="comment">//重新显示命令行</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				__set_FAULTMASK(<span class="number">1</span>); 				<span class="comment">// 关闭所有中断</span></span><br><span class="line">				Delay_ms(<span class="number">100</span>);</span><br><span class="line">				NVIC_SystemReset(); 				<span class="comment">// 程序重启</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (BootState &amp; SET_VERSION_FLAG) 		<span class="comment">// 设置版本号</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (datalen &lt;= <span class="number">32</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">sscanf</span>((<span class="type">const</span> <span class="type">char</span> *)data, <span class="string">&quot;VER-%d.%d.%d-%d/%d/%d-%d:%d&quot;</span>, &amp;temp, &amp;temp, &amp;temp, &amp;temp, &amp;temp, &amp;temp, &amp;temp, &amp;temp) == <span class="number">8</span>)</span><br><span class="line">			&#123;								   <span class="comment">// VER-1.0.0-2025/5/1-10:28</span></span><br><span class="line">				<span class="built_in">memset</span>(OTA.OTA_Ver, <span class="number">0</span>, <span class="number">32</span>);	   <span class="comment">// 将之前的版本号清零</span></span><br><span class="line">				<span class="built_in">memcpy</span>(OTA.OTA_Ver, data, <span class="number">32</span>); <span class="comment">// 填入新的版本号</span></span><br><span class="line">				AT24C02_WriteOTA();			   <span class="comment">// 写入掉电不丢失芯片</span></span><br><span class="line">				uprintf(<span class="string">&quot;版本号正确 \r\n&quot;</span>);</span><br><span class="line">				BootLoader_Info();</span><br><span class="line">				BootState &amp;= ~SET_VERSION_FLAG; <span class="comment">// 使用完复位标志位</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				uprintf(<span class="string">&quot;版本号格式错误 \r\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;版本号长度错误 \r\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (BootState &amp; CMD_5_FLAG)			<span class="comment">// 将bin程序传入W25Q64的第%d个块</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (datalen == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> ((data[<span class="number">0</span>] &gt;= <span class="number">0x31</span>) &amp;&amp; (data[<span class="number">0</span>] &lt;= <span class="number">0x39</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				UpDATA_A.W25Q64_BlockNM = data[<span class="number">0</span>] - <span class="number">0x30</span>; 	<span class="comment">// 字符转换数字</span></span><br><span class="line">				BootState |= (IAP_XMODEM_FLAG | IAP_XMODEMD_FLAG | CMD5_XMODEM_FLAG);<span class="comment">//加上XMODEM的标志位</span></span><br><span class="line">				UpDATA_A.XmodemTimer = <span class="number">0</span>;					<span class="comment">// 清空定时器</span></span><br><span class="line">				UpDATA_A.XmodemNB = <span class="number">0</span>;						<span class="comment">// 清空发送的包数</span></span><br><span class="line">				OTA.FireLen[UpDATA_A.W25Q64_BlockNM] = <span class="number">0</span>;	<span class="comment">// 置零表示清空数据</span></span><br><span class="line">				W25Q64_Erase_64k(UpDATA_A.W25Q64_BlockNM);	<span class="comment">// 擦除整块</span></span><br><span class="line">				uprintf(<span class="string">&quot;通过Xmodem协议,向外部FLASH第%d个块传输程序,使用bin文件 \r\n&quot;</span>, UpDATA_A.W25Q64_BlockNM);</span><br><span class="line">				BootState &amp;= ~CMD_5_FLAG;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				uprintf(<span class="string">&quot;编号错误 \r\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;数据长度错误 \r\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (BootState &amp; CMD_6_FLAG) 						<span class="comment">// 使用W25Q64保存的APP程序</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (datalen == <span class="number">1</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> ((data[<span class="number">0</span>] &gt;= <span class="number">0x31</span>) &amp;&amp; (data[<span class="number">0</span>] &lt;= <span class="number">0x39</span>))</span><br><span class="line">			&#123;</span><br><span class="line">				UpDATA_A.W25Q64_BlockNM = data[<span class="number">0</span>] - <span class="number">0x30</span>; 		<span class="comment">// 字符转换数字</span></span><br><span class="line">				BootState |= UPDATA_A_FLAG;				  <span class="comment">// A区更新标志</span></span><br><span class="line">				BootState &amp;= ~CMD_6_FLAG;				  <span class="comment">// 将命令6标志置位</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				uprintf(<span class="string">&quot;编号错误 \r\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;长度错误 \r\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="主程序"><a class="markdownIt-Anchor" href="#主程序"></a> 主程序</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要用到的功能：串口，SPI，FLASH</span></span><br><span class="line"><span class="type">uint32_t</span> BootState; 	<span class="comment">// 系统启动状态标志位</span></span><br><span class="line"><span class="type">uint8_t</span> wdata[<span class="number">2048</span>];</span><br><span class="line"><span class="type">uint8_t</span> rdata[<span class="number">2048</span>];</span><br><span class="line"><span class="keyword">extern</span> OTA_CB OTA;</span><br><span class="line"><span class="keyword">extern</span> UpData UpDATA_A;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">uint32_t</span> BootState;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> i;</span><br><span class="line">	USART1_Init(<span class="number">921600</span>); 	<span class="comment">// 初始化串口1，波特率921600</span></span><br><span class="line">	Delay_Init();		 <span class="comment">// 初始化延时函数</span></span><br><span class="line">	I2C1_Init();		 <span class="comment">// 初始化I2C1（用于AT24C02通信）</span></span><br><span class="line">	AT24C02_ReadOTA();	 <span class="comment">// 从AT24C02读取OTA标志位</span></span><br><span class="line">	W25Q64_Init();		 <span class="comment">// 初始化W25Q64（SPI Flash）</span></span><br><span class="line">	BootLoader_Jump();	 <span class="comment">// 检查是否需要跳转到BootLoader</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		Delay_ms(<span class="number">10</span>); <span class="comment">// 主循环延时10ms</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 串口1处理缓冲区数据</span></span><br><span class="line">		<span class="keyword">if</span> (U1CB.URxDataOUT != U1CB.URxDataIN)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 处理接收到的数据（Xmodem协议或其他指令）</span></span><br><span class="line">			BootLoader_Event(U1CB.URxDataOUT-&gt;start, U1CB.URxDataOUT-&gt;end - U1CB.URxDataOUT-&gt;start + <span class="number">1</span>);</span><br><span class="line">			<span class="comment">// 移动接收缓冲区指针</span></span><br><span class="line">			U1CB.URxDataOUT++;</span><br><span class="line">			<span class="keyword">if</span> (U1CB.URxDataOUT == U1CB.URxDataEND)</span><br><span class="line">			&#123;</span><br><span class="line">				U1CB.URxDataOUT = &amp;U1CB.URxDataPtr[<span class="number">0</span>]; <span class="comment">// 环形缓冲区回卷</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        </span><br><span class="line">		<span class="comment">// 检查是否需要发送Xmodem协议的控制字符&#x27;C&#x27;</span></span><br><span class="line">		<span class="keyword">if</span> (BootState &amp; IAP_XMODEM_FLAG)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (UpDATA_A.XmodemTimer &gt;= <span class="number">100</span>) 	<span class="comment">// 每100次循环发送一次&#x27;C&#x27;</span></span><br><span class="line">			&#123;</span><br><span class="line">				uprintf(<span class="string">&quot;C&quot;</span>); 				<span class="comment">// 发送Xmodem起始信号</span></span><br><span class="line">				UpDATA_A.XmodemTimer = <span class="number">0</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			UpDATA_A.XmodemTimer++;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 检查是否需要更新A区固件</span></span><br><span class="line">		<span class="keyword">if</span> (BootState &amp; UPDATA_A_FLAG)</span><br><span class="line">		&#123;</span><br><span class="line">			uprintf(<span class="string">&quot;长度%d字节\r\n&quot;</span>, OTA.FireLen[UpDATA_A.W25Q64_BlockNM]);</span><br><span class="line">			<span class="comment">// 擦除目标FLASH区域(A区)</span></span><br><span class="line">			FLASH_Erase(FLASH_A_SPAGE, FLASH_A_NUM);</span><br><span class="line">			uprintf(<span class="string">&quot;A区已擦除 \r\n&quot;</span>);</span><br><span class="line">			<span class="comment">// 检查固件长度是否为4的倍数</span></span><br><span class="line">			<span class="keyword">if</span> (OTA.FireLen[UpDATA_A.W25Q64_BlockNM] % <span class="number">4</span> == <span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="comment">// 按1KB页循环写入完整数据块</span></span><br><span class="line">				<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; (OTA.FireLen[UpDATA_A.W25Q64_BlockNM] / <span class="number">1024</span>); i++)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="comment">// 从W25Q64读取1KB数据到缓冲区</span></span><br><span class="line">                    			<span class="comment">// 源地址：块号×64KB + 偏移量， 读取长度=1KB</span></span><br><span class="line">					W25Q64_Read(UpDATA_A.UpDataBuff, i * FLASH_PAGE_SIZE + <span class="number">64</span> * <span class="number">1024</span> * UpDATA_A.W25Q64_BlockNM, FLASH_PAGE_SIZE);</span><br><span class="line">					<span class="comment">// 将1KB数据写入FLASH（目标地址递增）</span></span><br><span class="line">                    <span class="comment">// 目标地址</span></span><br><span class="line">                    <span class="comment">// 数据指针（强制转换为uint32_t*）</span></span><br><span class="line">                    <span class="comment">// 写入长度=1KB</span></span><br><span class="line">					FLASH_Write(FLASH_A_SADDR + i * FLASH_PAGE_SIZE, (<span class="type">uint32_t</span> *)UpDATA_A.UpDataBuff, FLASH_PAGE_SIZE);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 处理剩余不足1KB的数据</span></span><br><span class="line">				<span class="keyword">if</span> (OTA.FireLen[UpDATA_A.W25Q64_BlockNM] % <span class="number">1024</span> != <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					<span class="built_in">memset</span>(UpDATA_A.UpDataBuff, <span class="number">0</span>, FLASH_PAGE_SIZE);</span><br><span class="line">					<span class="comment">// 读取剩余数据</span></span><br><span class="line">                    <span class="comment">// 剩余数据的起始地址，剩余数据长度</span></span><br><span class="line">					W25Q64_Read(UpDATA_A.UpDataBuff, i * FLASH_PAGE_SIZE + <span class="number">64</span> * <span class="number">1024</span> * UpDATA_A.W25Q64_BlockNM,</span><br><span class="line">					OTA.FireLen[UpDATA_A.W25Q64_BlockNM] % <span class="number">1024</span>);</span><br><span class="line">                    </span><br><span class="line">					<span class="comment">// 写入剩余数据到FLASH</span></span><br><span class="line">					FLASH_Write(FLASH_A_SADDR + i * FLASH_PAGE_SIZE, (<span class="type">uint32_t</span> *)UpDATA_A.UpDataBuff, OTA.FireLen[UpDATA_A.W25Q64_BlockNM] % <span class="number">1024</span>);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// OTA更新后，UpDATA_A.W25Q64_BlockNM == 0</span></span><br><span class="line">				<span class="keyword">if</span> (UpDATA_A.W25Q64_BlockNM == <span class="number">0</span>)</span><br><span class="line">				&#123;</span><br><span class="line">					OTA.OTA_flag = <span class="number">0</span>;				<span class="comment">// 清除OTA标志</span></span><br><span class="line">					AT24C02_WriteOTA(); 			<span class="comment">// 更新后写入AT24C02（持久化存储）</span></span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">// 重启</span></span><br><span class="line">				uprintf(<span class="string">&quot; \r\nA区更新完毕 \r\n&quot;</span>);</span><br><span class="line">				__set_FAULTMASK(<span class="number">1</span>); <span class="comment">// 屏蔽所有异常</span></span><br><span class="line">				Delay_ms(<span class="number">100</span>);</span><br><span class="line">				NVIC_SystemReset(); <span class="comment">// 系统复位</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				uprintf(<span class="string">&quot;长度错误\r\n&quot;</span>);	 <span class="comment">// 数据长度未对齐</span></span><br><span class="line">				BootState &amp;= ~UPDATA_A_FLAG; <span class="comment">// 清除更新标志</span></span><br><span class="line">				BootLoader_Info();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="xmodem协议"><a class="markdownIt-Anchor" href="#xmodem协议"></a> Xmodem协议</h1>
<p><strong>Xmodem使用SecureCRTP</strong>软件配置连接串口通信，相较于Ymodem是更小的Package</p>
<h2 id="格式"><a class="markdownIt-Anchor" href="#格式"></a> 格式</h2>
<table>
<thead>
<tr>
<th style="text-align:center">Byte1</th>
<th style="text-align:center">Byte2</th>
<th style="text-align:center">Byte3</th>
<th style="text-align:center">Byte4 ~ Byte131</th>
<th style="text-align:center">Byte132 ~ Byte133</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Start of Header(SOH)</td>
<td style="text-align:center">Packet Number</td>
<td style="text-align:center">~(Packet Number)</td>
<td style="text-align:center">Pcacket Data</td>
<td style="text-align:center">CRC16 Check</td>
</tr>
</tbody>
</table>
<h2 id="指令"><a class="markdownIt-Anchor" href="#指令"></a> 指令</h2>
<table>
<thead>
<tr>
<th style="text-align:center">位</th>
<th style="text-align:center">指令</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">SOH</td>
<td style="text-align:center">0x01</td>
<td style="text-align:center">128字节数据包帧头</td>
</tr>
<tr>
<td style="text-align:center">STX</td>
<td style="text-align:center">0x02</td>
<td style="text-align:center">1024字节数据包帧头</td>
</tr>
<tr>
<td style="text-align:center">EOT</td>
<td style="text-align:center">0x04</td>
<td style="text-align:center">结束传输</td>
</tr>
<tr>
<td style="text-align:center">ACK</td>
<td style="text-align:center">0x06</td>
<td style="text-align:center">正确应答</td>
</tr>
<tr>
<td style="text-align:center">NAK</td>
<td style="text-align:center">0x15</td>
<td style="text-align:center">错误应答，重传数据</td>
</tr>
<tr>
<td style="text-align:center">CAN</td>
<td style="text-align:center">0x18</td>
<td style="text-align:center">取消传输</td>
</tr>
<tr>
<td style="text-align:center">CTRLZ</td>
<td style="text-align:center">0x1A</td>
<td style="text-align:center">数据填充</td>
</tr>
<tr>
<td style="text-align:center">HSC</td>
<td style="text-align:center">0x43</td>
<td style="text-align:center">握手</td>
</tr>
</tbody>
</table>
<h2 id="例子"><a class="markdownIt-Anchor" href="#例子"></a> 例子</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">‘C’											<span class="comment">// 发送一个C等待数据包</span></span><br><span class="line">											<span class="comment">// (3s一次，等待应答)</span></span><br><span class="line">SOH | <span class="number">0x01</span> | <span class="number">0xFE</span> | Data[<span class="number">0</span>~<span class="number">127</span>] | CRC16		<span class="comment">// 第一条指令</span></span><br><span class="line">ACK（正确应答）</span><br><span class="line">SOH | <span class="number">0x02</span> | <span class="number">0xFD</span> | Data[<span class="number">0</span>~<span class="number">127</span>] | CRC16		<span class="comment">// 第二条指令</span></span><br><span class="line">NAK（错误应答）</span><br><span class="line">SOH | <span class="number">0x02</span> | <span class="number">0xFD</span> | Data[<span class="number">0</span>~<span class="number">127</span>] | CRC16		<span class="comment">// 第二条指令</span></span><br><span class="line">ACK</span><br><span class="line">SOH | <span class="number">0x03</span> | <span class="number">0xFC</span> | Data[<span class="number">0</span>~<span class="number">127</span>] | CRC16s	<span class="comment">// 第三条指令</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<h2 id="crc16程序"><a class="markdownIt-Anchor" href="#crc16程序"></a> CRC16程序</h2>
<p>STM32支持CRC32，不支持CRC16，需要自己写</p>
<p>多项式p(x) = <strong>x^16 + x^12 + x^5 + 1</strong>，借助多项式将输入的数值进行<strong>模2除法</strong>，在C语言中是进行<strong>异或运算</strong>^。</p>
<p><img src="https://s2.loli.net/2025/05/09/V1B2YkysPQZipdg.png" alt="" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文字说明</span></span><br><span class="line">寄存器清零</span><br><span class="line">数据最右边补齐W位<span class="number">0</span> 							<span class="comment">// W是CRC校验值的位数</span></span><br><span class="line">when(还有数据)&#123;</span><br><span class="line">    左移寄存器<span class="number">1</span>位，读取数据的下一位到寄存器的bit <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (左移寄存器时出现溢出)&#123;</span><br><span class="line">        寄存器 ^= poly;    				<span class="comment">// 这里的poly=0011，按照上面的例子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">寄存器的值就是校验值</span><br><span class="line">    </span><br><span class="line"><span class="type">uint16_t</span> <span class="title function_">Xmodem_CRC16</span><span class="params">(<span class="type">uint8_t</span> *data, <span class="type">uint16_t</span> datalen)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">uint8_t</span> i;</span><br><span class="line">	<span class="type">uint16_t</span> Crcinit = <span class="number">0x0000</span>; 	<span class="comment">// 初始化为0</span></span><br><span class="line">	<span class="type">uint16_t</span> Poly = <span class="number">0x1021</span>;	   	<span class="comment">// XMODEM 使用的多项式：x^16 + x^12 + x^5 + 1</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (datalen--)</span><br><span class="line">	&#123;</span><br><span class="line">		Crcinit = (*data &lt;&lt; <span class="number">8</span>) ^ Crcinit;</span><br><span class="line">		<span class="comment">// 左移八位是因为CRC是高位优先计算，异或是为了改变当前CRC的值</span></span><br><span class="line">		<span class="comment">// 异或将新数据“混合”进当前的CRC值，使CRC计算能覆盖所有输入数据</span></span><br><span class="line">		<span class="comment">// 若直接赋值会丢失之前计算的CRC值</span></span><br><span class="line">		<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) <span class="comment">// 每个bit都要影响CRC计算，所以必须循环 8 次</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (Crcinit &amp; <span class="number">0x8000</span>) 	<span class="comment">// 检查最高位是否为1</span></span><br><span class="line">				Crcinit = (Crcinit &lt;&lt; <span class="number">1</span>) ^ Poly;</span><br><span class="line">			<span class="comment">// 如果最高位是1，说明当前的CRC值已经达到或超过多项式的最高位(Poly最高位为0x1000)</span></span><br><span class="line">			<span class="comment">// 必须减去多项(即^Poly)否则CRC值会越来越大</span></span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">				Crcinit = (Crcinit &lt;&lt; <span class="number">1</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		data++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> Crcinit;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br></pre></td></tr></table></figure>
<h1 id="参考"><a class="markdownIt-Anchor" href="#参考"></a> 参考</h1>
<p><a target="_blank" rel="noopener" href="https://github.com/havenxie/stm32-iap-uart-boot">havenxie/stm32-iap-uart-boot: STM32 IAP(UART模式)的BOOT部分</a></p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1SatHeBEVG/?spm_id_from=333.1007.top_right_bar_window_default_collection.content.click">【手把手教程 4G通信物联网 OTA远程升级 BootLoader程序设计】GD32F103C8T6单片机【上篇章】_哔哩哔哩_bilibili</a></p>
<h1 id="补充724"><a class="markdownIt-Anchor" href="#补充724"></a> 补充（7.24）</h1>
<h2 id="bootloader执行流程"><a class="markdownIt-Anchor" href="#bootloader执行流程"></a> Bootloader执行流程</h2>
<ol>
<li>
<p><strong>上电或复位</strong></p>
<ul>
<li>当系统上电或复位时，处理器从一个固定的地址开始执行，这个地址称为 <strong>向量表（Vector Table）</strong> 的起始地址。</li>
</ul>
</li>
<li>
<p><strong>读取向量表地址（比如 Flash 起始地址）</strong></p>
<ul>
<li>默认情况下，ARM Cortex-M 处理器会从地址 <strong>0x08000000</strong>（即 Flash 起始地址）读取：
<ul>
<li><code>0x08000000</code>：初始 <strong>MSP（Main Stack Pointer）</strong></li>
<li><code>0x08000004</code>：<strong>Reset Handler 的地址</strong>，也就是主程序的入口点</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>设置 MSP</strong></p>
</li>
</ol>
<ul>
<li>处理器将 <code>0x08000000</code> 处的值加载到 MSP（Main Stack Pointer），为堆栈初始化。</li>
</ul>
<ol start="4">
<li><strong>跳转到 Reset Handler</strong>
<ul>
<li>处理器将 <code>0x08000004</code> 处的值作为程序计数器 PC，开始执行实际程序。</li>
</ul>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置主栈指针</span></span><br><span class="line">__ASM <span class="type">void</span> <span class="title function_">MSR_SP</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	MSR MSP, r0;</span><br><span class="line">	BX r14;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 跳转到A区应用程序</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LOAD_A</span><span class="params">(<span class="type">uint32_t</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>((*(<span class="type">uint32_t</span> *)addr &gt;= <span class="number">0x20000000</span>) &amp;&amp; (*(<span class="type">uint32_t</span> *)addr &lt;= <span class="number">0x20004FFF</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		MSR_SP(*(<span class="type">uint32_t</span> *)addr);</span><br><span class="line">		load_A = (load_a)*(<span class="type">uint32_t</span> *)(addr + <span class="number">4</span>);</span><br><span class="line">		load_A();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		uprintf(<span class="string">&quot;Failed to jump to Area A \r\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="sram在此的意义"><a class="markdownIt-Anchor" href="#sram在此的意义"></a> SRAM在此的意义</h2>
<ul>
<li>
<p>SRAM（Static RAM）是 MCU 的运行内存（RAM），堆栈、全局变量、局部变量都存放在这里。</p>
</li>
<li>
<p>MSP 指针一般会指向 SRAM 的顶端（例如 <code>0x20000000</code>），向下增长。</p>
</li>
<li>
<p>应用程序运行期间所有动态数据、堆栈帧等都存在于 SRAM 中。</p>
</li>
</ul>
<h2 id="app程序配置"><a class="markdownIt-Anchor" href="#app程序配置"></a> APP程序配置</h2>
<ol>
<li>
<p>system_stm32f10x.c文件中的VECT_TAB_OFFSET，设置0x5000</p>
</li>
<li>
<p>配置Target</p>
</li>
</ol>
<p><img src="https://s2.loli.net/2025/07/24/r9UhFepacuX4bDy.png" alt="" /></p>
<h2 id="dma配置rx_buffer-1配合idle实现接收不定长数据"><a class="markdownIt-Anchor" href="#dma配置rx_buffer-1配合idle实现接收不定长数据"></a> DMA配置RX_BUFFER + 1配合IDLE实现接收不定长数据</h2>
<ol>
<li>
<p><strong>DMA设置</strong>：传输计数为RX_BUFFER + 1</p>
</li>
<li>
<p><strong>IDLE触发</strong>：当接收数据长度小于设置计数时触发</p>
</li>
<li>
<p><strong>长度计算</strong>：通过剩余计数计算实际接收长度</p>
</li>
<li>
<p><strong>重新配置</strong>：每次IDLE中断后重新配置DMA</p>
</li>
</ol>
<h2 id="为什么dma不使用循环模式而是普通模式"><a class="markdownIt-Anchor" href="#为什么dma不使用循环模式而是普通模式"></a> 为什么DMA不使用循环模式，而是普通模式</h2>
<p>DMA如果<strong>使用循环模式</strong>，会自动循环使用同一个缓冲区，<strong>无法区分不同数据包的边界</strong>，数据会覆盖，无法实现数据包管理；而使用<strong>普通模式+IDLE</strong>，可以<strong>准确计算每个数据包的长度</strong>。</p>
<ul>
<li>
<p>数据包边界识别</p>
</li>
<li>
<p>内存管理灵活性</p>
</li>
<li>
<p>数据长度计算</p>
</li>
<li>
<p>数据包队列</p>
</li>
</ul>

    </div>
    <!--文末结束语-->
    
        <div style="text-align:center;color: #ccc;font-size:24px;"> --- 本文结束 <i class="fas fa-heart"></i> The End --- </div>
    
    <!--页脚广告-->
    
    <v-divider></v-divider>
    
    <div class="post-nav">             
        
            <div class="post-nav-button float-left">
                <v-icon>chevron_left</v-icon>
                <a class="font-weight-bold text-left" href="/2025/07/12/CAN%E9%80%9A%E4%BF%A1%E5%AD%A6%E4%B9%A0/">
                    CAN通信学习
                </a>
            </div>
              
          
            <div class="post-nav-button float-right">
                <a class="font-weight-bold text-right" href="/2025/05/08/%E8%B0%83%E8%AF%95BUG%E4%B8%8E%E4%B8%80%E4%BA%9B%E8%AF%B4%E6%98%8E/">      
                    调试BUG与一些说明
                </a>
                <v-icon>chevron_right</v-icon>
            </div>
        
    </div>
</v-card>



        
                            <div id="mobile-footer" class="d-block d-md-none">
                                <v-divider></v-divider>
                                <div id="mobile-footer-content">
                                    <span>Theme: <a target="_blank" rel="noopener" href="https://github.com/kb1000fx/hexo-theme-insulin">Insulin</a> &nbsp; Powered by <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a></span><br>
                                    <span> &copy; 2021 - 2025 Big Ben</span>
                                </div>
                            </div>                   
                        </v-col>                                            
                    </v-row>
                </v-container>
            </v-content>
        </v-app>
    </div>
    
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.11"></script>
<script src="https://cdn.jsdelivr.net/npm/vuetify@2.2.30"></script>
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/js-base64@3.5.2/base64.min.js"></script>

<script src="/js/main.js"></script>




    <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




    <script src="https://cdn.jsdelivr.net/npm/mermaid@8.4.8/dist/mermaid.min.js"></script>
    <script>mermaid.initialize({
        startOnLoad: true,
        theme: "default"
    });</script>





</body>
</html>
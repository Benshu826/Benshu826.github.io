<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="UTF-8">
    
    <link rel="apple-touch-icon" sizes="76x76" href="/null">
    <link rel="icon" type="image/png" href="/null">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    <title>常见八股问题 - Ben Shu &#39;s Blog</title>
    
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    
    
    <meta name="description" content="">
    <meta name="author" content="Big Ben">
    <meta name="keywords" content="">
    <meta property="og:title" content="常见八股问题"/>
    <style>


    
    :root{
        --shadow-color: rgba(0,0,0,0.2);
        --sec-shadow: rgba(0,0,0,0.03);
        --shadow-hover-color: rgba(0,0,0,0.28);
        --first-text-color: #475b6d;
        --second-text-color: #37475b;
        --third-text-color: #858585;
        --default-text-color: #505050;
        --default-link-color: #007bff;
        --link-color: #000000;
        --second-link-color: #4F9BFA;
        --code-color:rgba(27,31,35,.05);
        --post-bkg-color: #fff;
        --page-bkg-color: #f2f5f8;
        --nav-a-hover-color: #3498db;
        --post-sec-text-color: #718096;
        --sec-bkg: #f2f5f8;
        --color-mode: 'light';
        --bkg-h: rgba(255,255,255,0.6);
        --bkg-m: #e1e4e8;
        --home-title-color: #4169E1;
        --shadow: 0 4px 10px rgba(0,2,4,0.06),0 0 1px rgba(0,2,4,0.11);
        --hr-color: #ddd;
        --bg-t: #f4f4f4;
        --nav-bkg: rgba(255,255,255,0.6);
    }

@media (prefers-color-scheme: dark) {
  :root {
    --color-mode: 'dark';
  }

  :root:not([data-theme]) {
    --first-text-color: hsla(0,0%,100%,0.92);
    --second-text-color: hsla(0,0%,100%,0.86);
    --third-text-color: #a7a9ad;
    --default-text-color: #505050;
    --default-link-color: #1589e9;
    --link-color: #000000;
    --second-link-color: #30a9de;
    --post-bkg-color: #252d38;
    --page-bkg-color: #181c27;
    --nav-a-hover-color: #3498db;
    --post-sec-text-color: #a7a9ad;
    --sec-bkg: #364151;
    --bkg-h: rgba(255,255,255,0.2);
    --bkg-m: rgba(255,255,255,0.1);
    --home-title-color: rgb(226, 82, 90);
    --code-color:#3e4b5e;
    --shadow: none;
    --hr-color: #718096;
    --bg-t: #364151;
    --nav-bkg: rgba(13,17,23,0.6);
  }
}

[data-theme='dark'] {
    --shadow-color: rgba(0,0,0,0.2);
    --shadow-hover-color: rgba(0,0,0,0.28);
    --first-text-color: hsla(0,0%,100%,0.92);
    --second-text-color: hsla(0,0%,100%,0.86);
    --third-text-color: #a7a9ad;
    --default-text-color: #505050;
    --default-link-color: #1589e9;
    --link-color: #000000;
    --second-link-color: #30a9de;
    --post-bkg-color: #252d38;
    --page-bkg-color: #181c27;
    --nav-a-hover-color: #3498db;
    --post-sec-text-color: #a7a9ad;
    --sec-bkg: #364151;
    --bkg-h: rgba(255,255,255,0.2);
    --bkg-m: rgba(255,255,255,0.1);
    --home-title-color: rgb(226, 82, 90);
    --code-color:#3e4b5e;
    --shadow: none;
    --hr-color: #718096;
    --bg-t: #364151;
    --nav-bkg: rgba(13,17,23,0.6);
}

</style>



<style>
#page-main,footer,.p-btn{
    display: none;
}
html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
}
body {
    background-color: var(--page-bkg-color);
    color: var(--second-text-color);
    overflow-y: scroll;
    overflow-x: hidden;
    transition: all .3s;
}
a {
    color: var(--default-link-color);
    text-decoration: none;
    background-color: transparent;
}
a:hover{
    color: var(--second-link-color);
}
.main-content,.post-card-main{
    margin: 30px;
}



@media (max-width: 410px){
    .post-card-main{
        max-width: 350px!important;
    }
}

@media (max-width: 980px){
    .post-card-main{
        max-width: 520px!important;
    }
}


@media (min-width: 780px){ 
    h3{
        font-size: 1.5rem;
        line-height: 1.5em;
    }
}
@media (min-width: 1280px){ 
    h3{
        font-size: 1.7rem;
        line-height: 1.5em;
    }
}
@media (min-width: 2096px){ 
    h3{
        font-size: 1.8rem;
        line-height: 1.5em;
    }
}

.text-center{
    text-align: center!important;
}
.middle-center{
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;
    -webkit-box-align: center;
    -ms-flex-align: center;
    align-items: center;
    -webkit-box-pack: center;
    -ms-flex-pack: center;
    justify-content: center;
    height: 100%;
}
header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    position: fixed;
    height: 54px;
    padding: 0 1.25rem;
    top: 0;
    left: 0;
    right: 0;
    z-index: 10;
    border-bottom: 1px solid var(--bkg-m);
    background-color: var(--nav-bkg);
    backdrop-filter: blur(4px);
    transition: all .3s;
}
header .header__left, header .header__right {
    display: flex;
    align-items: center;
    font-family: rubik,sans-serif,Varela Round;
}
header .header__left .logo__text {
    font-size: 18px;
    font-weight: 450;
    padding: 14.5px 10px;
    border-radius: 5px;
    color: var(--second-text-color);
}
header .header__right .navbar__menus {
    height: 54px;
    padding: 0 0 0 15px;
}
header .header__right .button {
    color: var(--second-text-color);
}
header .header__right .navbar__menus .navbar-menu {
    display: inline-block;
    align-items: center;
    height: 54px;
    padding: 0 10px;
    font-size: 16px;
    line-height: 54px;
}
header .header__right .dropdown-icon {
    display: none;
    height: 54px;
    padding: 15px 10px;
    border: 0;
    background-color: transparent;
}
header .header__right .dropdown-menus {
    line-height: 2rem;
    animation: slide-in .15s ease 1;
    display: none;
    position: absolute;
    left: 12px;
    right: 12px;
    top: calc(54px + 10px);
    border-radius: 6px;
    padding: 24px;
    background-color: var(--page-bkg-color);
    border: 1px solid var(--bkg-m);
    z-index: 9999;
    justify-items: center;
    justify-content: center;
    flex-direction: column;
}
header .header__right #btn-search, header .header__right #btn-toggle-dark{
    display: inline-block;
    padding:  18px 10px;
    height: 25px;
}
header .header__right #btn-dropdown{
  display: inline-block;
  padding:  13.5px 0;
}
header .header__right .dropdown-menus .dropdown-menu {
    padding: 10px;
    color: var(--second-text-color);
}
@media screen and (max-width: 764px){
.navbar__menus {
    display: none!important;
}
.dropdown-icon {
    display: inline-block!important;
}
}
.p-btn{
    position: fixed;
    bottom: 1.2rem;
    right: 1.2rem;
    contain: layout;
}
.toc-btn,.click-btn{
    cursor: pointer;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    align-items: center;
    margin-top: .5rem;
    font-size: .75rem;
    background-color: var(--sec-bkg);
    display: block;
    padding: 0.9rem;
    box-shadow: 0 0.3rem 0.6rem rgba(48,55,66,.15);
    border: none;
    border-radius: 0.5rem;
    line-height: 1;
    color: var(--first-text-color);
}
.toc-link{
    color: var(--second-text-color);
}

#css-loading h3{
    font-weight: 500;
    font-size: 1.4rem;
    text-align: center;
    position: fixed;
    top: 200px;
    left: 0;
    right: 0;
    opacity: 0;
    animation: cssLoad;
    animation-delay: 0.3s;
    -webkit-animation: cssLoad;
    -webkit-animation-delay: 0.3s;
}
@keyframes cssLoad {
    from {
        opacity: 0;
    }
    to {
        opacity: 0.9;
    }
}


.memorial {
    -webkit-filter: grayscale(100%);
    -moz-filter: grayscale(100%);
    -ms-filter: grayscale(100%);
    -o-filter: grayscale(100%);
    filter: grayscale(100%);
    filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); filter:gray;
}


    .post-copyright:after {
        position: absolute;
        color: #fff;
        background: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 496 512'%3E%3Cpath fill='gray' d='M245.8 214.9l-33.2 17.3c-9.4-19.6-25.2-20-27.4-20-22.2 0-33.3 14.6-33.3 43.9 0 23.5 9.2 43.8 33.3 43.8 14.4 0 24.6-7 30.5-21.3l30.6 15.5a73.2 73.2 0 01-65.1 39c-22.6 0-74-10.3-74-77 0-58.7 43-77 72.6-77 30.8-.1 52.7 11.9 66 35.8zm143 0l-32.7 17.3c-9.5-19.8-25.7-20-27.9-20-22.1 0-33.2 14.6-33.2 43.9 0 23.5 9.2 43.8 33.2 43.8 14.5 0 24.7-7 30.5-21.3l31 15.5c-2 3.8-21.3 39-65 39-22.7 0-74-9.9-74-77 0-58.7 43-77 72.6-77C354 179 376 191 389 214.8zM247.7 8C104.7 8 0 123 0 256c0 138.4 113.6 248 247.6 248C377.5 504 496 403 496 256 496 118 389.4 8 247.6 8zm.8 450.8c-112.5 0-203.7-93-203.7-202.8 0-105.5 85.5-203.3 203.8-203.3A201.7 201.7 0 01451.3 256c0 121.7-99.7 202.9-202.9 202.9z'/%3E%3C/svg%3E");
        content: ' ';
        height: 10rem;
        width: 10rem;
        right: -2rem;
        top: -2rem;
        opacity: .1;
    }

</style>

    

    
        <!--
        <link rel="stylesheet" href="/css/page.css" media="print"
            onload="this.media='all';this.onload=null">
        <noscript>-->
            <link rel="stylesheet" href="/css/page.css">
        <!--</noscript>-->
    
    
    <link rel="stylesheet" href="/css/main.css" media="print" onload="this.media='all';this.onload=null">
    <noscript>
        <link rel="stylesheet" href="/css/main.css">
    </noscript>

    
    <script src="/js/main.js"></script>
    
      
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha512-fHwaWebuwA7NSF5Qg/af4UeDx9XqUpYpOGgubo3yWu+b2IQR4UeQwbb42Ti7gVAjNtVoI/I9TEoYeu9omwcC6g==" crossorigin="anonymous" referrerpolicy="no-referrer" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>

    <body>
        <header>
            
<div class="header__left">
	<a href="/" class="button"><span class="logo__text">主页</span></a>
</div>
<div class="header__right">
	<div class="navbar__menus">
		
		<a href="/" class="button">
			<div class="navbar-menu">首页</div>
		</a>
		
		<a href="/archives/" class="button">
			<div class="navbar-menu">归档</div>
		</a>
		
		<a href="/categories/" class="button">
			<div class="navbar-menu">分类</div>
		</a>
		
		<a href="/tags/" class="button">
			<div class="navbar-menu">标签</div>
		</a>
		
		<a href="/about/" class="button">
			<div class="navbar-menu">关于</div>
		</a>
		
	</div>
	
	<a href="/search/" class="button">
		<div id="btn-search">
			<svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 1024 1024" width="24" height="24" fill="currentColor"
				stroke="currentColor" stroke-width="32">
				<path
					d="M192 448c0-141.152 114.848-256 256-256s256 114.848 256 256-114.848 256-256 256-256-114.848-256-256z m710.624 409.376l-206.88-206.88A318.784 318.784 0 0 0 768 448c0-176.736-143.264-320-320-320S128 271.264 128 448s143.264 320 320 320a318.784 318.784 0 0 0 202.496-72.256l206.88 206.88 45.248-45.248z">
				</path>
			</svg>
		</div>
	</a>
	
	<a href="javaScript:void(0);" class="button" id="btn-toggle-dark">
		<div>
			<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none"
				stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
				<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
			</svg>
		</div>
	</a>
	<a href="javaScript:void(0);" class="dropdown-icon button">
		<div id="btn-dropdown">
			<svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 1024 1024" width="24" height="24" fill="currentColor"
				stroke="currentColor" stroke-width="32" stroke-linecap="round">
				<path
					d="M903.43 561.52H148.8c-13.25 0-24-10.75-24-24s10.75-24 24-24h754.63c13.25 0 24 10.75 24 24s-10.75 24-24 24zM903.43 204.31H148.8c-13.25 0-24-10.75-24-24s10.75-24 24-24h754.63c13.25 0 24 10.75 24 24s-10.75 24-24 24zM903.43 918.73H148.8c-13.25 0-24-10.75-24-24s10.75-24 24-24h754.63c13.25 0 24 10.75 24 24s-10.75 24-24 24z"
					fill="currentColor"></path>
			</svg>
		</div>
	</a>
	<div class="dropdown-menus" id="dropdown-menus">
		
		<a href="/" class="dropdown-menu button">首页</a>
		<br>
		
		<a href="/archives/" class="dropdown-menu button">归档</a>
		<br>
		
		<a href="/categories/" class="dropdown-menu button">分类</a>
		<br>
		
		<a href="/tags/" class="dropdown-menu button">标签</a>
		<br>
		
		<a href="/about/" class="dropdown-menu button">关于</a>
		<br>
		
	</div>
</div>

        </header>
        <div id="top"></div>
        <div id="page-main" class="main-content">
        <div class="mg-top">
            

<article class="page">
<div id="post-meta-m">
    <div class="post-meta" id="post-meta">
  <h3>常见八股问题</h3>
    
      <span class="post-meta-label">
        Big Ben
      </span>
    
    
      <span class="post-meta-label">
        <span class="p-dot"></span>
        <time datetime="2025-08-31 20:51" pubdate>
          2025-08-31
        </time>
      </span>
    
    
      
      <span class="post-meta">
        <span class="p-dot"></span>
        共 9.1k 字
      </span>
    
    
    
  </div>
  
</div>
<div class="article-m">
  <div class="post-toc">
    
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E"><span class="toc-number">1.</span> <span class="toc-text"> 说明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cc"><span class="toc-number">2.</span> <span class="toc-text"> C&#x2F;C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E5%85%B3%E4%BA%8E%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">2.1.</span> <span class="toc-text"> 1.关于指针和数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F"><span class="toc-number">2.2.</span> <span class="toc-text"> 2.常量指针和指针常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3vector%E4%B8%8B%E7%9A%84resize%E5%92%8Creserve%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.3.</span> <span class="toc-text"> 3.Vector下的Resize和Reserve的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E6%8C%87%E9%92%88%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">2.4.</span> <span class="toc-text"> 4.指针的大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5strlen%E5%92%8Csizeof%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.5.</span> <span class="toc-text"> 5.strlen和sizeof的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6c%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">2.6.</span> <span class="toc-text"> 6.C语言内存分配的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%81%94%E5%90%88%E4%BD%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.7.</span> <span class="toc-text"> 7.结构体和联合体的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E9%87%8E%E6%8C%87%E9%92%88%E5%92%8C%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-number">2.8.</span> <span class="toc-text"> 8.野指针和悬空指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.9.</span> <span class="toc-text"> 9.数组和链表的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E5%AE%8F%E5%87%BD%E6%95%B0%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">2.10.</span> <span class="toc-text"> 10.宏函数注意点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11include-%E5%92%8C-include-%E5%8C%BA%E5%88%AB"><span class="toc-number">2.11.</span> <span class="toc-text"> 11.#include &quot;&quot; 和 #include &lt;&gt; 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.12.</span> <span class="toc-text"> 12.全局变量和局部变量的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13define-typedef-const-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.13.</span> <span class="toc-text"> 13.#define、typedef、const 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14static-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.14.</span> <span class="toc-text"> 14.static 的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15memcpy-%E5%92%8C-strcpy-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%93%AA%E4%B8%AA%E5%AE%89%E5%85%A8"><span class="toc-number">2.15.</span> <span class="toc-text"> 15.memcpy 和 strcpy 的区别，哪个安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.16.</span> <span class="toc-text"> 16.堆和栈的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17malloc-%E5%92%8C-new-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.17.</span> <span class="toc-text"> 17.malloc 和 new 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18struct-%E5%92%8C-class-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.18.</span> <span class="toc-text"> 18.struct 和 class 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19c-%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">2.19.</span> <span class="toc-text"> 19.C++ 类的访问权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">2.20.</span> <span class="toc-text"> 20.内联函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21%E7%A8%8B%E5%BA%8F%E5%88%86%E4%B8%BA%E5%87%A0%E4%B8%AA%E6%AE%B5"><span class="toc-number">2.21.</span> <span class="toc-text"> 21.程序分为几个段？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22%E4%B8%80%E4%B8%AA-c-%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="toc-number">2.22.</span> <span class="toc-text"> 22.一个 .c 文件怎么转换为可执行程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E5%8F%96%E6%B6%88%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E6%96%B9%E6%B3%95%E4%BA%86%E8%A7%A3"><span class="toc-number">2.23.</span> <span class="toc-text"> 23.取消内存对齐的方法（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">2.24.</span> <span class="toc-text"> 24.什么是回调函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-number">2.25.</span> <span class="toc-text"> 25.面向对象的三大特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26%E4%BB%80%E4%B9%88%E6%98%AF%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88c-%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%9C%E7%94%A8%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">2.26.</span> <span class="toc-text"> 26.什么是智能指针，C++ 的智能指针有哪些，作用又是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.27.</span> <span class="toc-text"> 27.深拷贝和浅拷贝的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E8%AE%A1%E7%AE%97%E4%BD%99%E6%95%B0"><span class="toc-number">2.28.</span> <span class="toc-text"> 28.用位运算计算余数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">2.29.</span> <span class="toc-text"> 29. 什么是虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-vector-%E5%92%8C-list-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-number">2.30.</span> <span class="toc-text"> 30. vector 和 list 的使用场景与区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.31.</span> <span class="toc-text"> 31.静态链接和动态链接的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32extern-c-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.32.</span> <span class="toc-text"> 32.extern “C” 的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33c-%E8%AF%AD%E8%A8%80%E4%BD%8D%E5%9F%9Fbit-field"><span class="toc-number">2.33.</span> <span class="toc-text"> 33.C 语言位域（Bit-field）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.34.</span> <span class="toc-text"> 34.左值和右值的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.</span> <span class="toc-text"> 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%9A%E8%BF%87%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%88%A4%E6%96%AD%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">3.1.</span> <span class="toc-text"> 1. 二叉树通过中序遍历和后序遍历，判断前序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">3.2.</span> <span class="toc-text"> 2.常见的排序算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">3.3.</span> <span class="toc-text"> 3.什么是平衡二叉树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">4.</span> <span class="toc-text"> 计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1tcp-%E5%92%8C-udp-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.</span> <span class="toc-text"> 1.TCP 和 UDP 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2http-%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-number">4.2.</span> <span class="toc-text"> 2.HTTP 的发展史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3osi-%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B-%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.3.</span> <span class="toc-text"> 3.OSI 四层模型 &#x2F; 七层模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4tcp-%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">4.4.</span> <span class="toc-text"> 4.TCP 粘包和拆包问题，怎么解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B"><span class="toc-number">4.5.</span> <span class="toc-text"> 5. TCP 三次握手（连接建立）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE"><span class="toc-number">4.6.</span> <span class="toc-text"> 6. TCP 四次挥手（连接释放）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-dhcp-%E5%8D%8F%E8%AE%AEdynamic-host-configuration-protocol"><span class="toc-number">4.7.</span> <span class="toc-text"> 7. DHCP 协议（Dynamic Host Configuration Protocol）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8ip-%E5%9C%B0%E5%9D%80-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81-%E7%BD%91%E5%85%B3%E5%92%8C-dns-%E4%BD%9C%E7%94%A8"><span class="toc-number">4.8.</span> <span class="toc-text"> 8.IP 地址、子网掩码、网关和 DNS 作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E7%B1%BB%E5%9E%8B%E4%BA%86%E8%A7%A3"><span class="toc-number">4.9.</span> <span class="toc-text"> 9.常用的网络拓扑类型（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10tcp-%E9%80%9A%E4%BF%A1%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%80%9A%E4%BF%A1%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">4.10.</span> <span class="toc-text"> 10.TCP 通信如何保证通信的可靠性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.</span> <span class="toc-text"> 操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.</span> <span class="toc-text"> 1.进程、线程和协程的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text"> 2.进程间通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">5.3.</span> <span class="toc-text"> 3.线程间通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">5.4.</span> <span class="toc-text"> 4.进程间的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B-%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">5.5.</span> <span class="toc-text"> 5.僵尸进程、孤儿进程和守护进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8C%BA%E5%88%AB"><span class="toc-number">5.6.</span> <span class="toc-text"> 6.多进程和多线程的适用场景区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7fork-%E5%92%8C-vfork-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.7.</span> <span class="toc-text"> 7.fork 和 vfork 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E5%BD%93-for-%E5%BE%AA%E7%8E%AF%E9%81%87%E5%88%B0-fork-%E5%87%BD%E6%95%B0%E4%BA%86%E8%A7%A3"><span class="toc-number">5.8.</span> <span class="toc-text"> 8.当 for 循环遇到 fork 函数（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E8%AF%BB%E5%86%99%E9%94%81-%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.9.</span> <span class="toc-text"> 9.读写锁、自旋锁和互斥锁的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">5.10.</span> <span class="toc-text"> 10.什么是线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">5.11.</span> <span class="toc-text"> 11.什么是原子操作？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81"><span class="toc-number">5.12.</span> <span class="toc-text"> 12.什么是死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">5.13.</span> <span class="toc-text"> 13.什么是线程安全</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#linux"><span class="toc-number">6.</span> <span class="toc-text"> Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E4%BB%80%E4%B9%88%E6%98%AF%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">6.1.</span> <span class="toc-text"> 1.什么是系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2linux-%E9%A9%B1%E5%8A%A8%E7%9A%84%E4%B8%89%E5%A4%A7%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.2.</span> <span class="toc-text"> 2.Linux 驱动的三大类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3linux-%E5%92%8C-rtos-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.3.</span> <span class="toc-text"> 3.Linux 和 RTOS 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91"><span class="toc-number">6.4.</span> <span class="toc-text"> 4.什么是交叉编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-select-poll-epoll-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E7%94%A8%E5%A4%84"><span class="toc-number">6.5.</span> <span class="toc-text"> 5. select &#x2F; poll &#x2F; epoll 的区别与用处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6linux-%E5%86%85%E6%A0%B8%E7%94%B1%E5%93%AA%E4%BA%9B%E6%9E%84%E6%88%90"><span class="toc-number">6.6.</span> <span class="toc-text"> 6.Linux 内核由哪些构成？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">6.7.</span> <span class="toc-text"> 7.什么是根文件系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-number">6.8.</span> <span class="toc-text"> 8.什么是临界区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E5%A4%87%E6%A0%91"><span class="toc-number">6.9.</span> <span class="toc-text"> 9.什么是设备树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E4%B8%BA%E4%BB%80%E4%B9%88-linux-%E7%9A%84%E4%B8%AD%E6%96%AD%E5%88%86%E4%B8%BA%E4%B8%8A%E5%8D%8A%E9%83%A8%E5%88%86%E5%92%8C%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%88%86"><span class="toc-number">6.10.</span> <span class="toc-text"> 10.为什么 Linux 的中断分为上半部分和下半部分？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#stm32%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.</span> <span class="toc-text"> STM32&amp;&amp;通信协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1gpio-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">7.1.</span> <span class="toc-text"> 1.GPIO 工作模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E5%A4%A7%E5%B0%8F%E7%AB%AF%E7%9A%84%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">7.2.</span> <span class="toc-text"> 2.大小端的概念，以及提供一个例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3spi-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">7.3.</span> <span class="toc-text"> 3.SPI 的工作模式有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4rs232-%E5%92%8C-rs485-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.4.</span> <span class="toc-text"> 4.RS232 和 RS485 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E4%B8%BA%E4%BB%80%E4%B9%88-i2c-%E9%9C%80%E8%A6%81%E5%BC%80%E6%BC%8F%E8%BE%93%E5%87%BA-%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB"><span class="toc-number">7.5.</span> <span class="toc-text"> 5.为什么 I2C 需要开漏输出 + 上拉电阻</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6stm32-%E4%B8%8A%E7%94%B5%E5%90%8E%E5%88%B0-__main-%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">7.6.</span> <span class="toc-text"> 6.STM32 上电后到 __main 的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7msp-%E5%92%8C-psp-%E4%B8%A4%E4%B8%AA%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88%E9%83%BD%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8"><span class="toc-number">7.7.</span> <span class="toc-text"> 7.MSP 和 PSP 两个指针是什么，都在什么时候用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E4%B8%AD%E6%96%AD%E8%83%BD%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E5%92%8C%E5%8F%82%E6%95%B0%E5%90%97"><span class="toc-number">7.8.</span> <span class="toc-text"> 8.中断能有返回值和参数吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9arm-%E4%B8%AD%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">7.9.</span> <span class="toc-text"> 9.ARM 中的寄存器，都有什么用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10ram-rom-%E5%92%8C-flash-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.10.</span> <span class="toc-text"> 10.RAM、ROM 和 Flash 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11cache-%E6%98%AF%E4%BB%80%E4%B9%88cache-%E4%B8%80%E8%87%B4%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">7.11.</span> <span class="toc-text"> 11.Cache 是什么，Cache 一致性是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12cortex-m3-%E5%92%8C-cortex-m4-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.12.</span> <span class="toc-text"> 12.Cortex-M3 和 Cortex-M4 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E4%BB%80%E4%B9%88%E6%98%AF-smp%E4%BA%86%E8%A7%A3"><span class="toc-number">7.13.</span> <span class="toc-text"> 13.什么是 SMP（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%8D%E4%BD%BF%E7%94%A8-malloc-%E5%87%BD%E6%95%B0"><span class="toc-number">7.14.</span> <span class="toc-text"> 14.为什么单片机不使用 malloc 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E6%96%AD%E5%B5%8C%E5%A5%97"><span class="toc-number">7.15.</span> <span class="toc-text"> 15.什么是中断嵌套</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16can-%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">7.16.</span> <span class="toc-text"> 16.CAN 通信的缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17%E4%BB%80%E4%B9%88%E6%98%AF-io-%E5%8F%A3%E6%82%AC%E7%A9%BA%E5%8F%AF%E8%83%BD%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">7.17.</span> <span class="toc-text"> 17.什么是 IO 口悬空？可能带来哪些问题？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-flash-%E6%93%A6%E5%86%99%E5%AF%BF%E5%91%BD%E9%97%AE%E9%A2%98"><span class="toc-number">7.18.</span> <span class="toc-text"> 18.如何处理 Flash 擦写寿命问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E4%B8%AD%E6%96%AD%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.19.</span> <span class="toc-text"> 19.中断上下文和进程上下文的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20__attrubute__%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">7.20.</span> <span class="toc-text"> 20.__attrubute__有什么用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#freertos"><span class="toc-number">8.</span> <span class="toc-text"> FreeRTOS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1freertos-%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">8.1.</span> <span class="toc-text"> 1.FreeRTOS 中使用的调度算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2freertos-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E5%90%8C%E6%AD%A5"><span class="toc-number">8.2.</span> <span class="toc-text"> 2.FreeRTOS 如何实现任务同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3freertos-%E7%9A%84%E6%97%B6%E9%97%B4%E7%89%87%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">8.3.</span> <span class="toc-text"> 3.FreeRTOS 的时间片的大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4freertos-%E4%B8%AD%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">8.4.</span> <span class="toc-text"> 4.FreeRTOS 中任务的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5freertos-%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-number">8.5.</span> <span class="toc-text"> 5.FreeRTOS 创建任务的方法和区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6freertos-%E7%9A%84%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1%E4%BB%A5%E5%8F%8A%E5%AE%83%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">8.6.</span> <span class="toc-text"> 6.FreeRTOS 的空闲任务以及它的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7freertos-%E4%B8%AD%E7%9A%84-svc-systick-%E5%92%8C-pendsv-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-number">8.7.</span> <span class="toc-text"> 7.FreeRTOS 中的 SVC、SysTick 和 PendSV 的作用和区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8freertos-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-pendsv"><span class="toc-number">8.8.</span> <span class="toc-text"> 8.FreeRTOS 为什么要用 PendSV</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9freertos-%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6%E5%9D%97%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">8.9.</span> <span class="toc-text"> 9.FreeRTOS 中的任务控制块是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10freertos-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">8.10.</span> <span class="toc-text"> 10.FreeRTOS 如何实现任务切换，过程是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11freertos-%E6%9C%89%E5%93%AA%E4%B8%A4%E7%A7%8D%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%94%E7%A7%8D%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">8.11.</span> <span class="toc-text"> 11.FreeRTOS 有哪两种内存分配方式，有哪五种分配算法？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8-freertos-%E4%B8%AD%E4%BF%A1%E5%8F%B7%E9%87%8F-%E9%98%9F%E5%88%97%E7%AD%89%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%A4%E5%A5%97%E5%87%BD%E6%95%B0"><span class="toc-number">8.12.</span> <span class="toc-text"> 12.为什么在 FreeRTOS 中信号量、队列等设计了两套函数？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13vtaskdelay-%E5%92%8C-vtaskdelayuntil-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.13.</span> <span class="toc-text"> 13.vTaskDelay 和 vTaskDelayUntil 的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">9.</span> <span class="toc-text"> 其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E5%B8%B8%E7%94%A8%E7%9A%84%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BA%86%E8%A7%A3"><span class="toc-number">9.1.</span> <span class="toc-text"> 1.常用的调试方法有什么（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-gdb-%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E4%BA%86%E8%A7%A3"><span class="toc-number">9.2.</span> <span class="toc-text"> 2. gdb 常见命令（了解）</span></a></li></ol></li></ol>
    
  </div>
    <div id="article">
      <div id="post-content" class="markdown-body textretty">
        <h1 id="说明"><a class="markdownIt-Anchor" href="#说明"></a> 说明</h1>
<p>随缘更新，东西有点多，有问题跟我提，我再改。</p>
<h1 id="cc"><a class="markdownIt-Anchor" href="#cc"></a> C/C++</h1>
<h2 id="1关于指针和数组"><a class="markdownIt-Anchor" href="#1关于指针和数组"></a> 1.关于指针和数组</h2>
<p><strong>指针数组： int *arr[10];</strong></p>
<p>数组里的<strong>每个元素都是一个指针</strong>，arr是数组名，arr[i]是一个指针。</p>
<p><strong>数组指针： int (*p)[10];</strong></p>
<p><strong>一个指针，指向整个数组</strong></p>
<ul>
<li>
<p>a，类型int*，即首元素的指针</p>
</li>
<li>
<p><strong>&amp;a，类型int (*)[6]，即整个数组地址</strong></p>
</li>
<li>
<p>*a，等价于a[0] —&gt; *(a+i) = a[i]</p>
</li>
</ul>
<blockquote>
<p><strong>Q1：int a[6] = {1, 2, 3, 4, 5, 6};printf(“%d\n”, *(int *)(&amp;a + 1) - 1)的输出</strong></p>
<p>A：(&amp;a + 1)是a + 6， 这里的*(int *)没什么意义,*((int *)(&amp;a + 1) - 1)是a + 5，即6。</p>
</blockquote>
<blockquote>
<p><strong>Q2：char *buff[] = {“char”, “int”, “double”}; printf(“%c\n”, *(buff+1)[1])的输出</strong></p>
<p>A：(buff+1)是&quot;int&quot;，<strong>[]的优先级大于*</strong>，所以*(buff+1)[1]=*(buff+1+1)=*(buff+2)，取&quot;double&quot;的首元素&quot;d&quot;。</p>
</blockquote>
<h2 id="2常量指针和指针常量"><a class="markdownIt-Anchor" href="#2常量指针和指针常量"></a> 2.常量指针和指针常量</h2>
<p><strong>常量指针：const int *a; / int const *a;</strong></p>
<p><strong>底层Const</strong>，指针<strong>所指内容</strong>是常量，<strong>不能通过指针修改</strong>（但指针可以指向别处）</p>
<p><strong>指针常量：int *const a;</strong></p>
<p><strong>顶层Const</strong>，<strong>指针</strong>本身是常量，<strong>初始化后不能再指向别的地址</strong>。</p>
<h2 id="3vector下的resize和reserve的区别"><a class="markdownIt-Anchor" href="#3vector下的resize和reserve的区别"></a> 3.Vector下的Resize和Reserve的区别</h2>
<p><strong><code>resize(n)</code></strong>：改变大小，若变大则会构造新元素（对内置类型填充为 0，对类调用默认构造），可能导致 <strong>迭代器失效</strong>。</p>
<p><strong><code>reserve(n)</code></strong>：只调整容量，不改变元素数量；不会插入新元素，所以<strong>不会填充 0</strong>，只是预留空间；若实际扩容则 <strong>迭代器失效</strong>。</p>
<h2 id="4指针的大小"><a class="markdownIt-Anchor" href="#4指针的大小"></a> 4.指针的大小</h2>
<ul>
<li>32 位平台：指针大小通常 <strong>4 字节</strong>。</li>
<li>64 位平台：指针大小通常 <strong>8 字节</strong>。</li>
</ul>
<blockquote>
<p>不管 <code>int*</code>、<code>char*</code>、<code>double*</code>，指针大小都一样。</p>
</blockquote>
<h2 id="5strlen和sizeof的区别"><a class="markdownIt-Anchor" href="#5strlen和sizeof的区别"></a> 5.strlen和sizeof的区别</h2>
<p><strong><code>strlen(s)</code></strong>：计算 <strong>字符串内容长度</strong>（遇到 <code>\0</code> 停止，不含 <code>\0</code>），需在运行时遍历。</p>
<p><strong><code>sizeof(x)</code></strong>：计算 <strong>对象/类型所占内存字节数</strong>，在编译期确定（数组包含 <code>\0</code>）。</p>
<blockquote>
<p><strong>区别</strong>：<code>strlen</code> 得到“内容长度”，<code>sizeof</code> 得到“占用空间”。</p>
<p>x[]数组的大小：sizeof(x) / sizeof(x[0])</p>
</blockquote>
<h2 id="6c语言内存分配的方式"><a class="markdownIt-Anchor" href="#6c语言内存分配的方式"></a> 6.C语言内存分配的方式</h2>
<ul>
<li>
<p><strong>静态存储区</strong>：全局变量、静态变量，程序运行期间始终存在。</p>
</li>
<li>
<p><strong>栈（Stack）</strong>：局部变量、函数参数，由编译器自动分配/释放。</p>
</li>
<li>
<p><strong>堆（Heap）</strong>：动态内存（<code>malloc/free</code>、<code>calloc</code>、<code>realloc</code>），由程序员手动管理</p>
</li>
</ul>
<h2 id="7结构体和联合体的区别"><a class="markdownIt-Anchor" href="#7结构体和联合体的区别"></a> 7.结构体和联合体的区别</h2>
<p><strong>结构体 (struct)</strong>：成员 <strong>独立存储</strong>，总大小 ≥ 成员之和，受 <strong>内存对齐</strong> 影响。</p>
<p><strong>联合体 (union)</strong>：所有成员 <strong>共用同一块内存</strong>，大小 = 最大成员大小，整体大小也需按 <strong>最大成员的对齐要求</strong> 对齐。</p>
<blockquote>
<p><strong>Q1：下面这个的输出是多少？</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> c[<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> S));</span><br></pre></td></tr></table></figure>
<p>A：结果是12 Byte，对齐int类型</p>
<p><strong>Q2：如何用联合体来判断大小端？</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">U</span> &#123;</span></span><br><span class="line"> <span class="type">int</span>  i;</span><br><span class="line"> <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="class"><span class="keyword">union</span> <span class="title">U</span> <span class="title">u</span>;</span></span><br><span class="line"> u.i = <span class="number">0x1234</span>;</span><br><span class="line"> <span class="keyword">if</span> (u.c == <span class="number">0x34</span>)         </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;小端\n&quot;</span>); <span class="comment">// 低地址存低字节</span></span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;大端\n&quot;</span>); <span class="comment">// 低地址存高字节</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="8野指针和悬空指针"><a class="markdownIt-Anchor" href="#8野指针和悬空指针"></a> 8.野指针和悬空指针</h2>
<ul>
<li><strong>野指针</strong>：<strong>未初始化或指向不可知区域的指针</strong>。</li>
<li><strong>悬空指针</strong>：<strong>指向的内存已释放</strong>/失效，<strong>但没有置<code>NULL</code></strong>，仍被使用。</li>
</ul>
<blockquote>
<p><strong>避免方法</strong>：指针初始化为 <code>NULL</code>；释放后及时置为 <code>NULL</code>。</p>
</blockquote>
<h2 id="9数组和链表的区别"><a class="markdownIt-Anchor" href="#9数组和链表的区别"></a> 9.数组和链表的区别</h2>
<ul>
<li><strong>数组</strong>：<strong>连续内存</strong>，存储的是同一类型数据，<strong>支持随机访问，插入/删除效率低</strong>。</li>
<li><strong>链表</strong>：<strong>离散内存</strong>，<strong>插入/删除效率高，查找效率低</strong>。</li>
</ul>
<blockquote>
<p><strong>使用场景</strong>：查询多 → 数组；插入删除多 → 链表。</p>
</blockquote>
<h2 id="10宏函数注意点"><a class="markdownIt-Anchor" href="#10宏函数注意点"></a> 10.宏函数注意点</h2>
<ul>
<li>宏函数通过 <code>#define</code> 定义，<strong>预处理阶段替换</strong>，<strong>无类型检查</strong>。</li>
<li><strong>缺点</strong>：可能重复计算参数，调试困难。</li>
<li><strong>改进</strong>：参数和表达式用括号保护，推荐使用 <strong>内联函数</strong> 替代。</li>
</ul>
<h2 id="11include-和-include-区别"><a class="markdownIt-Anchor" href="#11include-和-include-区别"></a> 11.<code>#include &quot;&quot;</code> 和 <code>#include &lt;&gt;</code> 区别</h2>
<ul>
<li><strong><code>#include &quot;&quot;</code></strong>：先从<strong>当前目录</strong>查找，再去<strong>系统目录</strong>查找。</li>
<li><strong><code>#include &lt;&gt;</code></strong>：只从<strong>系统目录</strong>查找。</li>
</ul>
<h2 id="12全局变量和局部变量的区别"><a class="markdownIt-Anchor" href="#12全局变量和局部变量的区别"></a> 12.全局变量和局部变量的区别</h2>
<ul>
<li><strong>全局变量</strong>：定义在函数外，作用域是整个文件或程序，<strong>存储在静态区</strong>。</li>
<li><strong>局部变量</strong>：定义在函数/代码块内，<strong>存储在栈</strong>，作用域仅在定义范围内。</li>
</ul>
<h2 id="13define-typedef-const-的区别"><a class="markdownIt-Anchor" href="#13define-typedef-const-的区别"></a> 13.<code>#define</code>、<code>typedef</code>、<code>const</code> 的区别</h2>
<ul>
<li><strong><code>#define</code></strong>：预处理宏替换，<strong>无类型检查</strong>。</li>
<li><strong><code>typedef</code></strong>：<strong>给类型取别名</strong>，<strong>有类型检查</strong>。</li>
<li><strong><code>const</code></strong>：定义常量，编译器<strong>检查类型</strong>，<strong>分配内存</strong>。</li>
</ul>
<blockquote>
<p>建议：常量用 <code>const</code>，类型别名用 <code>typedef</code>/<code>using</code>，少用 <code>#define</code>。</p>
</blockquote>
<h2 id="14static-的作用"><a class="markdownIt-Anchor" href="#14static-的作用"></a> 14.static 的作用</h2>
<ul>
<li>
<p><strong>在 C 中</strong>：</p>
<ul>
<li>局部静态变量：存储在<strong>静态存储区</strong>，函数结束不销毁。</li>
<li>全局静态变量：存储在<strong>静态存储区</strong>，仅在本文件可见。</li>
<li>静态函数：<strong>仅在本文件内可见</strong>。</li>
</ul>
</li>
<li>
<p><strong>在 C++ 中</strong>：</p>
<p><strong>类里</strong></p>
<ul>
<li><strong>静态成员变量</strong>：属于类本身，<strong>所有对象共享一份</strong>，不随对象创建/销毁而改变。</li>
<li><strong>静态成员函数</strong>：不依赖具体对象，只能访问类的静态成员（不能访问 this）。</li>
</ul>
</li>
</ul>
<h2 id="15memcpy-和-strcpy-的区别哪个安全"><a class="markdownIt-Anchor" href="#15memcpy-和-strcpy-的区别哪个安全"></a> 15.memcpy 和 strcpy 的区别，哪个安全？</h2>
<ul>
<li><strong><code>memcpy</code></strong>：按字节拷贝，适合任意类型数据（需指定长度）。</li>
<li><strong><code>strcpy</code></strong>：拷贝字符串，遇到 <code>\0</code> 停止，需保证目标空间足够大。</li>
<li><strong>安全性</strong>：<code>memcpy</code> 更通用更安全；<code>strcpy</code> 可能造成溢出，推荐用 <code>strncpy</code>。</li>
</ul>
<h2 id="16堆和栈的区别"><a class="markdownIt-Anchor" href="#16堆和栈的区别"></a> 16.堆和栈的区别</h2>
<ul>
<li><strong>栈（Stack）</strong>：<strong>系统自动分配/释放</strong>，空间小，效率高。</li>
<li><strong>堆（Heap）</strong>：<strong>自己手动申请/释放</strong>，空间大，效率低。</li>
</ul>
<blockquote>
<p>常见问题：堆使用不当可能导致 <strong>内存泄漏</strong>。</p>
</blockquote>
<h2 id="17malloc-和-new-的区别"><a class="markdownIt-Anchor" href="#17malloc-和-new-的区别"></a> 17.malloc 和 new 的区别</h2>
<ul>
<li><strong>malloc</strong>（C语言库函数）：分配内存，返回 <code>void*</code>，需手动 <code>free</code>。<strong>不会调用构造函数</strong>。</li>
<li><strong>new</strong>（C++ 运算符）：分配内存并调用构造函数，失败抛出异常 <code>bad_alloc</code>，需用 <code>delete</code> 释放。</li>
</ul>
<h2 id="18struct-和-class-的区别"><a class="markdownIt-Anchor" href="#18struct-和-class-的区别"></a> 18.struct 和 class 的区别</h2>
<ul>
<li><strong>在 C++ 中</strong>：
<ul>
<li><code>struct</code> 默认成员权限是 <strong>public</strong>。</li>
<li><code>class</code> 默认成员权限是 <strong>private</strong>。</li>
</ul>
</li>
<li>除此之外，两者在功能上基本相同。</li>
</ul>
<h2 id="19c-类的访问权限"><a class="markdownIt-Anchor" href="#19c-类的访问权限"></a> 19.C++ 类的访问权限</h2>
<ul>
<li><strong>public</strong>：对所有代码可见。</li>
<li><strong>protected</strong>：仅类本身和派生类可见。</li>
<li><strong>private</strong>：仅类本身可见。</li>
</ul>
<h2 id="20内联函数"><a class="markdownIt-Anchor" href="#20内联函数"></a> 20.内联函数</h2>
<ul>
<li>用 <code>inline</code> 修饰，编译时用函数体替换调用处，<strong>减少函数调用开销</strong>。</li>
<li><strong>注意</strong>：
<ul>
<li>仅是建议，编译器可能忽略。</li>
<li>递归、函数过大时不适合。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>弊端</strong>：</p>
<ul>
<li>代码被展开，会导致 <strong>二进制体积增大</strong>（代码膨胀）。</li>
<li>修改后需重新编译所有调用处，<strong>编译依赖增加</strong>。</li>
<li>频繁内联反而可能 <strong>影响指令缓存性能</strong>。</li>
</ul>
</blockquote>
<h2 id="21程序分为几个段"><a class="markdownIt-Anchor" href="#21程序分为几个段"></a> 21.程序分为几个段？</h2>
<p>典型的 C/C++ 程序在内存中分为：</p>
<ul>
<li><strong>代码段（text）</strong>：存放程序代码。</li>
<li><strong>数据段（data）</strong>：存放已初始化的全局变量、静态变量。</li>
<li><strong>BSS 段</strong>：存放未初始化的全局变量、静态变量。</li>
<li><strong>堆（heap）</strong>：动态分配的内存。</li>
<li><strong>共享内存段</strong>：静态变量</li>
<li><strong>栈（stack）</strong>：局部变量、函数参数。</li>
</ul>
<h2 id="22一个-c-文件怎么转换为可执行程序"><a class="markdownIt-Anchor" href="#22一个-c-文件怎么转换为可执行程序"></a> 22.一个 .c 文件怎么转换为可执行程序</h2>
<ol>
<li><strong>预处理</strong>：宏展开、头文件展开，生成 <code>.i</code> 文件。</li>
<li><strong>编译</strong>：把预处理结果转为汇编代码 <code>.s</code>。</li>
<li><strong>汇编</strong>：汇编器将 <code>.s</code> 转为机器码 <code>.o</code>。</li>
<li><strong>链接</strong>：把多个目标文件和库链接成可执行文件。</li>
</ol>
<h2 id="23取消内存对齐的方法了解"><a class="markdownIt-Anchor" href="#23取消内存对齐的方法了解"></a> 23.取消内存对齐的方法（了解）</h2>
<ul>
<li><strong>GCC</strong>：<code>__attribute__((packed))</code></li>
<li><strong>MSVC</strong>：<code>#pragma pack(1)</code></li>
</ul>
<h2 id="24什么是回调函数"><a class="markdownIt-Anchor" href="#24什么是回调函数"></a> 24.什么是回调函数</h2>
<ul>
<li>一个<strong>函数作为参数传递</strong>给另一个函数，被在特定时机调用。</li>
<li>常用于 <strong>事件驱动</strong>、<strong>异步处理</strong>。</li>
</ul>
<h2 id="25面向对象的三大特征"><a class="markdownIt-Anchor" href="#25面向对象的三大特征"></a> 25.面向对象的三大特征</h2>
<ul>
<li>
<p><strong>封装</strong></p>
<ul>
<li><strong>概念</strong>：把数据和操作打包在类里，隐藏实现细节，对外只暴露必要接口。</li>
<li><strong>C++ 实现</strong>：<code>class</code> / <code>struct</code> + <strong>访问控制符</strong>（<code>public</code>、<code>protected</code>、<code>private</code>）。</li>
<li><strong>作用</strong>：提高模块化与安全性，防止随意修改内部数据。</li>
</ul>
</li>
<li>
<p><strong>继承</strong></p>
<ul>
<li><strong>概念</strong>：子类自动获得父类已有的成员与方法，可以复用或扩展。</li>
<li><strong>C++ 实现</strong>：<code>class Derived : public Base &#123; ... &#125;;</code></li>
<li><strong>作用</strong>：代码复用，形成层次结构，支持多级继承。</li>
</ul>
</li>
<li>
<p><strong>多态</strong></p>
<ul>
<li>
<p><strong>概念</strong>：同一接口在不同对象上表现出不同的行为。</p>
</li>
<li>
<p><strong>C++ 实现</strong>：</p>
<ul>
<li><strong>编译期多态</strong>：函数重载、运算符重载（通过名字/参数列表区分）。</li>
<li><strong>运行期多态</strong>：虚函数 + 基类指针/引用调用派生类实现（依赖 <code>virtual</code> 关键字 + 动态绑定）。</li>
</ul>
</li>
<li>
<p><strong>作用</strong>：提高灵活性，便于扩展。</p>
</li>
</ul>
</li>
</ul>
<h2 id="26什么是智能指针c-的智能指针有哪些作用又是什么"><a class="markdownIt-Anchor" href="#26什么是智能指针c-的智能指针有哪些作用又是什么"></a> 26.什么是智能指针，C++ 的智能指针有哪些，作用又是什么</h2>
<ul>
<li><strong>作用</strong>：自动管理内存，避免<code>new/delete</code> 手工管理带来的内存泄漏。</li>
<li><strong>C++ 智能指针</strong>：
<ul>
<li><code>std::auto_ptr</code>（C++11 废弃）。</li>
<li><code>std::unique_ptr</code>：独占所有权→ 同一时间<strong>只能有一个指针指向资源</strong>，不能拷贝，只能移动。</li>
<li><code>std::shared_ptr</code>：引用计数共享所有权 → <strong>多个指针可以同时指向资源</strong>，内部用 <strong>引用计数</strong> 管理，最后一个销毁时释放内存。</li>
<li><code>std::weak_ptr</code>：弱引用 → 不增加引用计数，用来观察 <code>shared_ptr</code> 管理的对象，解决循环引用问题。</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>这里的<strong>所有权 (ownership)</strong> 指 <strong>谁负责在对象生命周期结束时释放内存</strong>。</li>
</ul>
<p><strong>Q：为什么auto_ptr会被废弃？</strong></p>
<ul>
<li><code>auto_ptr</code> 拷贝/赋值时，会把所有权转移（源指针变空）。</li>
<li>容易导致意外失效，比如容器里的元素被拷贝后全部失效。</li>
</ul>
</blockquote>
<h2 id="27深拷贝和浅拷贝的区别"><a class="markdownIt-Anchor" href="#27深拷贝和浅拷贝的区别"></a> 27.深拷贝和浅拷贝的区别</h2>
<ul>
<li><strong>浅拷贝</strong>：复制指针，<strong>不复制实际资源</strong> → <strong>多个指针对象指向同一块内存</strong>。</li>
<li><strong>深拷贝</strong>：复制内容，<strong>独立资源</strong> → 避免内存释放冲突。</li>
</ul>
<h2 id="28用位运算计算余数"><a class="markdownIt-Anchor" href="#28用位运算计算余数"></a> 28.用位运算计算余数</h2>
<ul>
<li><strong>对 2 的幂取余</strong>：<code>x % (2^n) == x &amp; (2^n - 1)</code></li>
</ul>
<blockquote>
<p>例：<code>13 % 8 == 13 &amp; 7 == 5</code>。</p>
</blockquote>
<h2 id="29-什么是虚函数"><a class="markdownIt-Anchor" href="#29-什么是虚函数"></a> 29. 什么是虚函数</h2>
<ul>
<li><strong>定义</strong>：用 <code>virtual</code> 修饰的成员函数；用于<strong>运行时多态</strong>（动态绑定）。</li>
<li><strong>机制（实现惯例）</strong>：每个多态对象含一根 <strong>vptr</strong> 指针指向 <strong>vtable</strong>；通过 vtable 在运行时决定调用哪个函数实现。</li>
</ul>
<h2 id="30-vector-和-list-的使用场景与区别"><a class="markdownIt-Anchor" href="#30-vector-和-list-的使用场景与区别"></a> 30. vector 和 list 的使用场景与区别</h2>
<ul>
<li><strong>vector</strong>
<ul>
<li>底层实现：<strong>动态数组</strong>，元素<strong>连续</strong>存储。</li>
<li><strong>优势</strong>：支持 <strong>随机访问 O(1)</strong>，缓存友好，遍历效率高。</li>
<li><strong>劣势</strong>：中间插入/删除需要移动大量元素，效率低。</li>
<li><strong>适用场景</strong>：查询、顺序访问多，增删少。</li>
</ul>
</li>
<li><strong>list</strong>
<ul>
<li>底层实现：<strong>双向链表</strong>，元素<strong>分散</strong>存储。</li>
<li><strong>优势</strong>：<strong>插入/删除 O(1)</strong>（已知位置时），不会移动其他元素。</li>
<li><strong>劣势</strong>：不支持随机访问，只能顺序遍历；节点额外指针开销大，缓存不友好。</li>
<li><strong>适用场景</strong>：需要频繁在中间插入、删除。</li>
</ul>
</li>
</ul>
<h2 id="31静态链接和动态链接的区别"><a class="markdownIt-Anchor" href="#31静态链接和动态链接的区别"></a> 31.静态链接和动态链接的区别</h2>
<ul>
<li><strong>静态链接</strong>：<strong>库函数编译时直接打包进可执行文件</strong>。
<ul>
<li>优点：独立运行；</li>
<li>缺点：体积大，更新麻烦。</li>
</ul>
</li>
<li><strong>动态链接</strong>：<strong>运行时加载共享库</strong>。
<ul>
<li>优点：节省空间，易更新；</li>
<li>缺点：依赖库文件。</li>
</ul>
</li>
</ul>
<h2 id="32extern-c-的作用"><a class="markdownIt-Anchor" href="#32extern-c-的作用"></a> 32.extern “C” 的作用</h2>
<ul>
<li>用于 C++ 中：告诉编译器按 <strong>C 语言方式</strong> 编译函数。</li>
<li>作用：避免 C++ 的 <strong>函数名修饰 (name mangling)</strong>，便于与 C 代码或库兼容。</li>
</ul>
<h2 id="33c-语言位域bit-field"><a class="markdownIt-Anchor" href="#33c-语言位域bit-field"></a> 33.C 语言位域（Bit-field）</h2>
<ul>
<li><strong>定义</strong>：在 <code>struct</code> 中，用指定位数存放成员，节省空间。</li>
<li><strong>用途</strong>：常用于 <strong>硬件寄存器映射</strong>、<strong>标志位集合</strong>。</li>
<li><strong>注意</strong>：位域排布依赖编译器/平台，移植性差。</li>
</ul>
<blockquote>
<p><strong>示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Flags</span> &#123;</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> a : <span class="number">1</span>;  <span class="comment">// 1 bit</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> b : <span class="number">3</span>;  <span class="comment">// 3 bit</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> c : <span class="number">4</span>;  <span class="comment">// 4 bit</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="34左值和右值的区别"><a class="markdownIt-Anchor" href="#34左值和右值的区别"></a> 34.左值和右值的区别</h2>
<ul>
<li><strong>左值 (lvalue)</strong>：表示一块<strong>可寻址的内存</strong>，可以出现在赋值符号左边。
<ul>
<li>例：变量名 <code>a</code>，数组元素 <code>arr[2]</code>，解引用 <code>*p</code>。</li>
</ul>
</li>
<li><strong>右值 (rvalue)</strong>：表示 <strong>临时值、常量、表达式结果</strong>，生命周期短，<strong>不能单独取地址</strong>。
<ul>
<li>例：常量 <code>10</code>，表达式 <code>a+b</code>。</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>
<p>C++ 扩展（右值细分）</p>
<ul>
<li><strong>纯右值 (prvalue)</strong>：字面量、临时对象。</li>
<li><strong>将亡值 (xvalue)</strong>：可被“偷资源”的临时对象（支持移动语义）。</li>
</ul>
</li>
</ul>
<p>✅ 一句话记忆：</p>
<ul>
<li>
<p><strong>左值</strong>：有名字、有地址、能长期存在。</p>
</li>
<li>
<p><strong>右值</strong>：没名字、临时用完就丢。</p>
</li>
</ul>
<p>📌 常见易混例子</p>
<ul>
<li><code>i++</code> → <strong>右值</strong>（返回旧值的临时量，不能赋值）。</li>
<li><code>++i</code> → <strong>左值</strong>（返回自增后的变量本身，可继续赋值）。</li>
<li><code>arr[0]</code> → <strong>左值</strong>（数组元素，可寻址）。</li>
<li><code>a+b</code> → <strong>右值</strong>（表达式结果，临时）</li>
</ul>
</blockquote>
<h1 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h1>
<h2 id="1-二叉树通过中序遍历和后序遍历判断前序遍历"><a class="markdownIt-Anchor" href="#1-二叉树通过中序遍历和后序遍历判断前序遍历"></a> 1. 二叉树通过中序遍历和后序遍历，判断前序遍历</h2>
<p><strong>前序遍历：中左右；中序遍历：左中右；后序遍历：左右中。</strong></p>
<p><strong>例子</strong></p>
<ul>
<li>中序：<code>D B E A F C</code></li>
<li>后序：<code>D E B F C A</code></li>
</ul>
<p><strong>推导过程</strong></p>
<ol>
<li><strong>后序末尾 = A</strong> → 整棵树根。
<ul>
<li>在中序里，<code>A</code> 左边是 <code>D B E</code>，右边是 <code>F C</code>。</li>
</ul>
</li>
<li><strong>左子树 = <code>D B E</code></strong>
<ul>
<li>在对应后序子序列 <code>D E B</code>，末尾 <code>B</code> 是根。</li>
<li>在中序 <code>D B E</code> 中，<code>B</code> 左边是 <code>D</code>，右边是 <code>E</code>。</li>
<li>→ 左子树前序 = <code>B D E</code>。</li>
</ul>
</li>
<li><strong>右子树 = <code>F C</code></strong>
<ul>
<li>在对应后序子序列 <code>F C</code>，末尾 <code>C</code> 是根。</li>
<li>在中序 <code>F C</code> 中，<code>C</code> 左边是 <code>F</code>，右边为空。</li>
<li>→ 右子树前序 = <code>C F</code>。</li>
</ul>
</li>
<li><strong>拼接前序</strong>
<ul>
<li>根 <code>A</code> + 左子树 <code>B D E</code> + 右子树 <code>C F</code></li>
<li>→ <strong>前序 = A B D E C F</strong>。</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>后序定根，中序分左右，递归拼前序</strong>。</p>
</blockquote>
<h2 id="2常见的排序算法"><a class="markdownIt-Anchor" href="#2常见的排序算法"></a> 2.常见的排序算法</h2>
<ul>
<li>
<p><strong>冒泡排序：</strong> 相邻元素两两比较，大的往后移，循环多次把最大值“冒”到最后。</p>
</li>
<li>
<p><strong>插入排序：</strong> 前面保持有序序列，取下一个元素，按大小插入到合适位置。</p>
</li>
<li>
<p><strong>选择排序：</strong> 每一轮从未排序区选择最小（或最大）的，与当前位置元素交换。</p>
</li>
<li>
<p><strong>快速排序：</strong> 取一个基准值，把小于的放左边，大于的放右边，然后递归分区排序。</p>
</li>
<li>
<p><strong>归并排序：</strong> 不断二分数组，递归到底后再逐层合并两个有序序列（需辅助数组）。</p>
</li>
<li>
<p><strong>基数排序：</strong> 按数位（个位、十位、百位…）依次排序，常用稳定排序作为子过程。</p>
</li>
<li>
<p><strong>希尔排序：</strong> 基于插入排序，先按较大间隔分组排序，再逐渐缩小间隔至 1。</p>
</li>
<li>
<p><strong>堆排序：</strong> 利用大顶堆/小顶堆，每次取堆顶元素放到末尾，再调整堆结构。</p>
</li>
<li>
<p><strong>计数排序：</strong> 统计每个元素出现次数，通过计数下标映射回输出（需额外数组）。</p>
</li>
<li>
<p><strong>桶排序：</strong> 按数值范围映射到不同桶内，每个桶独立排序，最后合并所有桶。</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2025/09/01/FE5rBgRM7qsvGCI.png" alt="" /></p>
<h2 id="3什么是平衡二叉树"><a class="markdownIt-Anchor" href="#3什么是平衡二叉树"></a> 3.什么是平衡二叉树</h2>
<ul>
<li>一种二叉搜索树，<strong>任意节点的左右子树高度差不超过 1</strong>。</li>
<li><strong>作用</strong>：保持查找、插入、删除的时间复杂度 O(log n)。</li>
<li><strong>典型实现</strong>：AVL 树、红黑树。</li>
</ul>
<h1 id="计算机网络"><a class="markdownIt-Anchor" href="#计算机网络"></a> 计算机网络</h1>
<h2 id="1tcp-和-udp-的区别"><a class="markdownIt-Anchor" href="#1tcp-和-udp-的区别"></a> 1.TCP 和 UDP 的区别</h2>
<ul>
<li><strong>TCP</strong>：面向连接，可靠传输，基于字节流的，速度慢。</li>
<li><strong>UDP</strong>：无连接，不可靠传输，速度快。</li>
</ul>
<h2 id="2http-的发展史"><a class="markdownIt-Anchor" href="#2http-的发展史"></a> 2.HTTP 的发展史</h2>
<ul>
<li><strong>HTTP/1.0</strong>：<strong>短连接</strong>，请求一次建立一次 TCP 连接。</li>
<li><strong>HTTP/1.1</strong>：默认<strong>长连接</strong>，支持流水线。</li>
<li><strong>HTTPS</strong>：HTTP + SSL/TLS，<strong>加密传输</strong>。</li>
<li><strong>HTTP/2.0</strong>：<strong>多路复用</strong>、头部压缩、<strong>二进制帧</strong>，用流的形式发送。</li>
<li><strong>HTTP/3.0</strong>：基于 <strong>QUIC 协议（UDP）</strong>，减少握手延迟。</li>
</ul>
<h2 id="3osi-四层模型-七层模型"><a class="markdownIt-Anchor" href="#3osi-四层模型-七层模型"></a> 3.OSI 四层模型 / 七层模型</h2>
<ul>
<li><strong>四层模型</strong>：应用层、传输层、网络层、网络接口层。</li>
<li><strong>七层模型</strong>：
<ul>
<li>应用层（HTTP、FTP、SMTP）</li>
<li>表示层（加密、压缩）</li>
<li>会话层（建立/管理会话）</li>
<li>传输层（TCP、UDP）</li>
<li>网络层（IP、ICMP）</li>
<li>数据链路层（ARP、PPP、以太网）</li>
<li>物理层（比特传输）</li>
</ul>
</li>
</ul>
<h2 id="4tcp-粘包和拆包问题怎么解决"><a class="markdownIt-Anchor" href="#4tcp-粘包和拆包问题怎么解决"></a> 4.TCP 粘包和拆包问题，怎么解决</h2>
<ul>
<li><strong>原因</strong>：TCP 是字节流协议，不保证消息边界 → 多个包合并或一个包被拆分。</li>
<li><strong>解决方法</strong>：
<ul>
<li>固定长度消息</li>
<li>使用分隔符</li>
<li>在消息头加长度字段</li>
<li>应用层协议处理（如 HTTP、MQTT）</li>
</ul>
</li>
</ul>
<h2 id="5-tcp-三次握手连接建立"><a class="markdownIt-Anchor" href="#5-tcp-三次握手连接建立"></a> 5. TCP 三次握手（连接建立）</h2>
<ol>
<li><strong>客户端 → 服务端</strong>：发送 <strong>SYN=1, seq=x</strong>
<ul>
<li>表示请求建立连接，并告知初始序列号 <code>x</code>。</li>
<li>客户端进入 <strong>SYN_SENT</strong> 状态。</li>
</ul>
</li>
<li><strong>服务端 → 客户端</strong>：发送 <strong>SYN=1, ACK=1, seq=y, ack=x+1</strong>
<ul>
<li>确认收到了客户端的 SYN，同时自己也发起连接请求。</li>
<li>服务端进入 <strong>SYN_RCVD</strong> 状态。</li>
</ul>
</li>
<li><strong>客户端 → 服务端</strong>：发送 <strong>ACK=1, ack=y+1</strong>
<ul>
<li>确认收到了服务端的 SYN。</li>
<li>客户端进入 <strong>ESTABLISHED</strong> 状态。</li>
<li>服务端收到 ACK 后，也进入 <strong>ESTABLISHED</strong>。</li>
</ul>
</li>
</ol>
<blockquote>
<p>👉 <strong>为什么三次？</strong></p>
<ul>
<li>防止已失效的连接请求报文突然到达而引起错误（历史 SYN 报文问题）。</li>
<li>双方要确认 <strong>对方的收发能力</strong>。</li>
</ul>
</blockquote>
<hr />
<h2 id="6-tcp-四次挥手连接释放"><a class="markdownIt-Anchor" href="#6-tcp-四次挥手连接释放"></a> 6. TCP 四次挥手（连接释放）</h2>
<ol>
<li><strong>客户端 → 服务端</strong>：发送 <strong>FIN=1, seq=u</strong>
<ul>
<li>表示“客户端已无数据要发”，请求关闭连接。</li>
<li>客户端进入 <strong>FIN_WAIT_1</strong> 状态。</li>
</ul>
</li>
<li><strong>服务端 → 客户端</strong>：发送 <strong>ACK=1, ack=u+1</strong>
<ul>
<li>确认收到了 FIN，但可能还有数据要发。</li>
<li>服务端进入 <strong>CLOSE_WAIT</strong> 状态；客户端进入 <strong>FIN_WAIT_2</strong>。</li>
</ul>
</li>
<li><strong>服务端 → 客户端</strong>：发送 <strong>FIN=1, seq=v</strong>
<ul>
<li>当服务端也没有数据要发时，主动关闭。</li>
<li>服务端进入 <strong>LAST_ACK</strong> 状态。</li>
</ul>
</li>
<li><strong>客户端 → 服务端</strong>：发送 <strong>ACK=1, ack=v+1</strong>
<ul>
<li>确认收到服务端的 FIN。</li>
<li>客户端进入 <strong>TIME_WAIT</strong>，等待 2MSL 确保最后 ACK 不丢失。</li>
<li>服务端收到 ACK 后进入 <strong>CLOSED</strong>，释放连接。</li>
</ul>
</li>
</ol>
<blockquote>
<p>👉 <strong>为什么要四次？</strong></p>
<ul>
<li>TCP 是全双工的，关闭要分成两个方向。</li>
<li>一方发送 FIN 表示“我这边没数据了”，但另一方可能还有数据要发 → 所以 ACK 和 FIN 分开发。</li>
</ul>
</blockquote>
<h2 id="7-dhcp-协议dynamic-host-configuration-protocol"><a class="markdownIt-Anchor" href="#7-dhcp-协议dynamic-host-configuration-protocol"></a> 7. DHCP 协议（Dynamic Host Configuration Protocol）</h2>
<ul>
<li><strong>作用</strong>：自动为主机分配网络参数（IP 地址、子网掩码、网关、DNS 等），避免手工配置。</li>
<li><strong>工作方式</strong>：基于 UDP，通常通过广播通信。</li>
</ul>
<p><strong>应用层</strong>：DHCP 协议本身（运行在客户端和服务器之间，分配网络参数）。</p>
<p><strong>传输层</strong>：使用 <strong>UDP</strong>（客户端端口 68，服务器端口 67）。</p>
<p><strong>网络层</strong>：依赖 IP（广播 255.255.255.255 或子网广播地址）。</p>
<p><strong>链路层</strong>：在第一次请求时，客户端可能还没有 IP，会用 <strong>MAC 地址</strong>标识自己。</p>
<h2 id="8ip-地址-子网掩码-网关和-dns-作用"><a class="markdownIt-Anchor" href="#8ip-地址-子网掩码-网关和-dns-作用"></a> 8.IP 地址、子网掩码、网关和 DNS 作用</h2>
<ul>
<li><strong>IP 地址</strong>：设备在网络中的唯一标识。</li>
<li><strong>子网掩码</strong>：划分网络号和主机号。
<ul>
<li><strong>网络号 = IP 地址 &amp; 子网掩码</strong></li>
<li><strong>主机号 = IP 地址 &amp; (子网掩码取反)</strong></li>
</ul>
</li>
<li><strong>网关</strong>：跨网络通信的出口。</li>
<li><strong>DNS</strong>：域名解析，将域名转换为 IP 地址。</li>
</ul>
<h2 id="9常用的网络拓扑类型了解"><a class="markdownIt-Anchor" href="#9常用的网络拓扑类型了解"></a> 9.常用的网络拓扑类型（了解）</h2>
<ul>
<li><strong>星型</strong>：所有节点通过中心设备连接，可靠但中心单点故障。</li>
<li><strong>总线型</strong>：共享一条总线，成本低但冲突多。</li>
<li><strong>环型</strong>：形成闭环，适合定时传输。</li>
<li><strong>树型</strong>：层次化管理。</li>
<li><strong>网状型</strong>：高可靠性，多路径冗余。</li>
</ul>
<h2 id="10tcp-通信如何保证通信的可靠性"><a class="markdownIt-Anchor" href="#10tcp-通信如何保证通信的可靠性"></a> 10.TCP 通信如何保证通信的可靠性</h2>
<ul>
<li><strong>确认应答机制</strong>（ACK）</li>
<li><strong>超时重传</strong></li>
<li><strong>滑动窗口</strong>（流量控制）</li>
<li><strong>拥塞控制</strong>（慢启动、拥塞避免、快速重传/恢复）</li>
<li><strong>有序性保证</strong>（序列号保证数据按顺序到达）</li>
</ul>
<h1 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统"></a> 操作系统</h1>
<h2 id="1进程-线程和协程的区别"><a class="markdownIt-Anchor" href="#1进程-线程和协程的区别"></a> 1.进程、线程和协程的区别</h2>
<ul>
<li><strong>进程</strong>：资源分配的最小单位。</li>
<li><strong>线程</strong>：CPU 调度的最小单位，<strong>共享进程资源</strong>。</li>
<li><strong>协程</strong>：用户态的轻量级线程，会主动让出 CPU，切换开销小。</li>
</ul>
<h2 id="2进程间通信方式"><a class="markdownIt-Anchor" href="#2进程间通信方式"></a> 2.进程间通信方式</h2>
<ul>
<li>管道（pipe）</li>
<li>消息队列</li>
<li>共享内存</li>
<li>信号量</li>
<li>信号（signal）</li>
<li>套接字（socket）</li>
</ul>
<h2 id="3线程间通信方式"><a class="markdownIt-Anchor" href="#3线程间通信方式"></a> 3.线程间通信方式</h2>
<ul>
<li><strong>共享内存</strong>（全局变量、堆内存）。</li>
<li><strong>同步机制</strong>：互斥锁、读写锁、信号量、条件变量。</li>
<li><strong>消息队列</strong>（用户实现，通常基于锁或无锁结构）。</li>
</ul>
<h2 id="4进程间的状态"><a class="markdownIt-Anchor" href="#4进程间的状态"></a> 4.进程间的状态</h2>
<ul>
<li><strong>新建（new）</strong>：进程创建中。</li>
<li><strong>就绪（ready）</strong>：等待 CPU 调度。</li>
<li><strong>运行（running）</strong>：占用 CPU 正在执行。</li>
<li><strong>阻塞（waiting）</strong>：等待 I/O 或事件。</li>
<li><strong>结束（terminated）</strong>：执行完成或被终止。</li>
</ul>
<h2 id="5僵尸进程-孤儿进程和守护进程"><a class="markdownIt-Anchor" href="#5僵尸进程-孤儿进程和守护进程"></a> 5.僵尸进程、孤儿进程和守护进程</h2>
<ul>
<li><strong>僵尸进程</strong>：子进程结束但父进程未回收（未调用 <code>wait</code>）。</li>
<li><strong>孤儿进程</strong>：父进程退出，子进程被 <code>init</code>/<code>systemd</code> 接管。</li>
<li><strong>守护进程</strong>：在后台运行、无终端控制的进程。</li>
</ul>
<h2 id="6多进程和多线程的适用场景区别"><a class="markdownIt-Anchor" href="#6多进程和多线程的适用场景区别"></a> 6.多进程和多线程的适用场景区别</h2>
<ul>
<li><strong>多进程</strong>：稳定性好，进程隔离，不易相互影响。适合多核 CPU、大规模并发服务。</li>
<li><strong>多线程</strong>：共享内存，切换开销小。适合计算密集型、轻量级并发。</li>
</ul>
<h2 id="7fork-和-vfork-的区别"><a class="markdownIt-Anchor" href="#7fork-和-vfork-的区别"></a> 7.fork 和 vfork 的区别</h2>
<ul>
<li><strong>fork</strong>：子进程复制父进程地址空间（写时拷贝），<strong>父子进程几乎独立</strong>。</li>
<li><strong>vfork</strong>：子进程与父进程<strong>共享地址空间</strong>，直到执行 <code>exec</code> 或 <code>exit</code>。效率更高，但风险更大。</li>
</ul>
<h2 id="8当-for-循环遇到-fork-函数了解"><a class="markdownIt-Anchor" href="#8当-for-循环遇到-fork-函数了解"></a> 8.当 for 循环遇到 fork 函数（了解）</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    fork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每次 <code>fork</code> 都会创建新进程，最终进程数为 <code>2^3 = 8</code>。</li>
</ul>
<h2 id="9读写锁-自旋锁和互斥锁的区别"><a class="markdownIt-Anchor" href="#9读写锁-自旋锁和互斥锁的区别"></a> 9.读写锁、自旋锁和互斥锁的区别</h2>
<ul>
<li><strong>互斥锁 (mutex)</strong>：一个任务独占，阻塞等待。</li>
<li><strong>自旋锁 (spinlock)</strong>：忙等，不释放 CPU，适合临界区很短的情况。</li>
<li><strong>读写锁 (rwlock)</strong>：允许多个读者，但写者独占，读多写少时效率高。</li>
</ul>
<h2 id="10什么是线程池"><a class="markdownIt-Anchor" href="#10什么是线程池"></a> 10.什么是线程池</h2>
<ul>
<li><strong>线程池</strong>：预先创建一定数量的线程，重复利用来执行任务。</li>
<li><strong>优点</strong>：减少频繁创建/销毁线程的开销，提高并发性能。</li>
<li><strong>典型应用</strong>：服务器请求处理。</li>
</ul>
<h2 id="11什么是原子操作"><a class="markdownIt-Anchor" href="#11什么是原子操作"></a> 11.什么是原子操作？</h2>
<ul>
<li><strong>不可分割的操作</strong>，执行过程不会被中断。</li>
<li><strong>特点</strong>：<strong>要么完全执行，要么完全不执行</strong>。</li>
<li>典型例子：加减计数、位操作。</li>
<li>实现方式：关中断、总线锁、CPU 提供的原子指令。</li>
</ul>
<h2 id="12什么是死锁"><a class="markdownIt-Anchor" href="#12什么是死锁"></a> 12.什么是死锁</h2>
<ul>
<li>多个进程/线程因争夺资源而相互等待，导致无法推进。</li>
<li><strong>产生条件（死锁四要素）</strong>：
<ul>
<li>互斥</li>
<li>占有且等待</li>
<li>不可剥夺</li>
<li>循环等待</li>
</ul>
</li>
</ul>
<h2 id="13什么是线程安全"><a class="markdownIt-Anchor" href="#13什么是线程安全"></a> 13.什么是线程安全</h2>
<ul>
<li>一个函数/代码段在多线程环境下被多个线程同时调用时，能保证结果正确。</li>
<li><strong>实现方法</strong>：加锁、原子操作、TLS（线程局部存储）。</li>
</ul>
<h1 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> Linux</h1>
<h2 id="1什么是系统调用"><a class="markdownIt-Anchor" href="#1什么是系统调用"></a> 1.什么是系统调用</h2>
<ul>
<li><strong>用户态进程向内核请求服务</strong>的接口。</li>
<li>通过软中断或陷阱指令进入内核。</li>
</ul>
<h2 id="2linux-驱动的三大类型"><a class="markdownIt-Anchor" href="#2linux-驱动的三大类型"></a> 2.Linux 驱动的三大类型</h2>
<ul>
<li><strong>字符设备驱动</strong>：顺序访问，按字节流操作，如串口。</li>
<li><strong>块设备驱动</strong>：以数据块为单位，如硬盘。</li>
<li><strong>网络设备驱动</strong>：面向数据包，如网卡。</li>
</ul>
<h2 id="3linux-和-rtos-的区别"><a class="markdownIt-Anchor" href="#3linux-和-rtos-的区别"></a> 3.Linux 和 RTOS 的区别</h2>
<ul>
<li><strong>Linux</strong>：通用操作系统，功能强大，调度非实时。</li>
<li><strong>RTOS</strong>：实时操作系统，保证任务实时性，资源占用小。</li>
</ul>
<h2 id="4什么是交叉编译"><a class="markdownIt-Anchor" href="#4什么是交叉编译"></a> 4.什么是交叉编译</h2>
<ul>
<li>在 <strong>一个平台</strong> 上编译生成 <strong>另一个平台</strong> 可运行的程序。</li>
<li>常见于嵌入式开发（如在 PC 上编译 ARM 设备的程序）。</li>
</ul>
<h2 id="5-select-poll-epoll-的区别与用处"><a class="markdownIt-Anchor" href="#5-select-poll-epoll-的区别与用处"></a> 5. select / poll / epoll 的区别与用处</h2>
<ul>
<li><strong>select</strong>
<ul>
<li>用 <strong>位图</strong> 保存 fd，最大支持数有限（通常 1024）。</li>
<li>每次调用都要 <strong>重新设置 fd 集合</strong>。</li>
<li>内核返回后还需遍历所有 fd，效率低。</li>
<li>适合 <strong>少量连接</strong>、简单场景。</li>
</ul>
</li>
<li><strong>poll</strong>
<ul>
<li>用 <strong>数组（链表形式）</strong> 保存 fd，<strong>没有数量限制</strong>。</li>
<li>每次调用仍需遍历所有 fd，效率依旧不高。</li>
<li>比 select 灵活，但高并发时性能差。</li>
</ul>
</li>
<li><strong>epoll</strong>
<ul>
<li>内核用 <strong>红黑树管理 fd</strong>，就绪 fd 放在 <strong>就绪队列</strong>。</li>
<li>用户只需处理“就绪的 fd”，无需遍历全部。</li>
<li>支持 <strong>LT（水平触发）</strong> 和 <strong>ET（边缘触发）</strong> 两种模式。</li>
<li>在 <strong>大规模并发连接</strong>（如服务器）场景下性能最好。</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>
<p>fd（File Descriptor，文件描述符）： 就是“内核给打开的文件/资源的编号”，程序靠它操作资源。</p>
</li>
<li>
<p>位图（Bitmap）：用一组 <strong>二进制位（bit）</strong> 来表示某些状态或资源是否存在/可用。</p>
</li>
</ul>
</blockquote>
<h2 id="6linux-内核由哪些构成"><a class="markdownIt-Anchor" href="#6linux-内核由哪些构成"></a> 6.Linux 内核由哪些构成？</h2>
<p>Linux 内核主要由以下几个部分组成：</p>
<ul>
<li><strong>进程管理</strong></li>
<li><strong>内存管理</strong></li>
<li><strong>文件系统</strong></li>
<li><strong>设备驱动</strong></li>
<li><strong>网络子系统</strong></li>
<li><strong>中断机制</strong></li>
<li><strong>系统调用接口</strong></li>
</ul>
<h2 id="7什么是根文件系统"><a class="markdownIt-Anchor" href="#7什么是根文件系统"></a> 7.什么是根文件系统</h2>
<ul>
<li>Linux 系统启动后挂载的第一个文件系统 <code>/</code>。</li>
<li>包含：驱动、库文件、系统命令、配置文件.</li>
</ul>
<h2 id="8什么是临界区"><a class="markdownIt-Anchor" href="#8什么是临界区"></a> 8.什么是临界区</h2>
<ul>
<li>多个线程/进程访问共享资源的代码区域。</li>
<li><strong>要求</strong>：在同一时刻只允许一个执行，通常用锁保护。</li>
</ul>
<h2 id="9什么是设备树"><a class="markdownIt-Anchor" href="#9什么是设备树"></a> 9.什么是设备树</h2>
<ul>
<li><strong>定义</strong>：一种 <strong>树状的数据结构</strong>，用文本/二进制文件（<code>.dts</code> / <code>.dtb</code>）描述硬件资源（CPU、内存、外设、中断等）。</li>
<li><strong>作用</strong>：
<ul>
<li>把硬件信息从内核代码中抽离 → <strong>内核与硬件解耦</strong>。</li>
<li>让同一个内核可以适配不同硬件平台，只需更换设备树文件，而无需重新编译内核</li>
</ul>
</li>
</ul>
<h2 id="10为什么-linux-的中断分为上半部分和下半部分"><a class="markdownIt-Anchor" href="#10为什么-linux-的中断分为上半部分和下半部分"></a> 10.为什么 Linux 的中断分为上半部分和下半部分？</h2>
<ul>
<li><strong>上半部分</strong>：快速处理中断（响应快），只做必要操作。</li>
<li><strong>下半部分</strong>：延迟处理耗时任务（软中断、tasklet、工作队列）。</li>
<li><strong>原因</strong>：缩短中断屏蔽时间，提高系统实时性。</li>
</ul>
<h1 id="stm32通信协议"><a class="markdownIt-Anchor" href="#stm32通信协议"></a> STM32&amp;&amp;通信协议</h1>
<h2 id="1gpio-工作模式"><a class="markdownIt-Anchor" href="#1gpio-工作模式"></a> 1.GPIO 工作模式</h2>
<ul>
<li><strong>输入模式</strong>：上拉输入、下拉输入、浮空输入、模拟输入</li>
<li><strong>输出模式</strong>：推挽输出、开漏输出</li>
<li><strong>复用功能</strong>：外设复用（USART、SPI 等）</li>
</ul>
<h2 id="2大小端的概念以及提供一个例子"><a class="markdownIt-Anchor" href="#2大小端的概念以及提供一个例子"></a> 2.大小端的概念，以及提供一个例子</h2>
<ul>
<li>
<p><strong>大端</strong>：高字节存储在低地址。</p>
</li>
<li>
<p><strong>小端</strong>：低字节存储在低地址。</p>
</li>
</ul>
<blockquote>
<p><strong>例子</strong>：<code>int a = 0x12345678;</code>（默认LSB优先）</p>
<ul>
<li>大端存储：<code>12 34 56 78</code></li>
<li>小端存储：<code>78 56 34 12</code></li>
</ul>
</blockquote>
<h2 id="3spi-的工作模式有哪些"><a class="markdownIt-Anchor" href="#3spi-的工作模式有哪些"></a> 3.SPI 的工作模式有哪些</h2>
<ul>
<li>
<p>由 <strong>CPOL（时钟极性）</strong> 和 <strong>CPHA（时钟相位）</strong> 决定，共 <strong>4 种模式</strong>：</p>
<p><strong>CPOL（Clock Polarity，时钟极性）</strong></p>
<ul>
<li>=0：时钟空闲时为 <strong>低电平</strong></li>
<li>=1：时钟空闲时为 <strong>高电平</strong></li>
</ul>
<p><strong>CPHA（Clock Phase，相位）</strong></p>
<ul>
<li>=0：<strong>第 1 个边沿采样</strong>（第一个有效边沿采样数据）</li>
<li>=1：<strong>第 2 个边沿采样</strong>（先在第一个边沿切换数据，第二个边沿采样）</li>
</ul>
</li>
<li>
<p>模式 0：CPOL=0, CPHA=0</p>
</li>
<li>
<p>模式 1：CPOL=0, CPHA=1</p>
</li>
<li>
<p>模式 2：CPOL=1, CPHA=0</p>
</li>
<li>
<p>模式 3：CPOL=1, CPHA=1</p>
</li>
</ul>
<h2 id="4rs232-和-rs485-的区别"><a class="markdownIt-Anchor" href="#4rs232-和-rs485-的区别"></a> 4.RS232 和 RS485 的区别</h2>
<ul>
<li><strong>RS232</strong>：
<ul>
<li>单端信号，<strong>点对点</strong>通信</li>
<li><strong>距离短</strong></li>
<li>抗干扰弱</li>
<li>逻辑“1”≈ −3V ~ −15V，逻辑“0”≈ +3V ~ +15V</li>
</ul>
</li>
<li><strong>RS485</strong>：
<ul>
<li>差分信号，支持多点总线</li>
<li><strong>距离远</strong></li>
<li>抗干扰强</li>
<li>A、B 线电压差 +2V~+6V 表示逻辑 1，−2V~−6V 表示逻辑 0</li>
</ul>
</li>
</ul>
<h2 id="5为什么-i2c-需要开漏输出-上拉电阻"><a class="markdownIt-Anchor" href="#5为什么-i2c-需要开漏输出-上拉电阻"></a> 5.为什么 I2C 需要开漏输出 + 上拉电阻</h2>
<ul>
<li><strong>开漏输出</strong>：只能拉低电平，不能输出高电平。</li>
<li><strong>上拉电阻</strong>：总线空闲时保持高电平，实现线与。</li>
<li><strong>原因</strong>：多个设备共享总线，避免总线冲突。</li>
</ul>
<h2 id="6stm32-上电后到-__main-的过程"><a class="markdownIt-Anchor" href="#6stm32-上电后到-__main-的过程"></a> 6.STM32 上电后到 <code>__main</code> 的过程</h2>
<ol>
<li><strong>硬件复位</strong></li>
</ol>
<ul>
<li>上电/复位后，Cortex-M 内核自动完成：
<ul>
<li>取向量表第 0 项 → <strong>Initial_SP</strong>，装入 MSP。</li>
<li>取向量表第 1 项 → <strong>Reset_Handler</strong> 地址，跳转执行。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>Reset_Handler</strong>（启动文件 <code>startup_xx.s</code> 中定义）</li>
</ol>
<ul>
<li>设置堆栈指针（MSP）、初始化中断向量表基址。</li>
<li>调用 <strong><code>SystemInit()</code></strong>：
<ul>
<li>配置系统时钟（HSE/PLL 等）。</li>
<li>配置 Flash 访问延时、总线分频。</li>
<li>初始化外设时钟（FPU、Cache、MPU 等）。</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>有的厂商库里叫 <strong><code>HardwareInit()</code> / <code>SystemClock_Config()</code></strong>，作用类似。</li>
</ul>
</blockquote>
<ol start="3">
<li><strong>C 运行时环境初始化</strong></li>
</ol>
<ul>
<li><strong>数据段初始化</strong>：将已初始化全局变量从 Flash 拷贝到 RAM。</li>
<li><strong>BSS 段清零</strong>：未初始化的全局/静态变量置 0。</li>
<li>可能还会初始化堆区指针。</li>
</ul>
<ol start="4">
<li><strong>调用 <code>__main</code></strong>（C 库入口函数）</li>
</ol>
<ul>
<li>进一步完成 C/C++ 环境初始化：
<ul>
<li>运行全局/静态对象的构造函数（C++）。</li>
<li>设置标准库需要的运行环境。</li>
</ul>
</li>
<li>最终调用 <code>main()</code>。</li>
</ul>
<h2 id="7msp-和-psp-两个指针是什么都在什么时候用"><a class="markdownIt-Anchor" href="#7msp-和-psp-两个指针是什么都在什么时候用"></a> 7.MSP 和 PSP 两个指针是什么，都在什么时候用</h2>
<ul>
<li><strong>MSP (Main Stack Pointer)</strong>：主堆栈指针，复位后默认使用，主要用于中断和异常。</li>
<li><strong>PSP (Process Stack Pointer)</strong>：进程堆栈指针，通常用于线程/任务。</li>
<li><strong>FreeRTOS</strong>：任务使用 PSP，内核/异常使用 MSP。</li>
</ul>
<h2 id="8中断能有返回值和参数吗"><a class="markdownIt-Anchor" href="#8中断能有返回值和参数吗"></a> 8.中断能有返回值和参数吗？</h2>
<ul>
<li><strong>不能</strong>：中断服务函数由硬件调用，没有返回值和参数。</li>
<li><strong>传参方法</strong>：使用全局变量、队列、消息通知等方式。</li>
</ul>
<h2 id="9arm-中的寄存器都有什么用"><a class="markdownIt-Anchor" href="#9arm-中的寄存器都有什么用"></a> 9.ARM 中的寄存器，都有什么用</h2>
<ul>
<li>
<p><strong>通用寄存器 (R0–R12)</strong></p>
<ul>
<li>临时存储、函数参数、返回值。</li>
<li>约定：
<ul>
<li><code>R0–R3</code>：函数参数 &amp; 返回值</li>
<li><code>R4–R11</code>：通常作为被调用者保存</li>
<li><code>R12 (IP)</code>：暂存寄存器</li>
</ul>
</li>
</ul>
<p><strong>SP (Stack Pointer, 栈指针)</strong></p>
<ul>
<li>指向当前栈顶。</li>
<li>分为：
<ul>
<li><strong>MSP (Main SP)</strong>：异常/中断、启动时使用</li>
<li><strong>PSP (Process SP)</strong>：线程模式任务栈（RTOS 常用）</li>
</ul>
</li>
</ul>
<p><strong>LR (Link Register, 链接寄存器)</strong></p>
<ul>
<li>保存函数返回地址。</li>
<li>在异常返回时，LR 含特殊值（如 <code>EXC_RETURN</code>），决定返回到线程/处理模式和使用 MSP/PSP。</li>
</ul>
<p><strong>PC (Program Counter, 程序计数器)</strong></p>
<ul>
<li>指向将要执行的下一条指令。</li>
<li>ARM 架构中一般是“取值 = 当前指令地址 + 偏移”。</li>
</ul>
<p><strong>xPSR (Program Status Register, 程序状态寄存器)</strong></p>
<ul>
<li>包含条件标志位 (N, Z, C, V)，执行状态，当前异常号等信息。</li>
</ul>
</li>
</ul>
<h2 id="10ram-rom-和-flash-的区别"><a class="markdownIt-Anchor" href="#10ram-rom-和-flash-的区别"></a> 10.RAM、ROM 和 Flash 的区别</h2>
<ul>
<li><strong>RAM</strong>（随机存取存储器）：读写速度快，断电数据丢失。</li>
<li><strong>ROM</strong>（只读存储器）：出厂时写入，通常不可修改。</li>
<li><strong>Flash</strong>：非易失存储，可擦写，常用于固件和数据存储。</li>
</ul>
<h2 id="11cache-是什么cache-一致性是什么"><a class="markdownIt-Anchor" href="#11cache-是什么cache-一致性是什么"></a> 11.Cache 是什么，Cache 一致性是什么</h2>
<ul>
<li><strong>Cache</strong>：CPU 与内存之间的高速缓存，加快数据访问速度。</li>
<li><strong>Cache 一致性</strong>：多核 CPU 或 DMA 等访问共享数据时，确保各个缓存的数据与主存一致。</li>
</ul>
<h2 id="12cortex-m3-和-cortex-m4-的区别"><a class="markdownIt-Anchor" href="#12cortex-m3-和-cortex-m4-的区别"></a> 12.Cortex-M3 和 Cortex-M4 的区别</h2>
<ul>
<li><strong>Cortex-M3</strong>：支持基本的 ARMv7-M 架构，32 位 RISC 内核，适合通用控制。</li>
<li><strong>Cortex-M4</strong>：在 M3 基础上增加 <strong>DSP 指令集</strong> 和 <strong>单精度浮点运算 (FPU)</strong>，适合信号处理。</li>
</ul>
<blockquote>
<p>M4 = M3 + DSP + 可选FPU</p>
</blockquote>
<h2 id="13什么是-smp了解"><a class="markdownIt-Anchor" href="#13什么是-smp了解"></a> 13.什么是 SMP（了解）</h2>
<ul>
<li><strong>SMP (Symmetric Multi-Processing，对称多处理)</strong>：多个 CPU 核心共享同一内存和 I/O，运行同一个操作系统。</li>
<li><strong>特点</strong>：负载均衡、可并行执行任务，常用于多核处理器系统。</li>
</ul>
<h2 id="14为什么单片机不使用-malloc-函数"><a class="markdownIt-Anchor" href="#14为什么单片机不使用-malloc-函数"></a> 14.为什么单片机不使用 malloc 函数</h2>
<ul>
<li>
<p><strong>资源限制</strong>：</p>
<ul>
<li>单片机 RAM 很小（几 KB ~ 几十 KB），<strong>动态分配容易造成内存碎片</strong>。</li>
</ul>
</li>
<li>
<p><strong>实时性要求</strong>：</p>
<ul>
<li><code>malloc/free</code> 的执行时间 <strong>不可预测</strong>，会破坏实时性。</li>
</ul>
</li>
<li>
<p><strong>可靠性问题</strong>：</p>
<ul>
<li>容易导致内存泄漏，调试困难，系统长期运行不稳定</li>
</ul>
</li>
</ul>
<h2 id="15什么是中断嵌套"><a class="markdownIt-Anchor" href="#15什么是中断嵌套"></a> 15.什么是中断嵌套</h2>
<p>在处理中断 A 时，允许更高优先级的中断 B 打断执行。</p>
<ul>
<li><strong>优点</strong>：提高实时性。</li>
<li><strong>缺点</strong>：过多嵌套可能导致栈溢出</li>
</ul>
<h2 id="16can-通信的缺点"><a class="markdownIt-Anchor" href="#16can-通信的缺点"></a> 16.CAN 通信的缺点</h2>
<ul>
<li>速率较低（典型 1Mbps）。</li>
<li>帧长度有限（8字节数据）。</li>
<li>总线型拓扑，节点过多易导致仲裁延迟。</li>
<li>无内置安全机制，易受干扰。</li>
</ul>
<h2 id="17什么是-io-口悬空可能带来哪些问题"><a class="markdownIt-Anchor" href="#17什么是-io-口悬空可能带来哪些问题"></a> 17.什么是 IO 口悬空？可能带来哪些问题？</h2>
<ul>
<li><strong>IO 悬空</strong>：输入引脚未接电路。</li>
<li><strong>问题</strong>：电平不确定，可能产生抖动、功耗增加、误触发。</li>
<li><strong>解决</strong>：加上拉或下拉电阻。</li>
</ul>
<h2 id="18如何处理-flash-擦写寿命问题"><a class="markdownIt-Anchor" href="#18如何处理-flash-擦写寿命问题"></a> 18.如何处理 Flash 擦写寿命问题</h2>
<ul>
<li><strong>磨损均衡 (Wear Leveling)</strong>：均匀分布写入次数。</li>
<li><strong>文件系统优化</strong>：使用专门的嵌入式文件系统（如 FATFS + WL）。</li>
<li><strong>缓存/批量写入</strong>：减少频繁擦写。</li>
</ul>
<h2 id="19中断上下文和进程上下文的区别"><a class="markdownIt-Anchor" href="#19中断上下文和进程上下文的区别"></a> 19.中断上下文和进程上下文的区别</h2>
<ul>
<li><strong>进程上下文</strong>：任务在用户态或内核态下运行，<strong>可以休眠/调度</strong>。</li>
<li><strong>中断上下文</strong>：响应硬件中断时执行，<strong>不能休眠，不能调用阻塞函数</strong>。</li>
</ul>
<h2 id="20__attrubute__有什么用"><a class="markdownIt-Anchor" href="#20__attrubute__有什么用"></a> 20.__attrubute__有什么用</h2>
<h1 id="freertos"><a class="markdownIt-Anchor" href="#freertos"></a> FreeRTOS</h1>
<h2 id="1freertos-中使用的调度算法"><a class="markdownIt-Anchor" href="#1freertos-中使用的调度算法"></a> 1.FreeRTOS 中使用的调度算法</h2>
<ul>
<li>
<p><strong>基于优先级的抢占式调度</strong>。</p>
</li>
<li>
<p>相同优先级下，采用 <strong>时间片轮转</strong>。</p>
</li>
<li>
<p><strong>协作式调度</strong>，任务<strong>不会被强制打断</strong>，只有当任务主动调用、阻塞或结束时，才会切换到其他就绪任务</p>
</li>
</ul>
<h2 id="2freertos-如何实现任务同步"><a class="markdownIt-Anchor" href="#2freertos-如何实现任务同步"></a> 2.FreeRTOS 如何实现任务同步</h2>
<ul>
<li><strong>信号量</strong>：用于任务间同步（包括二值信号量、计数信号量）。</li>
<li><strong>互斥量</strong>：解决资源互斥。</li>
<li><strong>队列</strong>：任务间数据传递。</li>
<li><strong>事件组</strong>：多任务事件同步</li>
</ul>
<h2 id="3freertos-的时间片的大小"><a class="markdownIt-Anchor" href="#3freertos-的时间片的大小"></a> 3.FreeRTOS 的时间片的大小</h2>
<ul>
<li>时间片由 <strong>SysTick 定时器中断周期</strong>决定。</li>
</ul>
<h2 id="4freertos-中任务的状态"><a class="markdownIt-Anchor" href="#4freertos-中任务的状态"></a> 4.FreeRTOS 中任务的状态</h2>
<ul>
<li><strong>就绪态（Ready）</strong></li>
<li><strong>运行态（Running）</strong></li>
<li><strong>阻塞态（Blocked）</strong>（等待事件或超时）</li>
<li><strong>挂起态（Suspended）</strong>（不可被调度，需手动恢复）</li>
<li><strong>终止态（Deleted）</strong></li>
</ul>
<h2 id="5freertos-创建任务的方法和区别"><a class="markdownIt-Anchor" href="#5freertos-创建任务的方法和区别"></a> 5.FreeRTOS 创建任务的方法和区别</h2>
<ul>
<li><strong>xTaskCreate</strong>：普通创建任务。</li>
<li><strong>xTaskCreateStatic</strong>：静态创建，用户提供栈和 TCB。</li>
<li><strong>区别</strong>：静态方式更安全，避免动态内存分配。</li>
</ul>
<h2 id="6freertos-的空闲任务以及它的作用"><a class="markdownIt-Anchor" href="#6freertos-的空闲任务以及它的作用"></a> 6.FreeRTOS 的空闲任务以及它的作用</h2>
<ul>
<li><strong>空闲任务 (Idle Task)</strong>：系统启动后自动创建。</li>
<li><strong>默认优先级最低</strong>，永远存在。</li>
<li><strong>作用</strong>：
<ul>
<li>回收已删除任务的资源。</li>
<li>执行用户定义的钩子函数（如省电模式）。</li>
</ul>
</li>
</ul>
<h2 id="7freertos-中的-svc-systick-和-pendsv-的作用和区别"><a class="markdownIt-Anchor" href="#7freertos-中的-svc-systick-和-pendsv-的作用和区别"></a> 7.FreeRTOS 中的 SVC、SysTick 和 PendSV 的作用和区别</h2>
<ul>
<li><strong>SVC (Supervisor Call)</strong>：系统调用，进入内核模式。
<ul>
<li>系统启动时用 <strong>SVC_Handler</strong> 进入第一个任务（第一次上下文切换）。</li>
<li>相当于“进入内核”的入口。</li>
</ul>
</li>
<li><strong>SysTick</strong>：系统定时器中断，触发任务调度，给操作系统提供 <strong>时间基准 (tick)</strong>。
<ul>
<li>周期性触发 <code>SysTick_Handler</code>。</li>
<li>内核更新系统时钟（<code>xTickCount</code>）。</li>
</ul>
</li>
<li><strong>PendSV</strong>：<strong>最低优先级中断</strong>，用于<strong>任务上下文切换</strong>。
<ul>
<li>因优先级最低，确保不会打断其他更重要的中断。</li>
<li>保存当前任务寄存器（上下文），切换栈指针（PSP），恢复下一个任务的上下文。</li>
</ul>
</li>
</ul>
<h2 id="8freertos-为什么要用-pendsv"><a class="markdownIt-Anchor" href="#8freertos-为什么要用-pendsv"></a> 8.FreeRTOS 为什么要用 PendSV</h2>
<ul>
<li>PendSV 可设为最低优先级，确保任务切换不会打断其他中断处理。</li>
<li>这样 <strong>上下文切换延迟最小，效率最高</strong>。</li>
</ul>
<h2 id="9freertos-中的任务控制块是什么"><a class="markdownIt-Anchor" href="#9freertos-中的任务控制块是什么"></a> 9.FreeRTOS 中的任务控制块是什么</h2>
<ul>
<li><strong>任务控制块 (TCB, Task Control Block)</strong>：保存任务的所有信息。</li>
<li><strong>主要内容</strong>：
<ul>
<li>栈指针（pxTopOfStack）</li>
<li>任务优先级（uxPriority）</li>
<li>任务状态（xStateListItem）</li>
<li>延时/阻塞时间（pxStack）</li>
<li>任务名（pcTaskName）</li>
</ul>
</li>
</ul>
<h2 id="10freertos-如何实现任务切换过程是什么"><a class="markdownIt-Anchor" href="#10freertos-如何实现任务切换过程是什么"></a> 10.FreeRTOS 如何实现任务切换，过程是什么</h2>
<p><strong>触发条件</strong></p>
<ul>
<li>周期性 <strong>SysTick</strong> 中断（时间片/延时到期）。</li>
<li>任务调用阻塞函数（如 <code>vTaskDelay</code>、<code>xQueueReceive</code>）。</li>
<li>高优先级任务进入就绪态。</li>
</ul>
<p><strong>切换机制</strong></p>
<ol>
<li><strong>触发调度请求</strong>：SysTick 或 <code>taskYIELD()</code> 设置 <strong>PendSV</strong> 异常挂起。</li>
<li><strong>保存上下文</strong>：<code>PendSV_Handler</code> 将当前任务的 CPU 寄存器压入其任务栈（PSP）。</li>
<li><strong>调度器决策</strong>：根据优先级选择下一个要运行的任务。</li>
<li><strong>恢复上下文</strong>：从新任务栈中弹出寄存器，恢复执行环境。</li>
<li><strong>返回任务</strong>：CPU 跳转到新任务的断点继续运行。</li>
</ol>
<h2 id="11freertos-有哪两种内存分配方式有哪五种分配算法"><a class="markdownIt-Anchor" href="#11freertos-有哪两种内存分配方式有哪五种分配算法"></a> 11.FreeRTOS 有哪两种内存分配方式，有哪五种分配算法？</h2>
<ul>
<li><strong>方式</strong>：
<ul>
<li><strong>静态分配</strong>：用户提供内存（更安全）。</li>
<li><strong>动态分配</strong>：系统在堆中申请。</li>
</ul>
</li>
<li><strong>算法（heap_1 ~ heap_5）</strong>：
<ul>
<li>heap_1：最简单，<strong>不</strong>允许<strong>释放</strong>，<strong>无内存碎片</strong>。</li>
<li>heap_2：允许<strong>释放</strong>，<strong>但可能产生碎片</strong>。</li>
<li>heap_3：直接调用 <code>malloc/free</code>。</li>
<li>heap_4：<strong>合并相邻空闲块</strong>，减少碎片。</li>
<li>heap_5：支持<strong>多个非连续内存区域碎片合并</strong>。</li>
</ul>
</li>
</ul>
<h2 id="12为什么在-freertos-中信号量-队列等设计了两套函数"><a class="markdownIt-Anchor" href="#12为什么在-freertos-中信号量-队列等设计了两套函数"></a> 12.为什么在 FreeRTOS 中信号量、队列等设计了两套函数？</h2>
<ul>
<li>FreeRTOS 提供 <strong>带阻塞时间</strong> 和 <strong>不带阻塞时间</strong> 两套接口。</li>
<li><strong>原因</strong>：
<ul>
<li>带阻塞时间：任务可在等待期间挂起，避免忙等。</li>
<li>不带阻塞时间：适合中断服务例程 (ISR)，因为中断中不能阻塞。</li>
</ul>
</li>
</ul>
<h2 id="13vtaskdelay-和-vtaskdelayuntil-的区别"><a class="markdownIt-Anchor" href="#13vtaskdelay-和-vtaskdelayuntil-的区别"></a> 13.vTaskDelay 和 vTaskDelayUntil 的区别</h2>
<ul>
<li><strong>vTaskDelay</strong>：延时相对当前时间。</li>
<li><strong>vTaskDelayUntil</strong>：延时基于绝对时间（适合周期性任务，抖动小）。</li>
</ul>
<h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1>
<h2 id="1常用的调试方法有什么了解"><a class="markdownIt-Anchor" href="#1常用的调试方法有什么了解"></a> 1.常用的调试方法有什么（了解）</h2>
<ul>
<li><strong>软件调试</strong>：<code>printf</code>、日志输出、断点调试（gdb）。</li>
<li><strong>硬件调试</strong>：示波器、逻辑分析仪、JTAG/SWD。</li>
<li><strong>分析工具</strong>：perf、valgrind、strace、Wireshark。</li>
</ul>
<h2 id="2-gdb-常见命令了解"><a class="markdownIt-Anchor" href="#2-gdb-常见命令了解"></a> 2. gdb 常见命令（了解）</h2>
<ul>
<li><strong>启动调试</strong>
<ul>
<li><code>gdb ./a.out</code> → 以 gdb 打开可执行文件。</li>
<li><code>run</code> (简写 <code>r</code>) → 开始运行程序。</li>
</ul>
</li>
<li><strong>断点控制</strong>
<ul>
<li><code>break main</code> (简写 <code>b main</code>) → 在 <code>main</code> 函数入口设置断点。</li>
<li><code>break 10</code> → 在源码第 10 行设置断点。</li>
<li><code>delete</code> → 删除断点。</li>
</ul>
</li>
<li><strong>单步调试</strong>
<ul>
<li><code>next</code> (简写 <code>n</code>) → 单步执行，<strong>函数整体当成一步</strong>（不进入函数体）。</li>
<li><code>step</code> (简写 <code>s</code>) → 单步执行，<strong>遇到函数会进入</strong>函数体。</li>
<li><code>finish</code> → 运行到当前函数结束并返回。</li>
</ul>
</li>
<li><strong>程序控制</strong>
<ul>
<li><code>continue</code> (简写 <code>c</code>) → 继续运行，直到下一个断点或程序结束。</li>
<li><code>quit</code> (简写 <code>q</code>) → 退出 gdb。</li>
</ul>
</li>
<li><strong>信息查看</strong>
<ul>
<li><code>print x</code> (简写 <code>p x</code>) → 打印变量 <code>x</code> 的值。</li>
<li><code>bt</code> (backtrace) → 查看调用栈，显示当前函数调用路径。</li>
<li><code>info locals</code> → 查看当前函数的局部变量。</li>
<li><code>list</code> (简写 <code>l</code>) → 查看当前源码附近的代码。</li>
</ul>
</li>
</ul>

      </div>
    </div>
</div>

<div class="post-category">

    <div id="p-meta-i">
        
              
                <a class="hover-with-bg" href="/categories/C%E8%AF%AD%E8%A8%80/">C语言</a>
              
          
          
              
                <a class="hover-with-bg" href="/tags/%E8%AF%AD%E6%B3%95/"># 语法</a>
              
          
    </div>
</div>


<div class="post-footer">
  

</div>

</article>


        </div>
        
<footer class="text-center">
    
    
    
    
    
    <p>&copy;  2022 - 2025&nbsp;&nbsp;本书</p>
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme by <a href="https://github.com/oCoke/hexo-theme-miracle" target="_blank">Miracle</a></p>
    
    
</footer>

<div class="p-btn">
    
        <a class="toc-btn" id="toc-btn"><i id="i-menu"></i></a>
    
    
      <a class="toc-btn" id="share-btn"><i>
        <svg t="1670124379155" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2683" width="25" height="25"><path d="M395.946667 234.666667v64H256v469.333333h512V522.666667h64V768a64 64 0 0 1-64 64H256a64 64 0 0 1-64-64V298.666667a64 64 0 0 1 64-64h139.946667z m335.850666-87.914667l150.848 150.826667-158.378666 158.4-45.269334-45.248L748.394667 341.333333H672c-121.685333 0-220.714667 97.024-223.914667 217.941334L448 565.333333v85.333334h-64v-85.333334C384 406.272 512.938667 277.333333 672 277.333333h99.861333l-85.312-85.333333 45.248-45.248z" p-id="2684" fill="var(--first-text-color)"></path></svg>
      </i></a>
    
    <a href="javascript:window.scrollTo({top:0,behavior:'smooth'});" class="click-btn">
      <i id="i-up"></i>
    </a>
</div>

<!-- SCRIPTS -->






<script>
    document.getElementById("btn-dropdown").addEventListener('click', () => {
      toggleClass("#dropdown-menus","display-inline");
    });
    console.log('\n' + ' %c Powered by Hexo Theme Miracle ' + ' %c https://github.com/oCoke/hexo-theme-miracle ' + '\n' + '\n', 'color: #fff; background: #4F9BFA; padding:5px 0;', 'background: #FFF; padding:5px 0;');

    

    
  /* 小彩蛋: 饮茶先啦 */
  setTimeout(() => {
    var time = new Date();
    if (time.getHours() == 15) {
      let comment = document.createComment(' 三点几嚟！饮茶先啦！ ');
      document.body.insertBefore(comment, document.getElementsByTagName('header')[0]);
    }
  },1);
    
</script>


<script>
    var postImg = document.querySelectorAll("article[class=page] img");
    for (let imgi = 0; imgi < postImg.length; imgi++) {
        postImg[imgi].onclick = () => {
            let zoomImg = document.createElement("div");
            zoomImg.id = "zoomImg";
            zoomImg.innerHTML = `<div id="zoom-picture"></div>
    <div class="poptrox-overlay"
        style="position: fixed; left: 0px; top: 0px; z-index: 20000; width: 100%; height: 100%; text-align: center; cursor: zoom-out; opacity: 1;">
        <div style="display:inline-block;height:100%;vertical-align:middle;"></div>
        <div
            style="position:absolute;left:0;top:0;width:100%;height:100%;background:#000000;opacity:0;filter:alpha(opacity=0);">
        </div>
        <div class="poptrox-popup"
            style="display: inline-block; vertical-align: middle; position: relative; z-index: 1; cursor: zoom-out; min-width: 10px; min-height: 10px; width: auto; height: auto;">
            <div class="loader" style="display: none;"></div>
            <div class="pic" style="text-indent: 0px;"><img
                    src="${ postImg[imgi].srcset || postImg[imgi].src }" alt="Loading..."
                    style="vertical-align: bottom; max-width: 85vw; max-height: 85vh;"></div>
        </div>
    </div>`;
            document.body.appendChild(zoomImg);
                document.querySelector("#zoomImg").onclick = () => {
                    document.querySelector("#zoomImg").remove();
                }
        }
    }
    
</script>




    <script>
        query("#toc-btn")[0].onclick = () => {
            if (query(".post-toc")[0].innerHTML) {
                toggleClass(".post-toc", "display-inline");
            }
        }

        if (!query(".post-toc")[0].innerHTML) {
            addClass("#toc-btn","display-none");
        }
    </script>



    <script>
        query("#share-btn")[0].onclick = async () => {
            let url = `${location.protocol}//${location.hostname}${location.port ? ":"+location.port:location.port}${location.pathname}#read=${sessionStorage.getItem(location.pathname+"_read_y") || ""}`;
            try {
                await navigator.clipboard.writeText(url);
                prompt_core("分享链接已经复制至剪贴板", 4800, true);
            } catch(e) {
                prompt_core("分享链接复制失败，请手动复制<br/>"+url, 4800, false);
            }
        }
    </script>







    <script>
        const getScrollPosition = (el = window) => ({
            x: el.pageXOffset !== undefined ? el.pageXOffset : el.scrollLeft,
            y: el.pageYOffset !== undefined ? el.pageYOffset : el.scrollTop
        });
        // 此处的 750 是「页面元素的最大宽度」
        var wx = document.getElementsByClassName("article-m")[0].clientWidth;
        var wy = document.getElementsByClassName("article-m")[0].clientHeight;
        function windowScroll() {
            // 反复修改 确保页面尺寸不改变
            wx = document.getElementsByClassName("article-m")[0].clientWidth;
            wy = document.getElementsByClassName("article-m")[0].clientHeight;
            let y = Math.round(getScrollPosition().y);
            // console.log(y);
            // 组合字符串，同时记录页面坐标，页面宽度和高度
            let p = `${y}:${wx}:${wy}`;
            // 写入到 sessionStorage 中
            sessionStorage.setItem(location.pathname + "_read_y", p);
        }
        // URL 中是否包含传递的坐标信息
        setTimeout(() => {
            if (location.hash.split("#read=").length > 1) {
                prompt_core("已有阅读进度，正在跳转", 4800, true);
                // 分离字符串
                let read_y = location.hash.split("#read=")[1];
                read_y = read_y.split(":");
                // 组合乘积，顺滑移动至坐标
                window.scrollTo({top: Math.round(Number(read_y[0]) * Number(read_y[1] * Number(read_y[2] / wx / wy))), behavior: "smooth"});
            } else {
                // 从 sessionStorage 中获取
                let read_y = sessionStorage.getItem(location.pathname + "_read_y") || "0:0:0";
                read_y = read_y.split(":");
                if (read_y[0] != "0") prompt_core("已有阅读进度，正在跳转", 4800, true);
                window.scrollTo({top: Math.round(Number(read_y[0]) * Number(read_y[1] * Number(read_y[2] / wx / wy))), behavior: "smooth"});
            }
        }, 500);
        window.onscroll = windowScroll;
    </script>





        </div>
        <div id="css-loading">
            <h3 class="text-center">加载中...</h3>
        </div>
        
    </body>
</html>

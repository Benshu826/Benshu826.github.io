<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="UTF-8">
    
    <link rel="apple-touch-icon" sizes="76x76" href="/null">
    <link rel="icon" type="image/png" href="/null">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    <title>常见八股问题 - Ben Shu &#39;s Blog</title>
    
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    
    
    <meta name="description" content="">
    <meta name="author" content="Big Ben">
    <meta name="keywords" content="">
    <meta property="og:title" content="常见八股问题"/>
    <style>


    
    :root{
        --shadow-color: rgba(0,0,0,0.2);
        --sec-shadow: rgba(0,0,0,0.03);
        --shadow-hover-color: rgba(0,0,0,0.28);
        --first-text-color: #475b6d;
        --second-text-color: #37475b;
        --third-text-color: #858585;
        --default-text-color: #505050;
        --default-link-color: #007bff;
        --link-color: #000000;
        --second-link-color: #4F9BFA;
        --code-color:rgba(27,31,35,.05);
        --post-bkg-color: #fff;
        --page-bkg-color: #f2f5f8;
        --nav-a-hover-color: #3498db;
        --post-sec-text-color: #718096;
        --sec-bkg: #f2f5f8;
        --color-mode: 'light';
        --bkg-h: rgba(255,255,255,0.6);
        --bkg-m: #e1e4e8;
        --home-title-color: #4169E1;
        --shadow: 0 4px 10px rgba(0,2,4,0.06),0 0 1px rgba(0,2,4,0.11);
        --hr-color: #ddd;
        --bg-t: #f4f4f4;
        --nav-bkg: rgba(255,255,255,0.6);
    }

@media (prefers-color-scheme: dark) {
  :root {
    --color-mode: 'dark';
  }

  :root:not([data-theme]) {
    --first-text-color: hsla(0,0%,100%,0.92);
    --second-text-color: hsla(0,0%,100%,0.86);
    --third-text-color: #a7a9ad;
    --default-text-color: #505050;
    --default-link-color: #1589e9;
    --link-color: #000000;
    --second-link-color: #30a9de;
    --post-bkg-color: #252d38;
    --page-bkg-color: #181c27;
    --nav-a-hover-color: #3498db;
    --post-sec-text-color: #a7a9ad;
    --sec-bkg: #364151;
    --bkg-h: rgba(255,255,255,0.2);
    --bkg-m: rgba(255,255,255,0.1);
    --home-title-color: rgb(226, 82, 90);
    --code-color:#3e4b5e;
    --shadow: none;
    --hr-color: #718096;
    --bg-t: #364151;
    --nav-bkg: rgba(13,17,23,0.6);
  }
}

[data-theme='dark'] {
    --shadow-color: rgba(0,0,0,0.2);
    --shadow-hover-color: rgba(0,0,0,0.28);
    --first-text-color: hsla(0,0%,100%,0.92);
    --second-text-color: hsla(0,0%,100%,0.86);
    --third-text-color: #a7a9ad;
    --default-text-color: #505050;
    --default-link-color: #1589e9;
    --link-color: #000000;
    --second-link-color: #30a9de;
    --post-bkg-color: #252d38;
    --page-bkg-color: #181c27;
    --nav-a-hover-color: #3498db;
    --post-sec-text-color: #a7a9ad;
    --sec-bkg: #364151;
    --bkg-h: rgba(255,255,255,0.2);
    --bkg-m: rgba(255,255,255,0.1);
    --home-title-color: rgb(226, 82, 90);
    --code-color:#3e4b5e;
    --shadow: none;
    --hr-color: #718096;
    --bg-t: #364151;
    --nav-bkg: rgba(13,17,23,0.6);
}

</style>



<style>
#page-main,footer,.p-btn{
    display: none;
}
html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
}
body {
    background-color: var(--page-bkg-color);
    color: var(--second-text-color);
    overflow-y: scroll;
    overflow-x: hidden;
    transition: all .3s;
}
a {
    color: var(--default-link-color);
    text-decoration: none;
    background-color: transparent;
}
a:hover{
    color: var(--second-link-color);
}
.main-content,.post-card-main{
    margin: 30px;
}



@media (max-width: 410px){
    .post-card-main{
        max-width: 350px!important;
    }
}

@media (max-width: 980px){
    .post-card-main{
        max-width: 520px!important;
    }
}


@media (min-width: 780px){ 
    h3{
        font-size: 1.5rem;
        line-height: 1.5em;
    }
}
@media (min-width: 1280px){ 
    h3{
        font-size: 1.7rem;
        line-height: 1.5em;
    }
}
@media (min-width: 2096px){ 
    h3{
        font-size: 1.8rem;
        line-height: 1.5em;
    }
}

.text-center{
    text-align: center!important;
}
.middle-center{
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;
    -webkit-box-align: center;
    -ms-flex-align: center;
    align-items: center;
    -webkit-box-pack: center;
    -ms-flex-pack: center;
    justify-content: center;
    height: 100%;
}
header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    position: fixed;
    height: 54px;
    padding: 0 1.25rem;
    top: 0;
    left: 0;
    right: 0;
    z-index: 10;
    border-bottom: 1px solid var(--bkg-m);
    background-color: var(--nav-bkg);
    backdrop-filter: blur(4px);
    transition: all .3s;
}
header .header__left, header .header__right {
    display: flex;
    align-items: center;
    font-family: rubik,sans-serif,Varela Round;
}
header .header__left .logo__text {
    font-size: 18px;
    font-weight: 450;
    padding: 14.5px 10px;
    border-radius: 5px;
    color: var(--second-text-color);
}
header .header__right .navbar__menus {
    height: 54px;
    padding: 0 0 0 15px;
}
header .header__right .button {
    color: var(--second-text-color);
}
header .header__right .navbar__menus .navbar-menu {
    display: inline-block;
    align-items: center;
    height: 54px;
    padding: 0 10px;
    font-size: 16px;
    line-height: 54px;
}
header .header__right .dropdown-icon {
    display: none;
    height: 54px;
    padding: 15px 10px;
    border: 0;
    background-color: transparent;
}
header .header__right .dropdown-menus {
    line-height: 2rem;
    animation: slide-in .15s ease 1;
    display: none;
    position: absolute;
    left: 12px;
    right: 12px;
    top: calc(54px + 10px);
    border-radius: 6px;
    padding: 24px;
    background-color: var(--page-bkg-color);
    border: 1px solid var(--bkg-m);
    z-index: 9999;
    justify-items: center;
    justify-content: center;
    flex-direction: column;
}
header .header__right #btn-search, header .header__right #btn-toggle-dark{
    display: inline-block;
    padding:  18px 10px;
    height: 25px;
}
header .header__right #btn-dropdown{
  display: inline-block;
  padding:  13.5px 0;
}
header .header__right .dropdown-menus .dropdown-menu {
    padding: 10px;
    color: var(--second-text-color);
}
@media screen and (max-width: 764px){
.navbar__menus {
    display: none!important;
}
.dropdown-icon {
    display: inline-block!important;
}
}
.p-btn{
    position: fixed;
    bottom: 1.2rem;
    right: 1.2rem;
    contain: layout;
}
.toc-btn,.click-btn{
    cursor: pointer;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    align-items: center;
    margin-top: .5rem;
    font-size: .75rem;
    background-color: var(--sec-bkg);
    display: block;
    padding: 0.9rem;
    box-shadow: 0 0.3rem 0.6rem rgba(48,55,66,.15);
    border: none;
    border-radius: 0.5rem;
    line-height: 1;
    color: var(--first-text-color);
}
.toc-link{
    color: var(--second-text-color);
}

#css-loading h3{
    font-weight: 500;
    font-size: 1.4rem;
    text-align: center;
    position: fixed;
    top: 200px;
    left: 0;
    right: 0;
    opacity: 0;
    animation: cssLoad;
    animation-delay: 0.3s;
    -webkit-animation: cssLoad;
    -webkit-animation-delay: 0.3s;
}
@keyframes cssLoad {
    from {
        opacity: 0;
    }
    to {
        opacity: 0.9;
    }
}


.memorial {
    -webkit-filter: grayscale(100%);
    -moz-filter: grayscale(100%);
    -ms-filter: grayscale(100%);
    -o-filter: grayscale(100%);
    filter: grayscale(100%);
    filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); filter:gray;
}


    .post-copyright:after {
        position: absolute;
        color: #fff;
        background: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 496 512'%3E%3Cpath fill='gray' d='M245.8 214.9l-33.2 17.3c-9.4-19.6-25.2-20-27.4-20-22.2 0-33.3 14.6-33.3 43.9 0 23.5 9.2 43.8 33.3 43.8 14.4 0 24.6-7 30.5-21.3l30.6 15.5a73.2 73.2 0 01-65.1 39c-22.6 0-74-10.3-74-77 0-58.7 43-77 72.6-77 30.8-.1 52.7 11.9 66 35.8zm143 0l-32.7 17.3c-9.5-19.8-25.7-20-27.9-20-22.1 0-33.2 14.6-33.2 43.9 0 23.5 9.2 43.8 33.2 43.8 14.5 0 24.7-7 30.5-21.3l31 15.5c-2 3.8-21.3 39-65 39-22.7 0-74-9.9-74-77 0-58.7 43-77 72.6-77C354 179 376 191 389 214.8zM247.7 8C104.7 8 0 123 0 256c0 138.4 113.6 248 247.6 248C377.5 504 496 403 496 256 496 118 389.4 8 247.6 8zm.8 450.8c-112.5 0-203.7-93-203.7-202.8 0-105.5 85.5-203.3 203.8-203.3A201.7 201.7 0 01451.3 256c0 121.7-99.7 202.9-202.9 202.9z'/%3E%3C/svg%3E");
        content: ' ';
        height: 10rem;
        width: 10rem;
        right: -2rem;
        top: -2rem;
        opacity: .1;
    }

</style>

    

    
        <!--
        <link rel="stylesheet" href="/css/page.css" media="print"
            onload="this.media='all';this.onload=null">
        <noscript>-->
            <link rel="stylesheet" href="/css/page.css">
        <!--</noscript>-->
    
    
    <link rel="stylesheet" href="/css/main.css" media="print" onload="this.media='all';this.onload=null">
    <noscript>
        <link rel="stylesheet" href="/css/main.css">
    </noscript>

    
    <script src="/js/main.js"></script>
    
      
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha512-fHwaWebuwA7NSF5Qg/af4UeDx9XqUpYpOGgubo3yWu+b2IQR4UeQwbb42Ti7gVAjNtVoI/I9TEoYeu9omwcC6g==" crossorigin="anonymous" referrerpolicy="no-referrer" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>

    <body>
        <header>
            
<div class="header__left">
	<a href="/" class="button"><span class="logo__text">主页</span></a>
</div>
<div class="header__right">
	<div class="navbar__menus">
		
		<a href="/" class="button">
			<div class="navbar-menu">首页</div>
		</a>
		
		<a href="/archives/" class="button">
			<div class="navbar-menu">归档</div>
		</a>
		
		<a href="/categories/" class="button">
			<div class="navbar-menu">分类</div>
		</a>
		
		<a href="/tags/" class="button">
			<div class="navbar-menu">标签</div>
		</a>
		
		<a href="/about/" class="button">
			<div class="navbar-menu">关于</div>
		</a>
		
	</div>
	
	<a href="/search/" class="button">
		<div id="btn-search">
			<svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 1024 1024" width="24" height="24" fill="currentColor"
				stroke="currentColor" stroke-width="32">
				<path
					d="M192 448c0-141.152 114.848-256 256-256s256 114.848 256 256-114.848 256-256 256-256-114.848-256-256z m710.624 409.376l-206.88-206.88A318.784 318.784 0 0 0 768 448c0-176.736-143.264-320-320-320S128 271.264 128 448s143.264 320 320 320a318.784 318.784 0 0 0 202.496-72.256l206.88 206.88 45.248-45.248z">
				</path>
			</svg>
		</div>
	</a>
	
	<a href="javaScript:void(0);" class="button" id="btn-toggle-dark">
		<div>
			<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none"
				stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
				<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
			</svg>
		</div>
	</a>
	<a href="javaScript:void(0);" class="dropdown-icon button">
		<div id="btn-dropdown">
			<svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 1024 1024" width="24" height="24" fill="currentColor"
				stroke="currentColor" stroke-width="32" stroke-linecap="round">
				<path
					d="M903.43 561.52H148.8c-13.25 0-24-10.75-24-24s10.75-24 24-24h754.63c13.25 0 24 10.75 24 24s-10.75 24-24 24zM903.43 204.31H148.8c-13.25 0-24-10.75-24-24s10.75-24 24-24h754.63c13.25 0 24 10.75 24 24s-10.75 24-24 24zM903.43 918.73H148.8c-13.25 0-24-10.75-24-24s10.75-24 24-24h754.63c13.25 0 24 10.75 24 24s-10.75 24-24 24z"
					fill="currentColor"></path>
			</svg>
		</div>
	</a>
	<div class="dropdown-menus" id="dropdown-menus">
		
		<a href="/" class="dropdown-menu button">首页</a>
		<br>
		
		<a href="/archives/" class="dropdown-menu button">归档</a>
		<br>
		
		<a href="/categories/" class="dropdown-menu button">分类</a>
		<br>
		
		<a href="/tags/" class="dropdown-menu button">标签</a>
		<br>
		
		<a href="/about/" class="dropdown-menu button">关于</a>
		<br>
		
	</div>
</div>

        </header>
        <div id="top"></div>
        <div id="page-main" class="main-content">
        <div class="mg-top">
            

<article class="page">
<div id="post-meta-m">
    <div class="post-meta" id="post-meta">
  <h3>常见八股问题</h3>
    
      <span class="post-meta-label">
        Big Ben
      </span>
    
    
      <span class="post-meta-label">
        <span class="p-dot"></span>
        <time datetime="2025-08-31 20:51" pubdate>
          2025-08-31
        </time>
      </span>
    
    
      
      <span class="post-meta">
        <span class="p-dot"></span>
        共 21.9k 字
      </span>
    
    
    
  </div>
  
</div>
<div class="article-m">
  <div class="post-toc">
    
      <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#cc"><span class="toc-number">1.</span> <span class="toc-text"> C&#x2F;C++</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.1.</span> <span class="toc-text"> 运算符优先级</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.</span> <span class="toc-text"> 原码、反码、补码转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#volatile"><span class="toc-number">1.3.</span> <span class="toc-text"> Volatile</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.4.</span> <span class="toc-text"> 指针的大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cc-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%A4%A7%E5%B0%8F"><span class="toc-number">1.5.</span> <span class="toc-text"> C&#x2F;C++ 基本数据类型大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%90%8Dnum%E5%92%8Cnum%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.</span> <span class="toc-text"> 数组名num和&amp;num的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8-"><span class="toc-number">1.7.</span> <span class="toc-text"> 什么时候用 . ，什么时候用-&gt;</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E5%92%8C%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88"><span class="toc-number">1.8.</span> <span class="toc-text"> 指针数组和数组指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%87%BD%E6%95%B0%E5%92%8C%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="toc-number">1.9.</span> <span class="toc-text"> 指针函数和函数指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F"><span class="toc-number">1.10.</span> <span class="toc-text"> 常量指针和指针常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8E%E6%8C%87%E9%92%88%E5%92%8C%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-number">1.11.</span> <span class="toc-text"> 野指针和悬空指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#free%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98%E5%90%8E%E6%8C%87%E9%92%88%E8%BF%98%E8%83%BD%E7%94%A8%E5%90%97"><span class="toc-number">1.12.</span> <span class="toc-text"> Free释放内存后，指针还能用吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%E6%9C%89%E4%BA%86%E6%8C%87%E9%92%88%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E9%9C%80%E8%A6%81%E5%BC%95%E7%94%A8"><span class="toc-number">1.13.</span> <span class="toc-text"> 引用是什么，有了指针为什么还需要引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.14.</span> <span class="toc-text"> 数组和链表的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#include-%E5%92%8C-include-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.15.</span> <span class="toc-text"> “#include &quot;&quot; 和 #include &lt;&gt; 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ifndef-define-endif%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.16.</span> <span class="toc-text"> #ifndef #define #endif的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#strlen%E5%92%8Csizeof%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.17.</span> <span class="toc-text"> strlen和sizeof的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gets%E5%92%8Cscanf%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.18.</span> <span class="toc-text"> gets和scanf函数的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.19.</span> <span class="toc-text"> C语言内存分配的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct-%E5%92%8C-class-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.20.</span> <span class="toc-text"> struct 和 class 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%81%94%E5%90%88%E4%BD%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.21.</span> <span class="toc-text"> 结构体和联合体的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%8F%E5%87%BD%E6%95%B0%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">1.22.</span> <span class="toc-text"> 宏函数注意点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.23.</span> <span class="toc-text"> 全局变量和局部变量的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#define-typedef-const-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.24.</span> <span class="toc-text"> #define、typedef、const 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.25.</span> <span class="toc-text"> static 的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#register%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.26.</span> <span class="toc-text"> register的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#memcpy-%E5%92%8C-strcpy-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%93%AA%E4%B8%AA%E5%AE%89%E5%85%A8"><span class="toc-number">1.27.</span> <span class="toc-text"> memcpy 和 strcpy 的区别，哪个安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.28.</span> <span class="toc-text"> 堆和栈的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#malloc%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.29.</span> <span class="toc-text"> malloc实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#malloc-%E5%92%8C-new-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.30.</span> <span class="toc-text"> malloc 和 new 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#malloc-calloc-realloc-%E5%86%85%E5%AD%98%E7%94%B3%E8%AF%B7%E5%87%BD%E6%95%B0"><span class="toc-number">1.31.</span> <span class="toc-text"> malloc、calloc、realloc 内存申请函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A2%ABfree%E5%9B%9E%E6%94%B6%E7%9A%84%E5%86%85%E5%AD%98%E6%98%AF%E7%AB%8B%E5%8D%B3%E8%BF%94%E8%BF%98%E7%BB%99%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%90%97"><span class="toc-number">1.32.</span> <span class="toc-text"> 被free回收的内存是立即返还给操作系统吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.33.</span> <span class="toc-text"> 内存泄漏是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.34.</span> <span class="toc-text"> 深拷贝和浅拷贝的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E5%88%86%E4%B8%BA%E5%87%A0%E4%B8%AA%E6%AE%B5"><span class="toc-number">1.35.</span> <span class="toc-text"> 程序分为几个段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA-c-%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.36.</span> <span class="toc-text"> 一个 .c 文件怎么转换为可执行程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.37.</span> <span class="toc-text"> 静态链接和动态链接的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#strcpy-sprintf%E5%92%8Cmemcpy%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.38.</span> <span class="toc-text"> strcpy、sprintf和memcpy的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a-%E5%92%8C-a-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.39.</span> <span class="toc-text"> ++a 和 a++ 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%92%8C-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.40.</span> <span class="toc-text"> # 和 ## 的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8D%E9%80%82%E7%94%A8%E9%A2%9D%E5%A4%96%E7%A9%BA%E9%97%B4%E4%BA%A4%E6%8D%A2%E4%B8%A4%E4%B8%AA%E6%95%B0"><span class="toc-number">1.41.</span> <span class="toc-text"> 不适用额外空间，交换两个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E8%83%BD%E4%B8%8D%E8%83%BD%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E9%87%8D%E5%90%8D"><span class="toc-number">1.42.</span> <span class="toc-text"> 局部变量能不能和全局变量重名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-%E8%AF%AD%E8%A8%80%E4%BD%8D%E5%9F%9Fbit-field%E4%BA%86%E8%A7%A3"><span class="toc-number">1.43.</span> <span class="toc-text"> C 语言位域（Bit-field）（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E8%AE%A1%E7%AE%97%E4%BD%99%E6%95%B0%E4%BA%86%E8%A7%A3"><span class="toc-number">1.44.</span> <span class="toc-text"> 用位运算计算余数（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%96%E6%B6%88%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E6%96%B9%E6%B3%95%E4%BA%86%E8%A7%A3"><span class="toc-number">1.45.</span> <span class="toc-text"> 取消内存对齐的方法（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">1.46.</span> <span class="toc-text"> 什么是回调函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%98%AF%E6%9C%89%E7%AC%A6%E5%8F%B7%E8%BF%98%E6%98%AF%E6%97%A0%E7%AC%A6%E5%8F%B7"><span class="toc-number">1.47.</span> <span class="toc-text"> 如何判断一个整数是有符号还是无符号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.48.</span> <span class="toc-text"> 面向对象和面向过程的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-number">1.49.</span> <span class="toc-text"> 面向对象的三大特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c-%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">1.50.</span> <span class="toc-text"> C++ 类的访问权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD-%E9%87%8D%E5%86%99-%E8%A6%86%E7%9B%96"><span class="toc-number">1.51.</span> <span class="toc-text"> 重载、重写、覆盖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88c-%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.52.</span> <span class="toc-text"> 什么是智能指针，C++ 的智能指针有哪些，作用是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E6%9C%89%E5%87%A0%E7%A7%8Dnew"><span class="toc-number">1.53.</span> <span class="toc-text"> C++有几种new</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E6%9C%89%E5%87%A0%E7%A7%8D%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.54.</span> <span class="toc-text"> C++有几种强制转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2%E5%A6%82%E4%BD%95%E6%B6%88%E9%99%A4%E5%AE%83"><span class="toc-number">1.55.</span> <span class="toc-text"> 隐式转换，如何消除它</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cout%E5%92%8Cprintf%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3"><span class="toc-number">1.56.</span> <span class="toc-text"> cout和printf的区别（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.57.</span> <span class="toc-text"> 什么是虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.58.</span> <span class="toc-text"> 什么是纯虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E4%B8%AD%E5%A6%82%E4%BD%95%E9%98%BB%E6%AD%A2%E4%B8%80%E4%B8%AA%E7%B1%BB%E8%A2%AB%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">1.59.</span> <span class="toc-text"> C++中如何阻止一个类被实例化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E5%87%BD%E6%95%B0%E4%B8%8D%E8%83%BD%E5%A3%B0%E6%98%8E%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.60.</span> <span class="toc-text"> 什么函数不能声明为虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88c%E9%BB%98%E8%AE%A4%E7%9A%84%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%8D%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.61.</span> <span class="toc-text"> 为什么C++默认的析构函数不是虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%BF%85%E9%A1%BB%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">1.62.</span> <span class="toc-text"> 为什么析构函数必须是虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%87%BD%E6%95%B0%E5%92%8C%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.63.</span> <span class="toc-text"> 静态函数和虚函数的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%9C%89%E5%87%A0%E7%A7%8D%E5%88%86%E5%88%AB%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">1.64.</span> <span class="toc-text"> 构造函数有几种，分别什么作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">1.65.</span> <span class="toc-text"> 构造函数和析构函数执行顺序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.66.</span> <span class="toc-text"> 构造函数、拷贝构造函数和赋值运算符的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AA%E5%AE%9A%E4%B9%89%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%BC%9A%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%93%AA%E4%BA%9B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="toc-number">1.67.</span> <span class="toc-text"> 只定义析构函数，会自动生成哪些构造函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E7%B1%BB%E9%BB%98%E8%AE%A4%E4%BC%9A%E7%94%9F%E6%88%90%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="toc-number">1.68.</span> <span class="toc-text"> 一个类默认会生成哪些函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E7%BB%A7%E6%89%BF"><span class="toc-number">1.69.</span> <span class="toc-text"> 什么是虚拟继承</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.70.</span> <span class="toc-text"> 指针和引用的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E6%8C%87%E9%92%88%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%BC%95%E7%94%A8"><span class="toc-number">1.71.</span> <span class="toc-text"> 什么时候指针，什么时候引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%8F%AA%E8%83%BD%E9%9D%99%E6%80%81%E5%88%86%E9%85%8D%E5%92%8C%E5%8F%AA%E8%83%BD%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D"><span class="toc-number">1.72.</span> <span class="toc-text"> 类如何实现只能静态分配和只能动态分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">1.73.</span> <span class="toc-text"> 什么是静态绑定和动态绑定</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%8F%98%E9%87%8F%E6%AF%94%E8%BE%83%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89"><span class="toc-number">1.74.</span> <span class="toc-text"> 结构体变量比较是否相等</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0inline"><span class="toc-number">1.75.</span> <span class="toc-text"> 内联函数（inline）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extern-c-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.76.</span> <span class="toc-text"> extern “C” 的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#c%E4%B8%ADnull%E5%92%8Cnullptr%E5%8C%BA%E5%88%AB"><span class="toc-number">1.77.</span> <span class="toc-text"> C++中NULL和nullptr区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this%E6%8C%87%E9%92%88"><span class="toc-number">1.78.</span> <span class="toc-text"> this指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A6%E5%80%BC%E5%92%8C%E5%8F%B3%E5%80%BC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.79.</span> <span class="toc-text"> 左值和右值的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cc%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%E4%BA%86%E8%A7%A3"><span class="toc-number">1.80.</span> <span class="toc-text"> C&#x2F;C++的关键字（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.81.</span> <span class="toc-text"> vector的底层实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector-%E5%92%8C-list-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-number">1.82.</span> <span class="toc-text"> vector 和 list 的使用场景与区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vector%E4%B8%8B%E7%9A%84resize%E5%92%8Creserve%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.83.</span> <span class="toc-text"> Vector下的Resize和Reserve的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vectorsize%E6%98%AFcapacity%E8%BF%98%E6%98%AF%E5%B7%B2%E5%AD%98%E5%82%A8%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0"><span class="toc-number">1.84.</span> <span class="toc-text"> Vector.size()是capacity，还是已存储的元素个数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%AE%B9%E5%99%A8%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%98%AF%E7%94%B1%E4%BB%80%E4%B9%88%E7%BB%84%E6%88%90%E7%9A%84"><span class="toc-number">1.85.</span> <span class="toc-text"> 如何理解迭代器，容器的迭代器是由什么组成的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stl%E4%B8%AD%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8%E6%9C%89%E6%8C%87%E9%92%88%E4%BA%86%E4%B8%BA%E4%BD%95%E8%BF%98%E8%A6%81%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">1.86.</span> <span class="toc-text"> STL中迭代器有什么用，有指针了为何还要迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stl%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%B9%E5%99%A8%E8%BF%99%E4%BA%9B%E5%AE%B9%E5%99%A8%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="toc-number">1.87.</span> <span class="toc-text"> STL中有哪些容器，这些容器的迭代器是如何删除元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stl%E4%B8%AD%E7%9A%84map%E5%92%8Cset%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">1.88.</span> <span class="toc-text"> STL中的map和set有什么区别，怎么实现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stl%E4%B8%AD%E7%9A%84map%E5%92%8Cunordered_map%E5%8C%BA%E5%88%AB"><span class="toc-number">1.89.</span> <span class="toc-text"> STL中的map和unordered_map区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stl%E7%9A%84map%E6%8F%92%E5%85%A5%E6%96%B9%E5%BC%8F"><span class="toc-number">1.90.</span> <span class="toc-text"> STL的map插入方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E5%93%AA%E4%BA%9B%E6%83%85%E5%86%B5%E4%B8%8B%E5%8F%AA%E8%83%BD%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E8%80%8C%E4%B8%8D%E8%83%BD%E8%B5%8B%E5%80%BC"><span class="toc-number">1.91.</span> <span class="toc-text"> 什么是初始化列表，哪些情况下只能初始化列表，而不能赋值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E5%87%BD%E6%95%B0%E8%83%BD%E4%B8%8D%E8%83%BD%E8%A2%AB%E9%87%8D%E8%BD%BD"><span class="toc-number">1.92.</span> <span class="toc-text"> 没有参数的函数能不能被重载</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.</span> <span class="toc-text"> 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">2.1.</span> <span class="toc-text"> 常见的排序算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%9A%E8%BF%87%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%88%A4%E6%96%AD%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">2.2.</span> <span class="toc-text"> 二叉树通过中序遍历和后序遍历，判断前序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%90%9C%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.3.</span> <span class="toc-text"> 什么是搜索二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">2.4.</span> <span class="toc-text"> 什么是平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%9A%E8%BF%87%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%88%A4%E6%96%AD%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86-2"><span class="toc-number">2.5.</span> <span class="toc-text"> 二叉树通过中序遍历和后序遍历，判断前序遍历</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">3.</span> <span class="toc-text"> 计算机网络</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#osi-%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B-%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.1.</span> <span class="toc-text"> OSI 四层模型 &#x2F; 七层模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.2.</span> <span class="toc-text"> HTTP是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http-%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-number">3.3.</span> <span class="toc-text"> HTTP 的发展史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%AD%97%E6%AE%B5"><span class="toc-number">3.4.</span> <span class="toc-text"> HTTP请求和响应报文包含哪些字段</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B"><span class="toc-number">3.5.</span> <span class="toc-text"> HTTP请求流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#get%E5%92%8Cpost%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.6.</span> <span class="toc-text"> GET和POST的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E5%92%8Chttps%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.7.</span> <span class="toc-text"> HTTP和HTTPS的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E5%92%8C%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86"><span class="toc-number">3.8.</span> <span class="toc-text"> 对称加密和非对称加密</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#https%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B"><span class="toc-number">3.9.</span> <span class="toc-text"> HTTPS请求流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81http%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">3.10.</span> <span class="toc-text"> 常见HTTP状态码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFdns"><span class="toc-number">3.11.</span> <span class="toc-text"> 什么是DNS</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dns-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">3.12.</span> <span class="toc-text"> DNS 负载均衡</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp-%E5%92%8C-udp-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">3.13.</span> <span class="toc-text"> TCP 和 UDP 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mtu%E5%92%8Cmss%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">3.14.</span> <span class="toc-text"> MTU和MSS分别是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp-%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">3.15.</span> <span class="toc-text"> TCP 粘包和拆包问题，怎么解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp-%E9%80%9A%E4%BF%A1%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E9%80%9A%E4%BF%A1%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">3.16.</span> <span class="toc-text"> TCP 通信如何保证通信的可靠性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%8C%BA%E5%88%86%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E5%92%8C%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">3.17.</span> <span class="toc-text"> 如何区分流量控制和拥塞控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B"><span class="toc-number">3.18.</span> <span class="toc-text"> TCP 三次握手（连接建立）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE"><span class="toc-number">3.19.</span> <span class="toc-text"> TCP 四次挥手（连接释放）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%9C%80%E5%90%8E%E8%BF%98%E8%A6%81%E7%AD%89%E5%BE%852msl"><span class="toc-number">3.20.</span> <span class="toc-text"> 为什么客户端最后还要等待2MSL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-cookie"><span class="toc-number">3.21.</span> <span class="toc-text"> 什么是 Cookie</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-session"><span class="toc-number">3.22.</span> <span class="toc-text"> 什么是 Session</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#socket%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%94%A8%E5%88%B0%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0"><span class="toc-number">3.23.</span> <span class="toc-text"> socket网络编程中用到哪些函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#dhcp-%E5%8D%8F%E8%AE%AEdynamic-host-configuration-protocol%E4%BA%86%E8%A7%A3"><span class="toc-number">3.24.</span> <span class="toc-text"> DHCP 协议（Dynamic Host Configuration Protocol）（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arp%E5%92%8Crarp"><span class="toc-number">3.25.</span> <span class="toc-text"> ARP和RARP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ping%E5%91%BD%E4%BB%A4%E5%9F%BA%E4%BA%8E%E4%BB%80%E4%B9%88%E5%8D%8F%E8%AE%AE%E4%BA%86%E8%A7%A3"><span class="toc-number">3.26.</span> <span class="toc-text"> Ping命令基于什么协议（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ip-%E5%9C%B0%E5%9D%80-%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81-%E7%BD%91%E5%85%B3%E5%92%8C-dns-%E4%BD%9C%E7%94%A8"><span class="toc-number">3.27.</span> <span class="toc-text"> IP 地址、子网掩码、网关和 DNS 作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ipv4-%E5%92%8C-ipv6-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BA%86%E8%A7%A3"><span class="toc-number">3.28.</span> <span class="toc-text"> IPv4 和 IPv6 的区别（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E7%BD%91%E7%BB%9C%E6%8B%93%E6%89%91%E7%B1%BB%E5%9E%8B%E4%BA%86%E8%A7%A3"><span class="toc-number">3.29.</span> <span class="toc-text"> 常用的网络拓扑类型（了解）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">4.</span> <span class="toc-text"> 操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.1.</span> <span class="toc-text"> 进程、线程和协程的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.</span> <span class="toc-text"> 进程间通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">4.3.</span> <span class="toc-text"> 进程间通信的选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">4.4.</span> <span class="toc-text"> 进程间的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">4.5.</span> <span class="toc-text"> 线程间通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8C%BA%E5%88%AB"><span class="toc-number">4.6.</span> <span class="toc-text"> 多进程和多线程的适用场景区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">4.7.</span> <span class="toc-text"> 什么是线程池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-number">4.8.</span> <span class="toc-text"> 什么是线程安全</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B-%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">4.9.</span> <span class="toc-text"> 僵尸进程、孤儿进程和守护进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3"><span class="toc-number">4.10.</span> <span class="toc-text"> 僵尸进程有什么危害，如何解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B"><span class="toc-number">4.11.</span> <span class="toc-text"> 什么是内核线程和用户线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">4.12.</span> <span class="toc-text"> 进程调度算法有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="toc-number">4.13.</span> <span class="toc-text"> 并发和并行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E6%A0%B8%E6%9C%BA%E6%A2%B0%E4%B8%8A%E5%86%99%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%90%A6%E8%80%83%E8%99%91%E5%8A%A0%E9%94%81%E4%BA%86%E8%A7%A3"><span class="toc-number">4.14.</span> <span class="toc-text"> 单核机械上写多线程程序，是否考虑加锁（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E4%BA%A4%E6%8D%A2%E5%92%8C%E8%A6%86%E7%9B%96%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">4.15.</span> <span class="toc-text"> 内存交换和覆盖有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">4.16.</span> <span class="toc-text"> 为什么使用虚拟内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E5%8C%96%E4%B8%BA%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">4.17.</span> <span class="toc-text"> 逻辑地址转化为物理地址的基本流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">4.18.</span> <span class="toc-text"> 动态分区分配算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">4.19.</span> <span class="toc-text"> 磁盘调度算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">4.20.</span> <span class="toc-text"> 页面置换算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95-2"><span class="toc-number">4.21.</span> <span class="toc-text"> 页面置换算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fork-exec-wait%E5%87%BD%E6%95%B0"><span class="toc-number">4.22.</span> <span class="toc-text"> fork、exec、wait函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fork-%E5%92%8C-vfork-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.23.</span> <span class="toc-text"> fork 和 vfork 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%93-for-%E5%BE%AA%E7%8E%AF%E9%81%87%E5%88%B0-fork-%E5%87%BD%E6%95%B0%E4%BA%86%E8%A7%A3"><span class="toc-number">4.24.</span> <span class="toc-text"> 当 for 循环遇到 fork 函数（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81-%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">4.25.</span> <span class="toc-text"> 读写锁、自旋锁和互斥锁的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C"><span class="toc-number">4.26.</span> <span class="toc-text"> 什么是原子操作？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%E9%97%AE%E9%A2%98%E5%8F%AF%E8%A7%81%E6%80%A7%E9%97%AE%E9%A2%98%E6%9C%89%E5%BA%8F%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">4.27.</span> <span class="toc-text"> 原子性问题，可见性问题，有序性问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">4.28.</span> <span class="toc-text"> 局部性原理是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81"><span class="toc-number">4.29.</span> <span class="toc-text"> 什么是死锁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#linux"><span class="toc-number">5.</span> <span class="toc-text"> Linux</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">5.1.</span> <span class="toc-text"> 什么是系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux-%E9%A9%B1%E5%8A%A8%E7%9A%84%E4%B8%89%E5%A4%A7%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.2.</span> <span class="toc-text"> Linux 驱动的三大类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91"><span class="toc-number">5.3.</span> <span class="toc-text"> 什么是交叉编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux-%E5%92%8C-rtos-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.4.</span> <span class="toc-text"> Linux 和 RTOS 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux-%E5%86%85%E6%A0%B8%E7%94%B1%E5%93%AA%E4%BA%9B%E6%9E%84%E6%88%90"><span class="toc-number">5.5.</span> <span class="toc-text"> Linux 内核由哪些构成？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux-%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86"><span class="toc-number">5.6.</span> <span class="toc-text"> Linux 系统组成部分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.7.</span> <span class="toc-text"> 什么是根文件系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-number">5.8.</span> <span class="toc-text"> 什么是临界区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E5%A4%87%E6%A0%91"><span class="toc-number">5.9.</span> <span class="toc-text"> 什么是设备树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#select-poll-epoll-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E7%94%A8%E5%A4%84"><span class="toc-number">5.10.</span> <span class="toc-text"> select &#x2F; poll &#x2F; epoll 的区别与用处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-linux-%E7%9A%84%E4%B8%AD%E6%96%AD%E5%88%86%E4%B8%BA%E4%B8%8A%E5%8D%8A%E9%83%A8%E5%88%86%E5%92%8C%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%88%86"><span class="toc-number">5.11.</span> <span class="toc-text"> 为什么 Linux 的中断分为上半部分和下半部分？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%B8%AD%E6%96%AD-vs-%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="toc-number">5.12.</span> <span class="toc-text"> 硬中断 vs 软中断</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#linux%E5%B8%B8%E8%A7%81%E6%8C%87%E4%BB%A4"><span class="toc-number">5.13.</span> <span class="toc-text"> Linux常见指令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#stm32"><span class="toc-number">6.</span> <span class="toc-text"> STM32</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#arm-%E4%B8%AD%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">6.1.</span> <span class="toc-text"> ARM 中的寄存器，都有什么用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%A7%E5%B0%8F%E7%AB%AF%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">6.2.</span> <span class="toc-text"> 大小端是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cortex-m3-%E5%92%8C-cortex-m4-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.3.</span> <span class="toc-text"> Cortex-M3 和 Cortex-M4 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gpio-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">6.4.</span> <span class="toc-text"> GPIO 工作模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-io-%E5%8F%A3%E6%82%AC%E7%A9%BA%E5%8F%AF%E8%83%BD%E5%B8%A6%E6%9D%A5%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">6.5.</span> <span class="toc-text"> 什么是 IO 口悬空，可能带来哪些问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E6%A0%88%E5%92%8C%E4%BB%BB%E5%8A%A1%E6%A0%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E4%BF%9D%E5%AD%98%E5%9C%A8%E5%93%AA%E9%87%8C"><span class="toc-number">6.6.</span> <span class="toc-text"> 中断栈和任务栈有什么区别，保存在哪里</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-i2c-%E9%9C%80%E8%A6%81%E5%BC%80%E6%BC%8F%E8%BE%93%E5%87%BA-%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB"><span class="toc-number">6.7.</span> <span class="toc-text"> 为什么 I2C 需要开漏输出 + 上拉电阻</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spi-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">6.8.</span> <span class="toc-text"> SPI 的工作模式有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spi%E5%BE%80%E5%B1%8F%E4%B8%8A%E5%88%B7%E4%B8%80%E4%B8%AA%E5%83%8F%E7%B4%A0%E7%82%B9%E5%A6%82%E4%BD%95%E6%93%8D%E4%BD%9C"><span class="toc-number">6.9.</span> <span class="toc-text"> SPI往屏上刷一个像素点，如何操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#rs232-%E5%92%8C-rs485-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.10.</span> <span class="toc-text"> RS232 和 RS485 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#stm32-%E4%B8%8A%E7%94%B5%E5%90%8E%E5%88%B0-__main-%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">6.11.</span> <span class="toc-text"> STM32 上电后到 __main 的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#msp-%E5%92%8C-psp-%E4%B8%A4%E4%B8%AA%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88%E9%83%BD%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8"><span class="toc-number">6.12.</span> <span class="toc-text"> MSP 和 PSP 两个指针是什么，都在什么时候用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E8%83%BD%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E5%92%8C%E5%8F%82%E6%95%B0%E5%90%97"><span class="toc-number">6.13.</span> <span class="toc-text"> 中断能有返回值和参数吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ram-rom-%E5%92%8C-flash-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.14.</span> <span class="toc-text"> RAM、ROM 和 Flash 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#cache-%E6%98%AF%E4%BB%80%E4%B9%88cache-%E4%B8%80%E8%87%B4%E6%80%A7%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">6.15.</span> <span class="toc-text"> Cache 是什么，Cache 一致性又是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-smp%E4%BA%86%E8%A7%A3"><span class="toc-number">6.16.</span> <span class="toc-text"> 什么是 SMP（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8D%95%E7%89%87%E6%9C%BA%E4%B8%8D%E4%BD%BF%E7%94%A8-malloc-%E5%87%BD%E6%95%B0"><span class="toc-number">6.17.</span> <span class="toc-text"> 为什么单片机不使用 malloc 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E6%96%AD%E5%B5%8C%E5%A5%97"><span class="toc-number">6.18.</span> <span class="toc-text"> 什么是中断嵌套</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86-flash-%E6%93%A6%E5%86%99%E5%AF%BF%E5%91%BD%E9%97%AE%E9%A2%98"><span class="toc-number">6.19.</span> <span class="toc-text"> 如何处理 Flash 擦写寿命问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%B8%8A%E4%B8%8B%E6%96%87%E5%92%8C%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.20.</span> <span class="toc-text"> 中断上下文和进程上下文的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#can-%E9%80%9A%E4%BF%A1%E7%9A%84%E7%BC%BA%E7%82%B9"><span class="toc-number">6.21.</span> <span class="toc-text"> CAN 通信的缺点</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#freertos"><span class="toc-number">7.</span> <span class="toc-text"> FreeRTOS</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#freertos-%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">7.1.</span> <span class="toc-text"> FreeRTOS 中使用的调度算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#freertos-%E7%9A%84%E6%97%B6%E9%97%B4%E7%89%87%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">7.2.</span> <span class="toc-text"> FreeRTOS 的时间片的大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#freertos-%E4%B8%AD%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">7.3.</span> <span class="toc-text"> FreeRTOS 中任务的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#freertos-%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-number">7.4.</span> <span class="toc-text"> FreeRTOS 创建任务的方法和区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#freertos-%E7%9A%84%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1%E4%BB%A5%E5%8F%8A%E5%AE%83%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">7.5.</span> <span class="toc-text"> FreeRTOS 的空闲任务以及它的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#freertos-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E5%90%8C%E6%AD%A5"><span class="toc-number">7.6.</span> <span class="toc-text"> FreeRTOS 如何实现任务同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#freertos-%E4%B8%AD%E7%9A%84-svc-systick-%E5%92%8C-pendsv-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-number">7.7.</span> <span class="toc-text"> FreeRTOS 中的 SVC、SysTick 和 PendSV 的作用和区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A6%81%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E8%B0%83%E5%BA%A6%E5%8F%AF%E4%BB%A5%E5%8F%AA%E6%9C%89systick%E4%B8%AD%E6%96%AD%E5%90%97"><span class="toc-number">7.8.</span> <span class="toc-text"> 要实现任务调度，可以只有systick中断吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#freertos-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-pendsv"><span class="toc-number">7.9.</span> <span class="toc-text"> FreeRTOS 为什么要用 PendSV</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#freertos-%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6%E5%9D%97%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">7.10.</span> <span class="toc-text"> FreeRTOS 中的任务控制块是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#freertos-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">7.11.</span> <span class="toc-text"> FreeRTOS 如何实现任务切换，过程是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#freertos-%E6%9C%89%E5%93%AA%E4%B8%A4%E7%A7%8D%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%94%E7%A7%8D%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95"><span class="toc-number">7.12.</span> <span class="toc-text"> FreeRTOS 有哪两种内存分配方式，有哪五种分配算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%9C%A8-freertos-%E4%B8%AD%E4%BF%A1%E5%8F%B7%E9%87%8F-%E9%98%9F%E5%88%97%E7%AD%89%E8%AE%BE%E8%AE%A1%E4%BA%86%E4%B8%A4%E5%A5%97%E5%87%BD%E6%95%B0"><span class="toc-number">7.13.</span> <span class="toc-text"> 为什么在 FreeRTOS 中信号量、队列等设计了两套函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#vtaskdelay-%E5%92%8C-vtaskdelayuntil-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">7.14.</span> <span class="toc-text"> vTaskDelay 和 vTaskDelayUntil 的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF"><span class="toc-number">8.</span> <span class="toc-text"> 硬件电路</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#stm32%E6%9C%80%E5%B0%8F%E5%8D%95%E5%85%83%E6%9D%BF%E6%9E%84%E6%88%90"><span class="toc-number">8.1.</span> <span class="toc-text"> STM32最小单元板构成</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ldo%E7%A8%B3%E5%8E%8B%E5%99%A8%E4%BA%86%E8%A7%A3"><span class="toc-number">8.2.</span> <span class="toc-text"> LDO稳压器（了解）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">9.</span> <span class="toc-text"> 其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B5%E8%84%911g%E7%9A%84%E7%A9%BA%E9%97%B4malloc12g-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E8%83%BD%E6%88%90%E5%8A%9F"><span class="toc-number">9.1.</span> <span class="toc-text"> 电脑1G的空间，malloc(1.2G) 为什么可能成功</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E7%9A%84%E8%B0%83%E8%AF%95%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E4%BA%86%E8%A7%A3"><span class="toc-number">9.2.</span> <span class="toc-text"> 常用的调试方法有什么（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#gdb-%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E4%BA%86%E8%A7%A3"><span class="toc-number">9.3.</span> <span class="toc-text"> gdb 常见命令（了解）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%AF%B4%E6%98%8E"><span class="toc-number">10.</span> <span class="toc-text"> 说明</span></a></li></ol>
    
  </div>
    <div id="article">
      <div id="post-content" class="markdown-body textretty">
        <h1 id="cc"><a class="markdownIt-Anchor" href="#cc"></a> C/C++</h1>
<h2 id="运算符优先级"><a class="markdownIt-Anchor" href="#运算符优先级"></a> 运算符优先级</h2>
<p><strong>自上而下，优先级降低</strong></p>
<ol>
<li>
<p><strong>括号</strong> <code>()</code>、数组 <code>[]</code>、结构体成员 <code>.</code>、指针成员 <code>-&gt;</code>。</p>
</li>
<li>
<p><strong>单目</strong>：<code>++</code>、<code>--</code>、<code>!</code>、<code>~</code>、取地址 <code>&amp;</code>、解引用 <code>*</code>、类型转换 <code>(type)</code>。</p>
</li>
<li>
<p><strong>算术</strong>：乘除 <code>%</code> &gt; 加减 &gt; 移位。</p>
</li>
<li>
<p><strong>比较</strong>：先大小，再相等。</p>
</li>
<li>
<p><strong>位运算</strong>：<code>&amp;</code> &gt; <code>^</code> &gt; <code>|</code>。</p>
</li>
<li>
<p><strong>逻辑运算</strong>：<code>&amp;&amp;</code> &gt; <code>||</code>。</p>
</li>
<li>
<p><strong>条件/赋值</strong>：<code>?:</code> &gt; <code>=</code>。</p>
</li>
<li>
<p><strong>最后</strong>：逗号 <code>,</code>。</p>
</li>
</ol>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 逗号运算符从左到右以此求值</span></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (a = a * <span class="number">3</span>, a++));</span><br><span class="line"><span class="comment">// 输出：15</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> a = <span class="number">5</span>; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, (a * <span class="number">3</span>, a++));</span><br><span class="line"><span class="comment">// 输出：5</span></span><br></pre></td></tr></table></figure>
</blockquote>
<hr />
<h2 id="原码-反码-补码转换"><a class="markdownIt-Anchor" href="#原码-反码-补码转换"></a> 原码、反码、补码转换</h2>
<p><strong>正数</strong>：原码 = 反码 = 补码。</p>
<p><strong>负数</strong>：补码 = 反码 + 1。</p>
<blockquote>
<p><strong>Q：计算机计算为什么使用补码？</strong></p>
<p>A：加减运算可以统一为加法，硬件实现简单。</p>
</blockquote>
<hr />
<h2 id="volatile"><a class="markdownIt-Anchor" href="#volatile"></a> Volatile</h2>
<p><strong>作用</strong>：告诉编译器变量的值 <strong>随时可能发生变化</strong>，不要对其进行优化。（预处理操作）</p>
<p><strong>典型场景</strong>：</p>
<ul>
<li>
<p><strong>多线程/中断共享变量</strong>（值可能被中断/其他线程修改）。</p>
</li>
<li>
<p><strong>硬件寄存器</strong>（如单片机的 IO、外设状态寄存器）。</p>
</li>
<li>
<p><strong>内存映射设备</strong>（读写必须严格执行，不能省略）。</p>
</li>
</ul>
<blockquote>
<p><code>volatile</code> 不能保证 <strong>原子性</strong>，需要配合 <strong>锁/关中断</strong> 保护临界区</p>
</blockquote>
<hr />
<h2 id="指针的大小"><a class="markdownIt-Anchor" href="#指针的大小"></a> 指针的大小</h2>
<ul>
<li>32 位平台：指针大小通常 <strong>4 字节</strong>。</li>
<li>64 位平台：指针大小通常 <strong>8 字节</strong>。</li>
</ul>
<blockquote>
<ul>
<li>
<p>不管 <code>int*</code>、<code>char*</code>、<code>double*</code>，指针大小都一样。</p>
</li>
<li>
<p>1Byte = 8 Bit</p>
</li>
<li>
<p>指针只能相减，不能相加（<strong>通常会越界</strong>）</p>
</li>
</ul>
</blockquote>
<hr />
<h2 id="cc-基本数据类型大小"><a class="markdownIt-Anchor" href="#cc-基本数据类型大小"></a> C/C++ 基本数据类型大小</h2>
<ul>
<li><strong>32 位</strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">大小 (字节)</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>char</code></td>
<td style="text-align:center">1</td>
<td style="text-align:center">最小存储单元</td>
</tr>
<tr>
<td style="text-align:center"><code>short</code></td>
<td style="text-align:center">2</td>
<td style="text-align:center">至少 16 位</td>
</tr>
<tr>
<td style="text-align:center"><code>int</code></td>
<td style="text-align:center">4</td>
<td style="text-align:center">通常 32 位</td>
</tr>
<tr>
<td style="text-align:center"><code>long</code></td>
<td style="text-align:center"><strong>4</strong></td>
<td style="text-align:center">和 <code>int</code> 一样大</td>
</tr>
<tr>
<td style="text-align:center"><code>long long</code></td>
<td style="text-align:center">8</td>
<td style="text-align:center">至少 64 位</td>
</tr>
<tr>
<td style="text-align:center"><code>float</code></td>
<td style="text-align:center">4</td>
<td style="text-align:center">IEEE 754 单精度</td>
</tr>
<tr>
<td style="text-align:center"><code>double</code></td>
<td style="text-align:center">8</td>
<td style="text-align:center">IEEE 754 双精度</td>
</tr>
<tr>
<td style="text-align:center"><code>long double</code></td>
<td style="text-align:center">12 或 16</td>
<td style="text-align:center">依平台而定（常见 12B 或 16B 对齐到 16）</td>
</tr>
<tr>
<td style="text-align:center">指针</td>
<td style="text-align:center"><strong>4</strong></td>
<td style="text-align:center">存放地址，32 位宽度</td>
</tr>
</tbody>
</table>
<ul>
<li><strong>64位</strong></li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">大小 (字节)</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>char</code></td>
<td style="text-align:center">1</td>
<td style="text-align:center">依旧是 1 字节</td>
</tr>
<tr>
<td style="text-align:center"><code>short</code></td>
<td style="text-align:center">2</td>
<td style="text-align:center">至少 16 位</td>
</tr>
<tr>
<td style="text-align:center"><code>int</code></td>
<td style="text-align:center">4</td>
<td style="text-align:center">32 位</td>
</tr>
<tr>
<td style="text-align:center"><code>long</code></td>
<td style="text-align:center"><strong>8</strong></td>
<td style="text-align:center"><strong>注意：比 32 位多一倍</strong></td>
</tr>
<tr>
<td style="text-align:center"><code>long long</code></td>
<td style="text-align:center">8</td>
<td style="text-align:center">至少 64 位</td>
</tr>
<tr>
<td style="text-align:center"><code>float</code></td>
<td style="text-align:center">4</td>
<td style="text-align:center">单精度</td>
</tr>
<tr>
<td style="text-align:center"><code>double</code></td>
<td style="text-align:center">8</td>
<td style="text-align:center">双精度</td>
</tr>
<tr>
<td style="text-align:center"><code>long double</code></td>
<td style="text-align:center">16</td>
<td style="text-align:center">常见实现是 16B（对齐到 16）</td>
</tr>
<tr>
<td style="text-align:center">指针</td>
<td style="text-align:center"><strong>8</strong></td>
<td style="text-align:center">存放地址，64 位宽度</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="数组名num和num的区别"><a class="markdownIt-Anchor" href="#数组名num和num的区别"></a> 数组名num和&amp;num的区别</h2>
<ul>
<li>
<p>一维数组</p>
<ul>
<li>num+1 是偏移到下个元素</li>
<li>&amp;num+1是偏移整个数组</li>
</ul>
</li>
<li>
<p>二维数组</p>
<ul>
<li>num+1 是偏移一个一维数组</li>
<li>&amp;num+1是整个数组</li>
</ul>
</li>
<li>
<p>int num[6];</p>
<ul>
<li>
<p>num，类型int*，即首元素的指针</p>
</li>
<li>
<p><strong>&amp;num，类型int (*)[6]，即整个数组地址</strong></p>
</li>
<li>
<p>*num，等价于a[0] —&gt; *(a+i) = a[i]</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Q1：int a[6] = {1, 2, 3, 4, 5, 6};printf(“%d\n”, *(int *)(&amp;a + 1) - 1)的输出</strong></p>
<p>A：(&amp;a + 1)是a + 6， 这里的*(int *)没什么意义,*((int *)(&amp;a + 1) - 1)是a + 5，即6。</p>
</blockquote>
<blockquote>
<p><strong>Q2：char *buff[] = {“char”, “int”, “double”}; printf(“%c\n”, *(buff+1)[1])的输出</strong></p>
<p>A：(buff+1)是&quot;int&quot;，<strong>[]的优先级大于*</strong>，所以*(buff+1)[1]=*(buff+1+1)=*(buff+2)，取&quot;double&quot;的首元素&quot;d&quot;。</p>
<p><strong>Q3：如何不使用sizeof求数据类型字节的大小</strong></p>
<p>#define mysizeof(value)	(char*)(&amp;value+1) - (char*)(&amp;value)</p>
</blockquote>
<h2 id="什么时候用-什么时候用-"><a class="markdownIt-Anchor" href="#什么时候用-什么时候用-"></a> 什么时候用 <code>.</code> ，什么时候用<code>-&gt;</code></h2>
<p><strong><code>.</code>（点运算符）</strong></p>
<ul>
<li>作用于 <strong>对象/结构体变量</strong> 本身。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span> <span class="type">int</span> a; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span>;</span></span><br><span class="line">s.a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p><strong><code>-&gt;</code>（箭头运算符）</strong></p>
<ul>
<li>作用于 <strong>指向结构体/对象的指针</strong>，相当于 <code>(*p).member</code>。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span> <span class="type">int</span> a; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> *<span class="title">p</span> =</span> &amp;s;</span><br><span class="line">p-&gt;a = <span class="number">20</span>; </span><br></pre></td></tr></table></figure>
<blockquote>
<p>变量 → <code>.</code></p>
<p>指针 → <code>-&gt;</code></p>
</blockquote>
<hr />
<h2 id="指针数组和数组指针"><a class="markdownIt-Anchor" href="#指针数组和数组指针"></a> 指针数组和数组指针</h2>
<p><strong>指针数组： int *arr[10];</strong></p>
<p>数组里的<strong>每个元素都是一个指针</strong>，arr是数组名，arr[i]是一个指针。</p>
<p><strong>数组指针： int (*p)[10];</strong></p>
<p><strong>一个指针，指向整个数组</strong></p>
<hr />
<h2 id="指针函数和函数指针"><a class="markdownIt-Anchor" href="#指针函数和函数指针"></a> 指针函数和函数指针</h2>
<p><strong>指针函数：int* func();</strong></p>
<p><strong>函数</strong>的返回值是指针。</p>
<p><strong>函数指针：</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123; <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"><span class="type">int</span> (*fp)(<span class="type">int</span>, <span class="type">int</span>);  <span class="comment">// 声明函数指针</span></span><br><span class="line">fp = add;             <span class="comment">// 让 fp 指向 add</span></span><br><span class="line"><span class="type">int</span> result = fp(<span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 调用函数</span></span><br></pre></td></tr></table></figure>
<p>指向函数的<strong>指针变量</strong></p>
<hr />
<h2 id="常量指针和指针常量"><a class="markdownIt-Anchor" href="#常量指针和指针常量"></a> 常量指针和指针常量</h2>
<p><strong>常量指针：const int *a; / int const *a;</strong></p>
<p><strong>底层Const</strong>，指针<strong>所指内容</strong>是常量，<strong>不能通过指针修改</strong>（但指针可以指向别处）</p>
<p><strong>指针常量：int *const a;</strong></p>
<p><strong>顶层Const</strong>，<strong>指针</strong>本身是常量，<strong>初始化后不能再指向别的地址</strong>。</p>
<hr />
<h2 id="野指针和悬空指针"><a class="markdownIt-Anchor" href="#野指针和悬空指针"></a> 野指针和悬空指针</h2>
<ul>
<li><strong>野指针</strong>：<strong>未初始化或指向不可知区域的指针</strong>。</li>
<li><strong>悬空指针</strong>：<strong>指向的内存已释放</strong>/失效，<strong>但没有置<code>NULL</code></strong>，仍被使用。</li>
</ul>
<blockquote>
<p><strong>避免方法</strong>：指针初始化为 <code>NULL</code>；释放后及时置为 <code>NULL</code>。</p>
</blockquote>
<hr />
<h2 id="free释放内存后指针还能用吗"><a class="markdownIt-Anchor" href="#free释放内存后指针还能用吗"></a> Free释放内存后，指针还能用吗</h2>
<p><strong>不能直接使用</strong>：<code>free</code> 只释放内存，不会清空指针，继续访问会造成 <strong>悬空指针</strong></p>
<blockquote>
<p>但如果非要使用，也是可以的，不过数据可能是<strong>垃圾值</strong></p>
</blockquote>
<hr />
<h2 id="引用是什么有了指针为什么还需要引用"><a class="markdownIt-Anchor" href="#引用是什么有了指针为什么还需要引用"></a> 引用是什么，有了指针为什么还需要引用</h2>
<p><strong>引用</strong>：变量的别名，<strong>和原变量共享同一块内存</strong>。</p>
<p>初始化后不能更换绑定，<strong>不会重新分配内存</strong>。</p>
<ul>
<li>
<p><strong>安全</strong>：引用必须初始化，不能为 <code>NULL</code>。</p>
</li>
<li>
<p><strong>简洁</strong>：用法像普通变量，不需 <code>*</code>、<code>-&gt;</code>。</p>
</li>
<li>
<p><strong>清晰</strong>：函数传参时避免拷贝。</p>
</li>
</ul>
<hr />
<h2 id="数组和链表的区别"><a class="markdownIt-Anchor" href="#数组和链表的区别"></a> 数组和链表的区别</h2>
<ul>
<li><strong>数组</strong>：<strong>连续内存</strong>，存储的是同一类型数据，<strong>支持随机访问，插入/删除效率低</strong>。</li>
<li><strong>链表</strong>：<strong>离散内存</strong>，<strong>插入/删除效率高，查找效率低</strong>。</li>
</ul>
<blockquote>
<p><strong>使用场景</strong>：查询多 → 数组；插入删除多 → 链表。</p>
</blockquote>
<hr />
<h2 id="include-和-include-区别"><a class="markdownIt-Anchor" href="#include-和-include-区别"></a> <code>“#include &quot;&quot;</code> 和 <code>#include &lt;&gt;</code> 区别</h2>
<ul>
<li><strong><code>#include &quot;&quot;</code></strong>：先从<strong>当前目录</strong>查找，再去<strong>系统目录</strong>查找。</li>
<li><strong><code>#include &lt;&gt;</code></strong>：只从<strong>系统目录</strong>查找。</li>
</ul>
<hr />
<h2 id="ifndef-define-endif的作用"><a class="markdownIt-Anchor" href="#ifndef-define-endif的作用"></a> #ifndef #define #endif的作用</h2>
<p>防止头文件被重复包含（“头文件保护”），用来<strong>避免重复定义</strong>、编译错误。</p>
<blockquote>
<p>#program once 和它功能一样</p>
</blockquote>
<h2 id="strlen和sizeof的区别"><a class="markdownIt-Anchor" href="#strlen和sizeof的区别"></a> strlen和sizeof的区别</h2>
<p><strong><code>strlen(s)</code></strong>：计算 <strong>字符串内容长度</strong>（遇到 <code>\0</code> 停止，不含 <code>\0</code>），需在运行时遍历。</p>
<p><strong><code>sizeof(x)</code></strong>：计算 <strong>对象/类型所占内存字节数</strong>，在编译期确定（数组包含 <code>\0</code>，会计算<code>\0</code>的空间）。</p>
<blockquote>
<p><strong>区别</strong>：<code>strlen</code> 得到“内容长度”，<code>sizeof</code> 得到“占用空间”。</p>
<p>计算x[]数组中元素个数：sizeof(x) / sizeof(x[0])</p>
</blockquote>
<hr />
<h2 id="gets和scanf函数的区别"><a class="markdownIt-Anchor" href="#gets和scanf函数的区别"></a> gets和scanf函数的区别</h2>
<p><strong>输入内容</strong></p>
<ul>
<li><code>gets(char *s)</code>：读取一行输入，直到遇到换行符（<code>\n</code>），换行符会被丢弃。</li>
<li><code>scanf(&quot;%s&quot;, s)</code>：读取一个字符串，遇到空格、Tab 或换行符就结束。</li>
</ul>
<p><strong>安全性</strong></p>
<ul>
<li><code>gets</code>：<strong>不安全</strong>，不检查缓冲区大小，容易造成缓冲区溢出（C11 标准已废弃）。</li>
<li><code>scanf(&quot;%s&quot;, ...)</code>：同样可能溢出，但可以通过指定最大宽度控制：</li>
</ul>
<hr />
<h2 id="c语言内存分配的方式"><a class="markdownIt-Anchor" href="#c语言内存分配的方式"></a> C语言内存分配的方式</h2>
<ul>
<li>
<p><strong>静态存储区</strong>：全局变量、静态变量，程序运行期间始终存在。</p>
</li>
<li>
<p><strong>栈（Stack）</strong>：局部变量、函数参数，由编译器自动分配/释放。</p>
</li>
<li>
<p><strong>堆（Heap）</strong>：动态内存（<code>malloc/free</code>、<code>calloc</code>、<code>realloc</code>），由程序员手动管理</p>
</li>
</ul>
<hr />
<h2 id="struct-和-class-的区别"><a class="markdownIt-Anchor" href="#struct-和-class-的区别"></a> struct 和 class 的区别</h2>
<ul>
<li>
<p><strong>在 C++ 中</strong>：</p>
<ul>
<li>
<p><strong>访问权限</strong></p>
<ul>
<li><code>struct</code>：默认成员是 <strong>public</strong>。</li>
<li><code>class</code>：默认成员是 <strong>private</strong>。</li>
</ul>
</li>
<li>
<p><strong>继承方式</strong></p>
<ul>
<li><code>struct</code>：默认是 <strong>public 继承</strong>。</li>
<li><code>class</code>：默认是 <strong>private 继承</strong>。</li>
</ul>
</li>
</ul>
</li>
<li>
<p>除此之外，<strong>两者在功能上基本相同</strong>。</p>
</li>
</ul>
<blockquote>
<p><strong>Q：C和C++里的struct有什么区别呢？</strong></p>
<ul>
<li>
<p><strong>访问权限</strong></p>
<ul>
<li>
<p>C：没有访问控制关键字（全部公开）。</p>
</li>
<li>
<p>C++：默认 <strong>public</strong>，可以使用 <code>public</code> / <code>private</code> / <code>protected</code>。</p>
</li>
</ul>
</li>
<li>
<p><strong>定义函数</strong></p>
<ul>
<li>C：不能包含成员函数。</li>
<li>C++：可以包含 <strong>成员函数、构造函数、析构函数、运算符重载</strong>。</li>
</ul>
</li>
<li>
<p><strong>继承</strong></p>
<ul>
<li>
<p>C：不支持继承。</p>
</li>
<li>
<p>C++：支持继承（默认是 <strong>public 继承</strong>）。</p>
</li>
</ul>
</li>
<li>
<p><strong>定义变量</strong></p>
<ul>
<li>
<p>C：定义变量必须写 <code>struct</code> 关键字（除非用 <code>typedef</code>）。</p>
</li>
<li>
<p>C++：不需要写 <code>struct</code>，和 <code>class</code> 一样用法。</p>
</li>
</ul>
</li>
</ul>
</blockquote>
<hr />
<h2 id="结构体和联合体的区别"><a class="markdownIt-Anchor" href="#结构体和联合体的区别"></a> 结构体和联合体的区别</h2>
<p><strong>结构体 (struct)</strong>：成员 <strong>独立存储</strong>，总大小 ≥ 成员之和，<strong>内存对齐最大类型</strong>。</p>
<p><strong>联合体 (union)</strong>：所有成员 <strong>共用同一块内存</strong>，大小 = 最大成员大小，整体大小也需按 <strong>最大成员的对齐要求</strong> 对齐。</p>
<blockquote>
<p><strong>Q1：下面这个的输出是多少？</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> c[<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> S));</span><br></pre></td></tr></table></figure>
<p>A：结果是12 Byte，char类型对齐int类型的大小</p>
<p><strong>Q2：如何用联合体来判断大小端？</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">U</span> &#123;</span></span><br><span class="line"> <span class="type">int</span>  i;</span><br><span class="line"> <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line"> <span class="class"><span class="keyword">union</span> <span class="title">U</span> <span class="title">u</span>;</span></span><br><span class="line"> u.i = <span class="number">0x1234</span>;</span><br><span class="line"> <span class="keyword">if</span> (u.c == <span class="number">0x12</span>)         </span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;大端\n&quot;</span>); <span class="comment">// 低地址存高字节</span></span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line">     <span class="built_in">printf</span>(<span class="string">&quot;小端\n&quot;</span>); <span class="comment">// 低地址存低字节</span></span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<hr />
<h2 id="宏函数注意点"><a class="markdownIt-Anchor" href="#宏函数注意点"></a> 宏函数注意点</h2>
<ul>
<li>宏函数通过 <code>#define</code> 定义，<strong>预处理阶段替换</strong>，<strong>无类型检查</strong>。</li>
<li><strong>缺点</strong>：可能重复计算参数，调试困难。</li>
<li><strong>改进</strong>：参数和表达式用括号保护，推荐使用 <strong>内联函数</strong> 替代。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SQUARE(x) ((x) * (x))   <span class="comment">// 宏函数</span></span></span><br></pre></td></tr></table></figure>
<hr />
<h2 id="全局变量和局部变量的区别"><a class="markdownIt-Anchor" href="#全局变量和局部变量的区别"></a> 全局变量和局部变量的区别</h2>
<ul>
<li><strong>全局变量</strong>：定义在函数外，作用域是整个文件或程序，<strong>存储在静态区</strong>。</li>
<li><strong>局部变量</strong>：定义在函数/代码块内，<strong>存储在栈</strong>，作用域仅在定义范围内。</li>
</ul>
<hr />
<h2 id="define-typedef-const-的区别"><a class="markdownIt-Anchor" href="#define-typedef-const-的区别"></a> <code>#define</code>、<code>typedef</code>、<code>const</code> 的区别</h2>
<ul>
<li><strong><code>#define</code></strong>：预处理指令，<strong>无类型检查</strong>。</li>
<li><strong><code>typedef</code></strong>：<strong>给类型取别名</strong>，<strong>有类型检查</strong>。</li>
<li><strong><code>const</code></strong>：定义常量，编译器<strong>检查类型</strong>，<strong>分配内存</strong>。</li>
</ul>
<blockquote>
<p>建议：常量用 <code>const</code>，类型别名用 <code>typedef</code>/<code>using</code>，少用 <code>#define</code></p>
<p><strong>特别说明</strong>：</p>
<p><strong>#define</strong> myptr int* p</p>
<p>//a 是 int * a, b 是 <strong>int b</strong></p>
<p>myptr a,b;</p>
<p><strong>typedef</strong> int* myptr;</p>
<p>//a 是 int * a,  b 是 <em><em>int</em> b</em>*</p>
<p>myptr a,b;</p>
</blockquote>
<hr />
<h2 id="static-的作用"><a class="markdownIt-Anchor" href="#static-的作用"></a> static 的作用</h2>
<p><strong>static修饰的参数若不赋值，则默认初始化为0。</strong></p>
<ul>
<li>
<p><strong>在 C 中</strong></p>
<ul>
<li>
<p><strong>局部静态变量</strong>：存放在<strong>静态存储区</strong>，函数退出后仍然存在，下次调用保留上次的值（有记忆的，只会被初始化一次）。</p>
</li>
<li>
<p><strong>全局静态变量</strong>：存放在<strong>静态存储区</strong>，作用域仅限当前文件，避免与其他文件的全局变量冲突。</p>
</li>
<li>
<p><strong>静态函数</strong>：作用域仅限当前文件，避免外部访问。</p>
</li>
</ul>
</li>
<li>
<p><strong>在 C++ 中</strong></p>
<ul>
<li>
<p><strong>静态成员变量</strong>：属于类本身，所有对象共享同一份，不随对象的创建和销毁而改变。</p>
</li>
<li>
<p><strong>静态成员函数</strong>：不依赖对象调用，只能访问类的静态成员，不能访问 <code>this</code> 指针。</p>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="register的作用"><a class="markdownIt-Anchor" href="#register的作用"></a> register的作用</h2>
<p><strong>作用</strong>：提示编译器把变量尽量存放在 <strong>CPU 寄存器</strong> 中，并且是<strong>整数</strong>。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>属于 <strong>存储类说明符</strong>。</li>
<li>只是“建议”，编译器可忽略。</li>
<li><code>register</code> 变量可能没有内存地址，因此 <strong>不能对其使用取地址运算符 <code>&amp;</code></strong>。</li>
</ul>
<hr />
<h2 id="memcpy-和-strcpy-的区别哪个安全"><a class="markdownIt-Anchor" href="#memcpy-和-strcpy-的区别哪个安全"></a> memcpy 和 strcpy 的区别，哪个安全</h2>
<ul>
<li><strong><code>memcpy</code></strong>：按字节拷贝，适合任意类型数据（需指定长度）。</li>
<li><strong><code>strcpy</code></strong>：拷贝字符串，遇到 <code>\0</code> 停止，需保证目标空间足够大。</li>
<li><strong>安全性</strong>：<code>memcpy</code> 更通用更安全；<code>strcpy</code> 可能造成溢出，推荐用 <code>strncpy</code>。</li>
</ul>
<hr />
<h2 id="堆和栈的区别"><a class="markdownIt-Anchor" href="#堆和栈的区别"></a> 堆和栈的区别</h2>
<ul>
<li><strong>栈（Stack）</strong>：<strong>系统自动分配/释放</strong>，空间小，效率高，<strong>向低地址扩张</strong>。</li>
<li><strong>堆（Heap）</strong>：<strong>自己手动申请/释放</strong>，空间大，效率低，<strong>向高地址扩张</strong>。</li>
</ul>
<blockquote>
<p>常见问题：堆使用不当可能导致 <strong>内存泄漏</strong>。</p>
</blockquote>
<hr />
<h2 id="malloc实现原理"><a class="markdownIt-Anchor" href="#malloc实现原理"></a> malloc实现原理</h2>
<p><strong>内存申请方式</strong>：</p>
<ul>
<li>小块内存（&lt; 128K）：通过 <strong><code>brk()</code></strong> 扩展堆顶指针。</li>
<li>大块内存（≥ 128K）：通过 <strong><code>mmap()</code></strong> 直接向内核申请独立内存区域。</li>
</ul>
<p><strong>内存池管理</strong>：</p>
<ul>
<li><code>malloc</code> 会向系统申请一大块内存作为 <strong>堆区</strong>，再划分为多个小块。</li>
<li>用户申请时，从堆区挑选合适的空闲块返回，而不是每次都调用系统接口。</li>
</ul>
<p><strong>空闲块组织</strong>：</p>
<ul>
<li>使用 <strong>隐式链表</strong> 管理空闲块。</li>
<li>每个空闲块会记录自身大小和指向下一块的指针。</li>
<li>分配时可能会 <strong>分割</strong> 空闲块；释放时可能会 <strong>合并</strong> 相邻块，减少碎片。</li>
</ul>
<blockquote>
<p>malloc 采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将 堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链 表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址</p>
</blockquote>
<hr />
<h2 id="malloc-和-new-的区别"><a class="markdownIt-Anchor" href="#malloc-和-new-的区别"></a> malloc 和 new 的区别</h2>
<ul>
<li><strong>malloc</strong>（C语言<strong>库函数</strong>）：<strong>需要手动计算内存大小</strong>，返回 <code>void*</code>，需手动 <code>free</code>。<strong>不会调用构造函数</strong>。</li>
<li><strong>new</strong>（C++ <strong>运算符</strong>）：<strong>类型安全</strong>，分配内存并调用构造函数，失败抛出异常，需用 <code>delete</code> 释放，返回具体类型指针。</li>
</ul>
<hr />
<h2 id="malloc-calloc-realloc-内存申请函数"><a class="markdownIt-Anchor" href="#malloc-calloc-realloc-内存申请函数"></a> malloc、calloc、realloc 内存申请函数</h2>
<p><strong><code>malloc(size)</code></strong></p>
<ul>
<li>分配指定字节大小的内存，<strong>内容不初始化</strong>（可能是垃圾值）。</li>
</ul>
<p><strong><code>calloc(n, size)</code></strong></p>
<ul>
<li>分配 <code>n * size</code> 字节，并<strong>全部置零</strong>。</li>
</ul>
<p><strong><code>realloc(ptr, size)</code></strong></p>
<ul>
<li>调整已分配内存大小：<strong>扩容或缩小</strong>，可能搬移到新地址。</li>
</ul>
<hr />
<h2 id="被free回收的内存是立即返还给操作系统吗"><a class="markdownIt-Anchor" href="#被free回收的内存是立即返还给操作系统吗"></a> 被free回收的内存是立即返还给操作系统吗</h2>
<p>不会，而是交给C的堆分配器。</p>
<p><strong>内存分配器机制（以 <code>ptmalloc</code> 为例）</strong></p>
<ul>
<li>
<p>内部维护多个 <strong>空闲链表（bins）</strong>。</p>
</li>
<li>
<p>使用 <strong>双向链表管理空闲块</strong>。</p>
</li>
<li>
<p>支持 <strong>相邻空闲块合并</strong>，减少碎片。</p>
</li>
<li>
<p>小块用 <code>sbrk()</code> 分配，大块可能用 <code>mmap()</code>。</p>
</li>
</ul>
<hr />
<h2 id="内存泄漏是什么"><a class="markdownIt-Anchor" href="#内存泄漏是什么"></a> 内存泄漏是什么</h2>
<p>程序通过 <code>malloc/new</code> 申请了内存，但在使用完后没有通过 <code>free/delete</code> 释放，导致这部分内存无法再被使用或回收。</p>
<p><strong>影响</strong>：长期运行会占满内存，导致程序变慢甚至崩溃。</p>
<blockquote>
<p>Q：如何避免？</p>
<ul>
<li>
<p>申请和释放配对使用 (<code>malloc/free</code>, <code>new/delete</code>)。</p>
</li>
<li>
<p>避免重复释放或遗忘释放。</p>
</li>
<li>
<p>推荐使用 <strong>智能指针</strong>（C++）管理内存。</p>
</li>
</ul>
</blockquote>
<hr />
<h2 id="深拷贝和浅拷贝的区别"><a class="markdownIt-Anchor" href="#深拷贝和浅拷贝的区别"></a> 深拷贝和浅拷贝的区别</h2>
<ul>
<li><strong>浅拷贝</strong>：复制指针，<strong>不复制实际资源</strong> → <strong>多个指针对象指向同一块内存</strong>。</li>
<li><strong>深拷贝</strong>：复制内容，<strong>独立资源</strong> → 避免内存释放冲突。</li>
</ul>
<hr />
<h2 id="程序分为几个段"><a class="markdownIt-Anchor" href="#程序分为几个段"></a> 程序分为几个段</h2>
<p>典型的 C/C++ 程序在内存中分为：</p>
<ul>
<li><strong>代码段（text）</strong>：存放<strong>只读存储区</strong>和<strong>文本区</strong>。</li>
<li><strong>数据段（data）</strong>：存放<strong>已初始化的全局变量、静态变量</strong>。</li>
<li><strong>BSS 段</strong>：存放<strong>未初始化的全局变量、静态变量</strong>。</li>
<li><strong>堆（heap）</strong>：<strong>动态分配</strong>的内存。</li>
<li><strong>共享内存段</strong>：<strong>存储动态链接库</strong>以及调用mmap函数的文件映射</li>
<li><strong>栈（stack）</strong>：<strong>局部变量、函数的参数，函数的返回值</strong>。</li>
</ul>
<hr />
<h2 id="一个-c-文件怎么转换为可执行程序"><a class="markdownIt-Anchor" href="#一个-c-文件怎么转换为可执行程序"></a> 一个 .c 文件怎么转换为可执行程序</h2>
<ul>
<li>
<p><strong>预处理</strong>：宏展开、头文件展开，生成 <code>.i</code> 文件。</p>
<ul>
<li><strong>将所有的#define删除</strong>，并且展开所有的宏定义</li>
<li><strong>处理所有的条件预编译指令</strong>，如#if、#ifdef</li>
<li><strong>处理#include预编译指令</strong></li>
<li><strong>过滤注释</strong></li>
<li>添加行号和文件名标识</li>
</ul>
</li>
<li>
<p><strong>编译</strong>：把预处理结果转为汇编代码 <code>.s</code>。</p>
<ul>
<li>目标代码生成：<strong>生成汇编代码</strong></li>
<li>目标<strong>代码优化</strong></li>
</ul>
</li>
<li>
<p><strong>汇编</strong>：汇编器将 <code>.s</code> 转为机器码 <code>.o</code>。</p>
<ul>
<li>汇编代码转变成机器可以执行的指令</li>
</ul>
</li>
<li>
<p><strong>链接</strong>：把多个目标文件和库链接成可执行文件。</p>
<ul>
<li>不同的源文件产生的目标文件进行链接</li>
</ul>
</li>
</ul>
<blockquote>
<p>过程：.c —&gt; .i —&gt; .s —&gt; .o</p>
</blockquote>
<hr />
<h2 id="静态链接和动态链接的区别"><a class="markdownIt-Anchor" href="#静态链接和动态链接的区别"></a> 静态链接和动态链接的区别</h2>
<ul>
<li><strong>静态链接</strong>：<strong>库函数编译时直接打包进可执行文件</strong>。
<ul>
<li>优点：独立运行；</li>
<li>缺点：体积大，更新麻烦。</li>
</ul>
</li>
<li><strong>动态链接</strong>：<strong>运行时加载共享库</strong>。
<ul>
<li>优点：节省空间，易更新；</li>
<li>缺点：依赖库文件。</li>
</ul>
</li>
</ul>
<hr />
<h2 id="strcpy-sprintf和memcpy的区别"><a class="markdownIt-Anchor" href="#strcpy-sprintf和memcpy的区别"></a> strcpy、sprintf和memcpy的区别</h2>
<ul>
<li>
<p><code>strcpy</code>：仅用于<strong>字符串</strong>，<strong>必须有 <code>\0</code> 结尾</strong>；有缓冲区溢出分险，建议用strncpy。</p>
</li>
<li>
<p><code>sprintf</code>：用于<strong>格式化文本</strong>（带数字、拼接等），<strong>输出到字符串</strong>；不检查越界，建议用snprintf。</p>
</li>
<li>
<p><code>memcpy</code>：<strong>拷贝任意内存</strong>，包括结构体、数组等，适用于“非字符串”。</p>
</li>
</ul>
<blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="type">char</span> buf[<span class="number">100</span>];</span><br><span class="line">&gt;<span class="type">int</span> id = <span class="number">42</span>;</span><br><span class="line">&gt;<span class="type">const</span> <span class="type">char</span>* name = <span class="string">&quot;Alice&quot;</span>;</span><br><span class="line">&gt;<span class="built_in">sprintf</span>(buf, <span class="string">&quot;User %d: %s&quot;</span>, id, name);</span><br><span class="line">&gt;<span class="comment">// buf内容是：User 42: Alice</span></span><br></pre></td></tr></table></figure>
</blockquote>
<hr />
<h2 id="a-和-a-的区别"><a class="markdownIt-Anchor" href="#a-和-a-的区别"></a> ++a 和 a++ 的区别</h2>
<ul>
<li>
<p><strong>++a</strong>：<strong>先自加</strong>，<strong>不开辟空间</strong>，效率更高。</p>
</li>
<li>
<p><strong>a++</strong>：<strong>需要开辟空间</strong>。</p>
</li>
</ul>
<hr />
<h2 id="和-的作用"><a class="markdownIt-Anchor" href="#和-的作用"></a> # 和 ## 的作用</h2>
<p><strong><code>#</code>（字符串化）</strong></p>
<ul>
<li>
<p>把宏参数转成 <strong>字符串</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define TO_STR(x) #x</span><br><span class="line">printf(&quot;%s&quot;, TO_STR(Hello)); // 输出 &quot;Hello&quot;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong><code>##</code>（连接符/粘合剂）</strong></p>
<ul>
<li>
<p>把宏参数和其他标识符<strong>拼接</strong>在一起。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define VAR(n) var##n</span><br><span class="line">int VAR(1) = 10;   // 变成 int var1 = 10;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr />
<h2 id="不适用额外空间交换两个数"><a class="markdownIt-Anchor" href="#不适用额外空间交换两个数"></a> 不适用额外空间，交换两个数</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 算术</span></span><br><span class="line">x = x + y;</span><br><span class="line">y = x - y;</span><br><span class="line">x = x - y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异或(只能对char和int)（了解）</span></span><br><span class="line">x = x ^ y;</span><br><span class="line">y = x ^ y;</span><br><span class="line">x = x ^ y;</span><br><span class="line">y = y ^ x;</span><br><span class="line">x = x ^ y;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="局部变量能不能和全局变量重名"><a class="markdownIt-Anchor" href="#局部变量能不能和全局变量重名"></a> 局部变量能不能和全局变量重名</h2>
<p><strong>可以重名，局部变量会屏蔽同名的全局变量</strong>，在作用域内优先使用局部变量。</p>
<hr />
<h2 id="c-语言位域bit-field了解"><a class="markdownIt-Anchor" href="#c-语言位域bit-field了解"></a> C 语言位域（Bit-field）（了解）</h2>
<ul>
<li><strong>定义</strong>：在 <code>struct</code> 中，用指定位数存放成员，节省空间。</li>
<li><strong>用途</strong>：常用于 <strong>硬件寄存器映射</strong>、<strong>标志位集合</strong>。</li>
<li><strong>注意</strong>：位域排布依赖编译器/平台，移植性差。</li>
</ul>
<blockquote>
<p><strong>示例</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Flags</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> a : <span class="number">1</span>;  <span class="comment">// 1 bit</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> b : <span class="number">3</span>;  <span class="comment">// 3 bit</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> c : <span class="number">4</span>;  <span class="comment">// 4 bit</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<hr />
<h2 id="用位运算计算余数了解"><a class="markdownIt-Anchor" href="#用位运算计算余数了解"></a> 用位运算计算余数（了解）</h2>
<p>只了解到可以<strong>对2的幂进行取余</strong>操作</p>
<ul>
<li><strong>对 2 的幂取余</strong>：<code>x % (2^n) == x &amp; (2^n - 1)</code></li>
</ul>
<blockquote>
<p>例：<code>13 % 8 == 13 &amp; 7 == 5</code>。</p>
</blockquote>
<hr />
<h2 id="取消内存对齐的方法了解"><a class="markdownIt-Anchor" href="#取消内存对齐的方法了解"></a> 取消内存对齐的方法（了解）</h2>
<ul>
<li><strong>GCC</strong>：<code>__attribute__((packed))</code></li>
<li><strong>MSVC</strong>：<code>#pragma pack(1)</code></li>
</ul>
<hr />
<h2 id="什么是回调函数"><a class="markdownIt-Anchor" href="#什么是回调函数"></a> 什么是回调函数</h2>
<ul>
<li>一个<strong>函数作为参数传递</strong>给另一个函数，被在特定时机调用。</li>
<li>常用于 <strong>事件驱动</strong>、<strong>异步处理</strong>。</li>
</ul>
<blockquote>
<p>比如Bootloader执行完MSR_SP后，就需要加载回调函数load()。</p>
</blockquote>
<hr />
<h2 id="如何判断一个整数是有符号还是无符号"><a class="markdownIt-Anchor" href="#如何判断一个整数是有符号还是无符号"></a> 如何判断一个整数是有符号还是无符号</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> isunsing(a) ((a &gt;= 0) &amp;&amp; (~a &gt;= 0))</span></span><br></pre></td></tr></table></figure>
<hr />
<h2 id="面向对象和面向过程的区别"><a class="markdownIt-Anchor" href="#面向对象和面向过程的区别"></a> 面向对象和面向过程的区别</h2>
<p><strong>面向过程 (Procedure-Oriented)</strong></p>
<ul>
<li>强调 <strong>过程/函数</strong>，把问题拆解成步骤。</li>
<li>数据与函数分离。</li>
</ul>
<p><strong>面向对象 (Object-Oriented)</strong></p>
<ul>
<li>强调 <strong>对象</strong>，数据和操作绑定在一起。</li>
<li>支持 <strong>封装、继承、多态</strong>。</li>
</ul>
<hr />
<h2 id="面向对象的三大特征"><a class="markdownIt-Anchor" href="#面向对象的三大特征"></a> 面向对象的三大特征</h2>
<ul>
<li>
<p><strong>封装</strong></p>
<ul>
<li><strong>概念</strong>：把数据和操作打包在类里，隐藏实现细节，对外只暴露必要接口。</li>
<li><strong>C++ 实现</strong>：<code>class</code> / <code>struct</code> + <strong>访问控制符</strong>（<code>public</code>、<code>protected</code>、<code>private</code>）。</li>
<li><strong>作用</strong>：提高模块化与安全性，防止随意修改内部数据。</li>
</ul>
</li>
<li>
<p><strong>继承</strong></p>
<ul>
<li><strong>概念</strong>：子类自动获得父类已有的成员与方法，可以复用或扩展。</li>
<li><strong>C++ 实现</strong>：<code>class Derived : public Base &#123; ... &#125;;</code></li>
<li><strong>作用</strong>：代码复用，形成层次结构，支持多级继承。</li>
</ul>
</li>
<li>
<p><strong>多态</strong></p>
<ul>
<li>
<p><strong>概念</strong>：同一接口在不同对象上表现出不同的行为。</p>
</li>
<li>
<p><strong>C++ 实现</strong>：</p>
<ul>
<li><strong>编译期多态</strong>：函数重载、运算符重载（通过名字/参数列表区分）。</li>
<li><strong>运行期多态</strong>：虚函数 + 基类指针/引用调用派生类实现（依赖 <code>virtual</code> 关键字 + 动态绑定）。</li>
</ul>
</li>
<li>
<p><strong>作用</strong>：提高灵活性，便于扩展。</p>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="c-类的访问权限"><a class="markdownIt-Anchor" href="#c-类的访问权限"></a> C++ 类的访问权限</h2>
<ul>
<li><strong>public</strong>：对所有代码可见。</li>
<li><strong>protected</strong>：仅类本身和派生类可见。</li>
<li><strong>private</strong>：仅类本身可见。</li>
</ul>
<hr />
<h2 id="重载-重写-覆盖"><a class="markdownIt-Anchor" href="#重载-重写-覆盖"></a> 重载、重写、覆盖</h2>
<ul>
<li><strong>重载（Overload）</strong>
<ul>
<li><strong>概念</strong>：同一个作用域内，<strong>函数名相同</strong>，但 <strong>参数列表不同</strong>（个数或类型不同）。</li>
<li><strong>发生位置</strong>：同一个类中（或全局函数）。</li>
<li><strong>关键点</strong>：编译期根据实参匹配 → <strong>静态多态</strong>。</li>
</ul>
</li>
<li><strong>重写（Override）</strong>
<ul>
<li><strong>概念</strong>：派生类中 <strong>重新定义</strong> 基类的 <strong>虚函数</strong>，<strong>函数名必须相同</strong>。</li>
<li><strong>发生位置</strong>：继承体系中。</li>
<li><strong>关键点</strong>：运行时通过虚表决定调用 → <strong>动态多态</strong>。</li>
</ul>
</li>
<li><strong>隐藏（Hide/Overwrite）</strong>
<ul>
<li><strong>概念</strong>：<strong>派生类</strong>定义了一个<strong>与基类同名但非虚函数</strong>或 <strong>参数列表不同的函数</strong>，<strong>会隐藏基类的同名函数</strong>。</li>
<li><strong>结果</strong>：基类版本被“遮蔽”，不是严格的多态。</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>
<p><strong>重载</strong>：同域，同名，不同参数 → 编译期多态。</p>
</li>
<li>
<p><strong>重写</strong>：继承，虚函数，相同签名 → 运行时多态。</p>
</li>
<li>
<p><strong>覆盖</strong>：继承，同名但非虚函数或不同签名 → 基类函数被隐藏。</p>
</li>
</ul>
</blockquote>
<hr />
<h2 id="什么是智能指针c-的智能指针有哪些作用是什么"><a class="markdownIt-Anchor" href="#什么是智能指针c-的智能指针有哪些作用是什么"></a> 什么是智能指针，C++ 的智能指针有哪些，作用是什么</h2>
<ul>
<li><strong>作用</strong>：自动管理内存，避免<code>new/delete</code> 手工管理带来的内存泄漏。</li>
<li><strong>C++ 智能指针</strong>：
<ul>
<li><code>std::auto_ptr</code>（C++11 废弃）。</li>
<li><code>std::unique_ptr</code>：独占所有权→ 同一时间<strong>只能有一个指针指向资源</strong>，不能拷贝，只能移动。</li>
<li><code>std::shared_ptr</code>：引用计数共享所有权 → <strong>多个指针可以同时指向资源</strong>，内部用 <strong>引用计数</strong> 管理，最后一个销毁时释放内存。</li>
<li><code>std::weak_ptr</code>：弱引用 → 不增加引用计数，用来观察 <code>shared_ptr</code> 管理的对象，解决循环引用问题。</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>这里的<strong>所有权 (ownership)</strong> 指 <strong>谁负责在对象生命周期结束时释放内存</strong>。</li>
</ul>
<p><strong>Q：为什么auto_ptr会被废弃？</strong></p>
<ul>
<li><code>auto_ptr</code> 拷贝/赋值时，会把所有权转移（源指针变空）。</li>
<li>容易导致意外失效，比如容器里的元素被拷贝后全部失效。</li>
</ul>
</blockquote>
<hr />
<h2 id="c有几种new"><a class="markdownIt-Anchor" href="#c有几种new"></a> C++有几种new</h2>
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th style="text-align:center">语法示例</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">普通 <code>new</code>（plain new）</td>
<td style="text-align:center"><code>int* p = new int(5);</code></td>
<td style="text-align:center"><strong>分配内存并调用构造函数</strong></td>
</tr>
<tr>
<td style="text-align:center"><code>placement new</code></td>
<td style="text-align:center"><code>new(ptr) Type(args);</code></td>
<td style="text-align:center"><strong>在已有内存上构造对象</strong></td>
</tr>
<tr>
<td style="text-align:center"><code>nothrow new</code></td>
<td style="text-align:center"><code>int* p = new(std::nothrow) int;</code></td>
<td style="text-align:center"><strong>分配失败返回 nullptr，不抛异常</strong></td>
</tr>
</tbody>
</table>
<hr />
<h2 id="c有几种强制转换"><a class="markdownIt-Anchor" href="#c有几种强制转换"></a> C++有几种强制转换</h2>
<table>
<thead>
<tr>
<th style="text-align:center">转换类型</th>
<th style="text-align:center">语法示例</th>
<th style="text-align:center">用途简述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>static_cast</code></td>
<td style="text-align:center"><code>static_cast&lt;int&gt;(3.14)</code></td>
<td style="text-align:center">普通转换（类型安全）如基本类型、父子类指针转换</td>
</tr>
<tr>
<td style="text-align:center"><code>dynamic_cast</code></td>
<td style="text-align:center"><code>dynamic_cast&lt;Derived*&gt;(basePtr)</code></td>
<td style="text-align:center">向下转型（需 RTTI）父类 → 子类，失败时返回 nullptr</td>
</tr>
<tr>
<td style="text-align:center"><code>const_cast</code></td>
<td style="text-align:center"><code>const_cast&lt;char*&gt;(cstr)</code></td>
<td style="text-align:center">加/去 const</td>
</tr>
<tr>
<td style="text-align:center"><code>reinterpret_cast</code></td>
<td style="text-align:center"><code>reinterpret_cast&lt;int*&gt;(p)</code></td>
<td style="text-align:center"><strong>按位重解释</strong>（低级暴力）能转但风险高！</td>
</tr>
</tbody>
</table>
<hr />
<h2 id="隐式转换如何消除它"><a class="markdownIt-Anchor" href="#隐式转换如何消除它"></a> 隐式转换，如何消除它</h2>
<p><strong>编译器自动帮你做的类型转换</strong>，不需要你写 <code>cast</code> 或构造函数，常在赋值、传参、运算中发生。</p>
<ul>
<li>使用 <code>explicit</code> 关键字</li>
<li>使用 <code>delete</code> 禁用不想要的转换</li>
<li>使用强转类型转换（明确表达）</li>
</ul>
<hr />
<h2 id="cout和printf的区别了解"><a class="markdownIt-Anchor" href="#cout和printf的区别了解"></a> cout和printf的区别（了解）</h2>
<p>cout和printf都是输出对应数据，而<strong>cout有缓冲输出，使用flush立即强迫缓冲输出</strong>。</p>
<hr />
<h2 id="什么是虚函数"><a class="markdownIt-Anchor" href="#什么是虚函数"></a> 什么是虚函数</h2>
<ul>
<li>
<p><strong>定义</strong>：用 <code>virtual</code> 修饰的成员函数；用于<strong>运行时多态</strong>（动态绑定）。</p>
</li>
<li>
<p><strong>机制（实现惯例）</strong>：每个多态对象含一根 <strong>虚指针</strong>指向 <strong>虚函数表</strong>；通过 虚函数表 在运行时决定调用哪个函数实现。</p>
</li>
</ul>
<blockquote>
<p><strong>虚函数</strong>是<strong>类定义的</strong>，但<strong>调用</strong>属于<strong>对象</strong></p>
<p><strong>虚函数</strong>位于<strong>文本段</strong>(.text)，<strong>虚函数表</strong>位于<strong>数据段</strong>(.data)</p>
</blockquote>
<hr />
<h2 id="什么是纯虚函数"><a class="markdownIt-Anchor" href="#什么是纯虚函数"></a> 什么是纯虚函数</h2>
<p><strong>定义</strong>：在基类中声明但<strong>没有实现</strong>的虚函数，语法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtual <span class="type">void</span> <span class="title function_">func</span><span class="params">()</span> = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p><strong>特点</strong>：</p>
<ol>
<li>含有纯虚函数的类是 <strong>抽象类</strong>，不能实例化。</li>
<li>常用于定义 <strong>接口/规范</strong>。</li>
</ol>
<blockquote>
<p><strong>Q：纯虚函数和虚函数的区别？</strong></p>
<p>A：纯虚函数只是相当于一个接口名。</p>
</blockquote>
<hr />
<h2 id="c中如何阻止一个类被实例化"><a class="markdownIt-Anchor" href="#c中如何阻止一个类被实例化"></a> C++中如何阻止一个类被实例化</h2>
<ul>
<li><strong>构造函数</strong>设为 <code>private/protected</code></li>
<li><strong>纯虚析构函数</strong>（<strong>抽象类</strong>）</li>
</ul>
<hr />
<h2 id="什么函数不能声明为虚函数"><a class="markdownIt-Anchor" href="#什么函数不能声明为虚函数"></a> 什么函数不能声明为虚函数</h2>
<ul>
<li>
<p><strong>构造函数</strong>：对象还没完全构造，不能通过虚表实现多态。</p>
</li>
<li>
<p><strong>静态成员函数</strong>：不依赖对象（没有 <code>this</code> 指针），无法放入虚表。</p>
</li>
<li>
<p><strong>内联函数</strong>（<code>inline</code>）：可以是虚函数，但一旦被声明为虚函数，就<strong>失去强制内联的意义</strong>。</p>
</li>
<li>
<p><strong>友元函数</strong>：不属于类成员，不能放入虚表。</p>
</li>
<li>
<p><strong>模板函数</strong>：普通模板函数不能直接虚化。</p>
</li>
</ul>
<hr />
<h2 id="为什么c默认的析构函数不是虚函数"><a class="markdownIt-Anchor" href="#为什么c默认的析构函数不是虚函数"></a> 为什么C++默认的析构函数不是虚函数</h2>
<ul>
<li>
<p>普通类通常 <strong>不会被继承</strong>，非虚析构更高效。</p>
</li>
<li>
<p>只有涉及 <strong>多态使用（基类指针/引用指向派生类对象）</strong> 时，才需要虚析构。</p>
</li>
</ul>
<hr />
<h2 id="为什么析构函数必须是虚函数"><a class="markdownIt-Anchor" href="#为什么析构函数必须是虚函数"></a> 为什么析构函数必须是虚函数</h2>
<ul>
<li>
<p>如果通过 <strong>基类指针删除派生类对象</strong>，没有虚析构会只调用基类析构，导致派生类资源未释放 → <strong>内存泄漏/未定义行为</strong>。</p>
</li>
<li>
<p>设为虚函数，能保证删除时按正确的继承层次依次调用析构函数。</p>
</li>
</ul>
<hr />
<h2 id="静态函数和虚函数的区别"><a class="markdownIt-Anchor" href="#静态函数和虚函数的区别"></a> 静态函数和虚函数的区别</h2>
<p><strong>静态函数（static）</strong></p>
<ul>
<li>属于<strong>类本身，不依赖对象</strong>。</li>
<li>不能访问非静态成员（没有 <code>this</code> 指针）。</li>
<li>调用方式：<code>ClassName::func()</code>。</li>
<li>绑定方式：<strong>编译期绑定</strong>（静态绑定）。</li>
</ul>
<p><strong>虚函数（virtual）</strong></p>
<ul>
<li><strong>属于对象</strong>，支持 <strong>运行时多态</strong>。</li>
<li>通过虚函数表（vtable）在运行时决定调用哪个版本。</li>
<li>必须通过对象或对象指针/引用调用。</li>
<li>绑定方式：<strong>运行时绑定</strong>（动态绑定）。</li>
</ul>
<hr />
<h2 id="构造函数有几种分别什么作用"><a class="markdownIt-Anchor" href="#构造函数有几种分别什么作用"></a> 构造函数有几种，分别什么作用</h2>
<ul>
<li><strong>默认构造函数</strong>
<ul>
<li>无参数或参数有默认值。</li>
<li>作用：<strong>创建对象时提供默认初始化</strong>。</li>
</ul>
</li>
<li><strong>有参构造函数</strong>
<ul>
<li>带参数。</li>
<li>作用：用指定值初始化对象。</li>
</ul>
</li>
<li><strong>拷贝构造函数</strong>
<ul>
<li>形如 <code>Class(const Class&amp; obj)</code>。</li>
<li>作用：用<strong>已有对象初始化新对象</strong>（值传递/返回对象时会调用）。</li>
</ul>
</li>
<li><strong>移动构造函数（C++11）</strong>
<ul>
<li>形如 <code>Class(Class&amp;&amp; obj)</code>。</li>
<li>作用：<strong>接管临时对象的资源</strong>，避免拷贝开销。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>拓展：</strong></p>
<ul>
<li><strong>委托构造函数（C++11）</strong>
<ul>
<li>一个构造函数调用同类的另一个构造函数。</li>
<li>作用：减少代码重复。</li>
</ul>
</li>
<li><strong>显式构造函数（explicit）</strong>
<ul>
<li>用 <code>explicit</code> 修饰。</li>
<li>作用：防止隐式类型转换。</li>
</ul>
</li>
</ul>
</blockquote>
<hr />
<h2 id="构造函数和析构函数执行顺序"><a class="markdownIt-Anchor" href="#构造函数和析构函数执行顺序"></a> 构造函数和析构函数执行顺序</h2>
<ul>
<li>构造函数
<ul>
<li><strong>基类</strong>构造函数</li>
<li><strong>成员类</strong>对象构造函数</li>
<li><strong>派生类</strong>构造函数</li>
</ul>
</li>
<li>析构函数
<ul>
<li><strong>派生类</strong>析构函数</li>
<li><strong>成员类</strong>对象析构函数</li>
<li><strong>基类</strong>析构函数</li>
</ul>
</li>
</ul>
<hr />
<h2 id="构造函数-拷贝构造函数和赋值运算符的区别"><a class="markdownIt-Anchor" href="#构造函数-拷贝构造函数和赋值运算符的区别"></a> 构造函数、拷贝构造函数和赋值运算符的区别</h2>
<ul>
<li><strong>构造函数</strong>：<strong>对象不存在</strong>，<strong>创建一个新对象</strong>时调用</li>
<li><strong>拷贝构造函数</strong>：<strong>对象不存在</strong>，用别的<strong>已经存在的对象来初始化</strong></li>
<li><strong>赋值运算符</strong>：<strong>对象存在</strong>，用<strong>别的对象给它赋值</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">const</span> A&amp; a)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;拷贝构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    A&amp; <span class="keyword">operator</span> = (A&amp; a)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;赋值运算符&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">A</span>()&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A a1;		<span class="comment">//构造函数</span></span><br><span class="line">    A a2 = a1;	<span class="comment">//拷贝构造</span></span><br><span class="line">    a2 = a1;	<span class="comment">//赋值运算符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line"><span class="comment">//赋值运算符</span></span><br></pre></td></tr></table></figure>
<hr />
<h2 id="只定义析构函数会自动生成哪些构造函数"><a class="markdownIt-Anchor" href="#只定义析构函数会自动生成哪些构造函数"></a> 只定义析构函数，会自动生成哪些构造函数</h2>
<ul>
<li><strong>默认构造函数</strong></li>
<li><strong>拷贝构造函数</strong></li>
<li><strong>拷贝赋值运算符</strong></li>
</ul>
<hr />
<h2 id="一个类默认会生成哪些函数"><a class="markdownIt-Anchor" href="#一个类默认会生成哪些函数"></a> 一个类默认会生成哪些函数</h2>
<ul>
<li>
<p><strong>无参构造函数</strong>（默认构造函数）</p>
</li>
<li>
<p><strong>拷贝构造函数</strong></p>
</li>
<li>
<p><strong>拷贝赋值运算符</strong> (<code>operator=</code>)</p>
</li>
<li>
<p><strong>析构函数</strong>（非虚，除非基类里有虚函数）</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与上方一一对应</span></span><br><span class="line"><span class="built_in">Empty</span>();</span><br><span class="line"><span class="built_in">Empty</span>(<span class="type">const</span> Empty&amp;);</span><br><span class="line">Empty&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Empty&amp;);</span><br><span class="line">~<span class="built_in">Empty</span>();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在 C++11 及以后，可能还会自动生成：</p>
<ul>
<li><strong>移动构造函数</strong></li>
<li><strong>移动赋值运算符</strong></li>
</ul>
</blockquote>
<hr />
<h2 id="什么是虚拟继承"><a class="markdownIt-Anchor" href="#什么是虚拟继承"></a> 什么是虚拟继承</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A&#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; <span class="built_in">sizeof</span>(A) &lt;&lt; endl;	<span class="comment">// 1，空对象</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(B) &lt;&lt; <span class="built_in">sizeof</span>(B) &lt;&lt; endl;	<span class="comment">// 4，一个bptr指针</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(C) &lt;&lt; <span class="built_in">sizeof</span>(C) &lt;&lt; endl;	<span class="comment">// 4，一个bptr指针</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">sizeof</span>(D) &lt;&lt; <span class="built_in">sizeof</span>(D) &lt;&lt; endl;	<span class="comment">// 8，两个bptr指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述中B和C虚拟继承A，D又继承B和C，这种方式是<strong>菱形继承/钻石继承</strong>，无论基类被继承多少次，只会存在一个实体。</p>
<h2 id="指针和引用的区别"><a class="markdownIt-Anchor" href="#指针和引用的区别"></a> 指针和引用的区别</h2>
<ul>
<li>
<p><strong>指针存地址</strong>，<strong>引用</strong>是<strong>变量别名</strong>。</p>
</li>
<li>
<p><strong>指针可为空</strong>，<strong>引用</strong>必须初始化且<strong>不可为空</strong>。</p>
</li>
<li>
<p><strong>指针可多级，引用只有一级</strong>。</p>
</li>
<li>
<p><strong>指针能改变指向</strong>；<strong>引用</strong>绑定后<strong>不可改变指向</strong>。</p>
</li>
</ul>
<hr />
<h2 id="什么时候指针什么时候引用"><a class="markdownIt-Anchor" href="#什么时候指针什么时候引用"></a> 什么时候指针，什么时候引用</h2>
<ul>
<li>
<p><strong>用指针的场景</strong></p>
<ul>
<li>
<p>参数可以为空。</p>
</li>
<li>
<p>需要在函数中改变指向。</p>
</li>
<li>
<p>需要返回函数内部申请的内存。</p>
</li>
<li>
<p>与 C 接口交互（C 风格就是指针）。</p>
</li>
</ul>
</li>
<li>
<p><strong>用引用的场景</strong></p>
<ul>
<li>
<p>必须有对象，不允许空。</p>
</li>
<li>
<p>对空间敏感（如递归、大对象），<strong>引用避免拷贝，开销小</strong>。</p>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="类如何实现只能静态分配和只能动态分配"><a class="markdownIt-Anchor" href="#类如何实现只能静态分配和只能动态分配"></a> 类如何实现只能静态分配和只能动态分配</h2>
<ul>
<li><strong>只能静态分配</strong>：把<strong>new、delete重载</strong>为<strong>private</strong>属性</li>
<li><strong>只能动态分配</strong>：把<strong>构造、析构</strong>函数设为<strong>protected</strong>属性，再用子类动态创建</li>
</ul>
<hr />
<h2 id="什么是静态绑定和动态绑定"><a class="markdownIt-Anchor" href="#什么是静态绑定和动态绑定"></a> 什么是静态绑定和动态绑定</h2>
<ul>
<li>
<p><strong>静态绑定</strong>：<strong>编译</strong>时决定，<strong>非虚函数</strong>，效率高，<strong>无需特殊关键字说明</strong>。</p>
</li>
<li>
<p><strong>动态绑定</strong>：<strong>运行</strong>时决定，<strong>虚函数 + 指针/引用</strong>，支持<strong>多态</strong>（<code>virtual</code>、<code>override</code>）。</p>
</li>
</ul>
<hr />
<h2 id="结构体变量比较是否相等"><a class="markdownIt-Anchor" href="#结构体变量比较是否相等"></a> 结构体变量比较是否相等</h2>
<p><strong>C语言</strong></p>
<ul>
<li><strong>不支持 <code>==</code> 比较结构体变量</strong>。</li>
<li><strong>必须手动逐个字段比较</strong>，或用 <code>memcmp</code>（不推荐，可能有填充位）。</li>
</ul>
<p><strong>C<ins>98 / C</ins>11 / C<ins>14 / C</ins>17</strong></p>
<ul>
<li>默认不支持结构体比较。</li>
<li>需要<strong>手动重载 <code>operator==</code></strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> Point&amp; other) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x == other.x &amp;&amp; y == other.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>C++20及以上</strong></p>
<ul>
<li>支持结构体自动生成比较操作（<strong>需要使用 <code>= default</code></strong>）。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line">    <span class="keyword">auto</span> <span class="built_in">operator</span>&lt;=&gt;(<span class="type">const</span> Point&amp;) <span class="type">const</span> = <span class="keyword">default</span>;  <span class="comment">// 自动生成 ==、&lt;、&lt;=、&gt; 等</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="内联函数inline"><a class="markdownIt-Anchor" href="#内联函数inline"></a> 内联函数（<code>inline</code>）</h2>
<p><strong>作用</strong>：建议编译器在调用处直接展开函数体，减少函数调用开销（避免压栈/跳转）。</p>
<p><strong>特点</strong>：</p>
<ul>
<li>
<p><strong>编译阶段，有类型检查。</strong></p>
</li>
<li>
<p>只是<strong>建议</strong>，编译器可选择忽略。</p>
</li>
<li>
<p>适合<strong>短小、频繁调用</strong>的函数。</p>
</li>
<li>
<p><strong>递归函数</strong>、<strong>过大函数</strong>通常不会被内联。</p>
</li>
<li>
<p>内联函数必须在<strong>调用前可见</strong>。</p>
</li>
</ul>
<p><strong>优势</strong>：</p>
<ul>
<li>提高性能（减少调用开销）。</li>
<li>保持函数形式（比宏函数更安全，有类型检查）。</li>
</ul>
<p><strong>局限</strong>：</p>
<ul>
<li><strong>会增加代码体积</strong>（代码膨胀）。</li>
<li><strong>不能用于虚函数的多态调用</strong>（运行时决定的调用无法内联）。</li>
</ul>
<hr />
<h2 id="extern-c-的作用"><a class="markdownIt-Anchor" href="#extern-c-的作用"></a> extern “C” 的作用</h2>
<ul>
<li>用于 C++ 中：告诉编译器按 <strong>C 语言方式</strong> 编译函数。</li>
<li>作用：避免 C++ 的 <strong>函数名修饰 (name mangling)</strong>，便于与 C 代码或库兼容。</li>
</ul>
<hr />
<h2 id="c中null和nullptr区别"><a class="markdownIt-Anchor" href="#c中null和nullptr区别"></a> C++中NULL和nullptr区别</h2>
<p>NULL来自C语言，nullptr则是C++11新增关键字。</p>
<ul>
<li>
<p><code>NULL</code> 是 <code>(void*)0</code>，有类型歧义，<strong>不推荐</strong>。</p>
</li>
<li>
<p><code>nullptr</code> 是专门的空指针类型，<strong>类型安全</strong>，</p>
</li>
</ul>
<blockquote>
<p><strong>Q：C语言可以没有NULL吗？</strong></p>
<ul>
<li>
<p><code>NULL</code> 不是必须的，只是 <code>(void*)0</code> 的别名。</p>
</li>
<li>
<p>C语言可以不用 <code>NULL</code>，但<strong>实际开发强烈建议用 <code>NULL</code> 表示空指针</strong>，提升可读性和规范性。</p>
</li>
</ul>
</blockquote>
<hr />
<h2 id="this指针"><a class="markdownIt-Anchor" href="#this指针"></a> this指针</h2>
<ul>
<li>
<p><code>this</code> 是一个指向<strong>当前对象首地址的指针</strong>。</p>
</li>
<li>
<p><code>this</code><strong>只能在成员函数使用</strong>，不能在全局函数、静态函数中使用。</p>
</li>
<li>
<p>存储位置因编译器不同会不同。</p>
</li>
</ul>
<blockquote>
<p><strong>Q1：this指针是什么时候创建？</strong></p>
<p>A1：<strong>在每次调用非静态成员函数时</strong>，编译器会<strong>隐式传入</strong>当前对象的地址作为 <code>this</code> 参数。所以**<code>this</code> 不是在构造对象时创建的，而是在成员函数执行时临时传入的**。</p>
<p><strong>Q2：this存放在哪？</strong></p>
<p>A2：<strong>this是一个局部变量</strong>，通常存放在<strong>寄存器/栈</strong>中。</p>
</blockquote>
<hr />
<h2 id="左值和右值的区别"><a class="markdownIt-Anchor" href="#左值和右值的区别"></a> 左值和右值的区别</h2>
<ul>
<li><strong>左值 (lvalue)</strong>：表示一块<strong>可寻址的内存</strong>，可以出现在赋值符号左边。
<ul>
<li>例：变量名 <code>a</code>，数组元素 <code>arr[2]</code>，解引用 <code>*p</code>。</li>
</ul>
</li>
<li><strong>右值 (rvalue)</strong>：表示 <strong>临时值、常量、表达式结果</strong>，生命周期短，<strong>不能单独取地址</strong>。
<ul>
<li>例：常量 <code>10</code>，表达式 <code>a+b</code>。</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>
<p>C++ 扩展（右值细分）</p>
</li>
<li>
<p><strong>左值</strong></p>
<ul>
<li><strong>纯右值 (prvalue)</strong>：字面量、临时对象。</li>
<li><strong>将亡值 (xvalue)</strong>：可被“偷资源”的临时对象（支持移动语义）。</li>
</ul>
</li>
<li>
<p><strong>左值</strong>：有名字、有地址、能长期存在。</p>
</li>
<li>
<p><strong>右值</strong>：没名字、临时用完就丢。</p>
</li>
</ul>
<p><strong>常见易混例子</strong></p>
<ul>
<li><code>i++</code> → <strong>右值</strong>（返回旧值的临时量，不能赋值）。</li>
<li><code>++i</code> → <strong>左值</strong>（返回自增后的变量本身，可继续赋值）。</li>
<li><code>arr[0]</code> → <strong>左值</strong>（数组元素，可寻址）。</li>
<li><code>a+b</code> → <strong>右值</strong>（表达式结果，临时）</li>
</ul>
</blockquote>
<hr />
<h2 id="cc的关键字了解"><a class="markdownIt-Anchor" href="#cc的关键字了解"></a> C/C++的关键字（了解）</h2>
<p><strong>C语言</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span>        <span class="keyword">break</span>       <span class="keyword">case</span>        <span class="type">char</span>        <span class="type">const</span>  </span><br><span class="line"><span class="keyword">continue</span>    <span class="keyword">default</span>     <span class="keyword">do</span>          <span class="type">double</span>      <span class="keyword">else</span>  </span><br><span class="line"><span class="keyword">enum</span>        <span class="keyword">extern</span>      <span class="type">float</span>       <span class="keyword">for</span>         <span class="keyword">goto</span>  </span><br><span class="line"><span class="keyword">if</span>          <span class="keyword">inline</span>      <span class="type">int</span>         <span class="type">long</span>        <span class="keyword">register</span>  </span><br><span class="line"><span class="keyword">restrict</span>    <span class="keyword">return</span>      <span class="type">short</span>       <span class="type">signed</span>      <span class="keyword">sizeof</span>  </span><br><span class="line"><span class="type">static</span>      <span class="keyword">struct</span>      <span class="keyword">switch</span>      <span class="keyword">typedef</span>     <span class="keyword">union</span>  </span><br><span class="line"><span class="type">unsigned</span>    <span class="type">void</span>        <span class="keyword">volatile</span>    <span class="keyword">while</span></span><br></pre></td></tr></table></figure>
<p>相较于C语言，<strong>C++新增</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alignas</span>     <span class="keyword">alignof</span>     <span class="keyword">and</span>         <span class="keyword">and_eq</span>      <span class="keyword">asm</span>  </span><br><span class="line"><span class="keyword">bitand</span>      <span class="keyword">bitor</span>       <span class="type">bool</span>        <span class="keyword">catch</span>       <span class="type">char16_t</span>  </span><br><span class="line"><span class="type">char32_t</span>    <span class="keyword">class</span>       <span class="title class_">compl</span>       <span class="keyword">const_cast</span>  <span class="keyword">constexpr</span>  </span><br><span class="line"><span class="keyword">consteval</span>   <span class="keyword">constinit</span>   <span class="keyword">co_await</span>    <span class="keyword">co_return</span>   <span class="keyword">co_yield</span>  </span><br><span class="line"><span class="keyword">decltype</span>    <span class="keyword">delete</span>      <span class="keyword">dynamic_cast</span>   <span class="keyword">explicit</span>    <span class="keyword">export</span>  </span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>  <span class="literal">false</span>       <span class="keyword">friend</span>      <span class="keyword">inline</span>      <span class="keyword">mutable</span>  </span><br><span class="line"><span class="keyword">namespace</span>   <span class="keyword">new</span>         <span class="keyword">noexcept</span>    <span class="literal">nullptr</span>     <span class="keyword">operator</span>  </span><br><span class="line"><span class="keyword">or</span>          <span class="keyword">or_eq</span>       <span class="keyword">private</span>     <span class="keyword">protected</span>    <span class="keyword">public</span>  </span><br><span class="line"><span class="keyword">reflexpr</span>    <span class="keyword">reinterpret_cast</span>        <span class="keyword">requires</span>    <span class="keyword">static_assert</span>  </span><br><span class="line"><span class="keyword">static_cast</span> <span class="keyword">struct</span>      <span class="keyword">template</span>    <span class="keyword">this</span>        <span class="keyword">thread_local</span>  </span><br><span class="line"><span class="keyword">throw</span>       <span class="literal">true</span>        <span class="keyword">try</span>         <span class="keyword">typeid</span>      <span class="keyword">typename</span>  </span><br><span class="line"><span class="keyword">union</span>       <span class="keyword">using</span>       <span class="keyword">virtual</span>     <span class="type">wchar_t</span>     <span class="keyword">xor</span>  </span><br><span class="line"><span class="keyword">xor_eq</span></span><br></pre></td></tr></table></figure>
<hr />
<h2 id="vector的底层实现"><a class="markdownIt-Anchor" href="#vector的底层实现"></a> vector的底层实现</h2>
<p><strong>结构</strong>：动态数组，内存连续，可随机访问。</p>
<p><strong>扩容</strong>：<strong>容量不足</strong>时按倍数增长，<strong>重新分配并搬移元素</strong>。</p>
<p><strong>迭代器失效</strong>：扩容后所有迭代器失效；<strong>非扩容时，插入/删除点之后的迭代器失效</strong>。</p>
<hr />
<h2 id="vector-和-list-的使用场景与区别"><a class="markdownIt-Anchor" href="#vector-和-list-的使用场景与区别"></a> vector 和 list 的使用场景与区别</h2>
<ul>
<li><strong>vector</strong>
<ul>
<li>底层实现：<strong>动态数组</strong>，元素<strong>连续</strong>存储。</li>
<li><strong>优势</strong>：支持 <strong>随机访问 O(1)</strong>，缓存友好，遍历效率高。</li>
<li><strong>劣势</strong>：中间插入/删除需要移动大量元素，效率低。</li>
<li><strong>适用场景</strong>：查询、顺序访问多，增删少。</li>
</ul>
</li>
<li><strong>list</strong>
<ul>
<li>底层实现：<strong>双向链表</strong>，元素<strong>分散</strong>存储。</li>
<li><strong>优势</strong>：<strong>插入/删除 O(1)</strong>（已知位置时），不会移动其他元素。</li>
<li><strong>劣势</strong>：不支持随机访问，只能顺序遍历；节点额外指针开销大，缓存不友好。</li>
<li><strong>适用场景</strong>：需要频繁在中间插入、删除。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Q：如果有10w个数据，那么查找一个元素，list和vector哪个效率更高？</strong></p>
<p>A：查找要根据实际情况选用，而不是纯理论。</p>
<ul>
<li>如果位于中间，则vector</li>
<li>如果位于开头或结尾，则list</li>
</ul>
<p>（如果不知道处于什么位置，那就用vector吧）</p>
</blockquote>
<hr />
<h2 id="vector下的resize和reserve的区别"><a class="markdownIt-Anchor" href="#vector下的resize和reserve的区别"></a> Vector下的Resize和Reserve的区别</h2>
<p><strong><code>resize(n)</code></strong>：<strong>改变大小</strong>，若变大则会构造新元素（对内置类型填充为 0，对类调用默认构造），可能导致 <strong>迭代器失效</strong>。</p>
<p><strong><code>reserve(n)</code></strong>：<strong>只调整容量，不改变元素数量</strong>；不会插入新元素，所以<strong>不会填充 0</strong>，只是预留空间；若实际扩容则 <strong>迭代器失效</strong>。</p>
<blockquote>
<p>Vector的<strong>内存占用空间只增不减</strong>，即使erase/clear也是不变。</p>
</blockquote>
<hr />
<h2 id="vectorsize是capacity还是已存储的元素个数"><a class="markdownIt-Anchor" href="#vectorsize是capacity还是已存储的元素个数"></a> Vector.size()是capacity，还是已存储的元素个数</h2>
<p><strong>已存储的元素个数</strong></p>
<blockquote>
<p><strong>size 是“已经放了几个”，capacity 是“最多能塞几个”。</strong></p>
</blockquote>
<hr />
<h2 id="如何理解迭代器容器的迭代器是由什么组成的"><a class="markdownIt-Anchor" href="#如何理解迭代器容器的迭代器是由什么组成的"></a> 如何理解迭代器，容器的迭代器是由什么组成的</h2>
<p><strong>定义</strong>：迭代器是“指针的泛化”，用来访问容器中的元素。</p>
<p><strong>作用</strong>：统一访问方式，让不同容器都能用同样的算法操作。</p>
<p>底层通常是 <strong>指针</strong> 或 <strong>类对象</strong>，封装了：</p>
<ul>
<li>当前元素的位置（指针/索引）。</li>
<li>运算操作（<code>++</code>, <code>--</code>, <code>*</code>, <code>-&gt;</code> 等）。</li>
<li>类型定义（<code>value_type</code>, <code>reference</code>, <code>pointer</code> 等）。</li>
</ul>
<hr />
<h2 id="stl中迭代器有什么用有指针了为何还要迭代器"><a class="markdownIt-Anchor" href="#stl中迭代器有什么用有指针了为何还要迭代器"></a> STL中迭代器有什么用，有指针了为何还要迭代器</h2>
<p><strong>作用</strong>：在不同容器上提供统一的访问方式，配合算法使用。</p>
<p><strong>为什么不直接用指针</strong>：</p>
<ul>
<li>不是所有容器都用连续内存（如 list、map）。</li>
<li>迭代器可像指针一样操作，但能适配各种容器。</li>
</ul>
<hr />
<h2 id="stl中有哪些容器这些容器的迭代器是如何删除元素"><a class="markdownIt-Anchor" href="#stl中有哪些容器这些容器的迭代器是如何删除元素"></a> STL中有哪些容器，这些容器的迭代器是如何删除元素</h2>
<p><strong>常见容器</strong></p>
<ul>
<li>
<p><strong>顺序</strong>容器：<code>vector</code>、<code>deque</code>、<code>list</code></p>
</li>
<li>
<p><strong>关联</strong>容器：<code>set</code>、<code>map</code>、<code>multiset</code>、<code>multimap</code></p>
</li>
<li>
<p><strong>无序</strong>容器：<code>unordered_set</code>、<code>unordered_map</code>、<code>unordered_multiset</code>、<code>unordered_multimap</code></p>
</li>
</ul>
<p><strong>删除元素与迭代器</strong></p>
<ul>
<li>
<p><strong>vector / deque</strong>：<code>erase(it)</code>，返回下一个迭代器；<strong>删除点及其后的迭代器全部失效</strong>。</p>
</li>
<li>
<p><strong>list</strong>：<code>erase(it)</code>，只使 <code>it</code> 失效，<strong>其他迭代器不变</strong>。</p>
</li>
<li>
<p><strong>map / set / 无序容器</strong>：<code>erase(it)</code>，只使当前迭代器失效，<strong>其他迭代器保持有效</strong>。</p>
</li>
</ul>
<blockquote>
<p><strong>STL容器结构</strong></p>
<p><strong>序列式容器</strong></p>
<ul>
<li><strong>vector</strong>：<strong>动态数组</strong>（连续内存块，通常维护起始、尾后和容量末尾三个指针）</li>
<li><strong>deque</strong>：<strong>分块数组 + 中控器</strong>（一个指针数组管理多个固定大小的连续内存块）</li>
<li><strong>list</strong>：<strong>双向循环链表</strong>（每个节点包含指向前后节点的指针和数据）</li>
<li><strong>forward_list</strong>：<strong>单向链表</strong>（每个节点仅包含指向下一个节点的指针和数据）</li>
<li><strong>array</strong>：<strong>静态数组</strong>（固定大小的连续内存，编译时确定）</li>
</ul>
<p><strong>关联式容器（有序）</strong></p>
<ul>
<li><strong>set / map / multiset / multimap</strong>：<strong>红黑树</strong></li>
</ul>
<p><strong>关联式容器（无序）</strong></p>
<ul>
<li><strong>unordered_set / unordered_map / unordered_multiset / unordered_multimap</strong>：<strong>哈希表</strong></li>
</ul>
<p><strong>容器适配器</strong></p>
<ul>
<li><strong>stack</strong>：默认基于 <strong>deque</strong> 封装（也可指定 <code>vector</code>或 <code>list</code>）</li>
<li><strong>queue</strong>：默认基于 <strong>deque</strong> 封装（也可指定 <code>list</code>）</li>
<li><strong>priority_queue</strong>：默认基于 <strong>vector</strong> 封装（<strong>堆算法</strong>，默认为大顶堆）</li>
</ul>
</blockquote>
<hr />
<h2 id="stl中的map和set有什么区别怎么实现的"><a class="markdownIt-Anchor" href="#stl中的map和set有什么区别怎么实现的"></a> STL中的map和set有什么区别，怎么实现的</h2>
<ul>
<li>
<p><strong>存储内容</strong></p>
<ul>
<li>
<p><code>map</code>：存储 <strong>key-value 键值对</strong>，key 唯一。</p>
</li>
<li>
<p><code>set</code>：只存储 <strong>key</strong>，元素唯一。</p>
</li>
</ul>
</li>
<li>
<p><strong>访问方式</strong></p>
<ul>
<li>
<p><code>map[key]</code> 可直接通过下标访问或修改 value。</p>
</li>
<li>
<p><code>set</code> 只能通过迭代器遍历查找。</p>
</li>
</ul>
</li>
<li>
<p><strong>底层实现</strong></p>
<ul>
<li>
<p>两者通常都用 <strong>红黑树（平衡二叉搜索树）</strong> 实现，元素有序。</p>
</li>
<li>
<p><code>map</code> 的节点存 <code>(key, value)</code>，<code>set</code> 的节点只存 <code>key</code>。</p>
</li>
<li>
<p>插入、删除、查找复杂度均为 <code>O(log n)</code>。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>Q：为什么map和set使用红黑树</strong></p>
<p>它们要求<strong>自动排序</strong>，而红黑树能够实现这一功能，并且<strong>时间复杂度较低</strong>。</p>
</blockquote>
<hr />
<h2 id="stl中的map和unordered_map区别"><a class="markdownIt-Anchor" href="#stl中的map和unordered_map区别"></a> STL中的map和unordered_map区别</h2>
<p><strong><code>map</code></strong></p>
<ul>
<li><strong>底层实现</strong>：<strong>红黑树</strong>（平衡二叉搜索树）。</li>
<li><strong>存储内容</strong>：节点存放 <code>(key, value)</code>。</li>
<li><strong>存放规则</strong>：按 <strong>key 有序</strong> 排列。</li>
<li><strong>复杂度</strong>：查找/插入/删除 <code>O(log n)</code>。</li>
<li><strong>遍历</strong>：迭代器<strong>中序遍历</strong>即有序。</li>
</ul>
<hr />
<p><strong><code>unordered_map</code></strong></p>
<ul>
<li><strong>底层实现</strong>：<strong>哈希表</strong>（bucket + 链表/拉链法 或 开放地址法）。</li>
<li><strong>存储内容</strong>：元素 <code>(key, value)</code> 存放在某个桶中。</li>
<li><strong>存放规则</strong>：按 <strong>哈希值分桶</strong>，无序。</li>
<li><strong>复杂度</strong>：平均 <code>O(1)</code>，最坏 <code>O(n)</code>。</li>
<li><strong>遍历</strong>：迭代器顺序取决于哈希分布，不能保证有序。</li>
</ul>
<hr />
<h2 id="stl的map插入方式"><a class="markdownIt-Anchor" href="#stl的map插入方式"></a> STL的map插入方式</h2>
<ul>
<li>
<p>用insert函数插入pair</p>
</li>
<li>
<p>用insert函数插入value_type</p>
</li>
<li>
<p>用insert函数插入make_pair()</p>
</li>
<li>
<p>用数组方式插入数据</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="type">int</span>, <span class="built_in">string</span>&gt; myMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 用insert函数插入pair</span></span><br><span class="line">myMap.insert(<span class="built_in">pair</span>&lt;<span class="type">int</span>, <span class="built_in">string</span>&gt;(<span class="number">1</span>, <span class="string">&quot;One&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 用insert函数插入value_type</span></span><br><span class="line">myMap.insert(<span class="built_in">map</span>&lt;<span class="type">int</span>, <span class="built_in">string</span>&gt;::value_type(<span class="number">2</span>, <span class="string">&quot;Two&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 用insert函数插入make_pair()</span></span><br><span class="line">myMap.insert(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="string">&quot;Three&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 用数组方式插入数据</span></span><br><span class="line">myMap[<span class="number">4</span>] = <span class="string">&quot;Four&quot;</span>; <span class="comment">// 键不存在，插入</span></span><br><span class="line">myMap[<span class="number">4</span>] = <span class="string">&quot;Four Again&quot;</span>; <span class="comment">// 键已存在，覆盖原有值</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>Q：map中的[]与find的区别？</strong></p>
<p>A：operator[]用于<strong>访问或插入</strong>元素，若<strong>键不存在</strong>则会<strong>自动创建新键值对</strong>（值默认初始化）并返回其引用；<code>find</code>仅用于<strong>查找</strong>元素，返回迭代器，若键不存在则返回 <code>end()</code>迭代器，<strong>不会修改map</strong>。若需检查键是否存在且避免意外插入，应优先使用find</p>
</blockquote>
<hr />
<h2 id="什么是初始化列表哪些情况下只能初始化列表而不能赋值"><a class="markdownIt-Anchor" href="#什么是初始化列表哪些情况下只能初始化列表而不能赋值"></a> 什么是初始化列表，哪些情况下只能初始化列表，而不能赋值</h2>
<p><strong>初始化列表 (Initializer List)</strong></p>
<ul>
<li>
<p><strong>概念</strong>：在构造函数冒号后，用 <code>&#123;&#125;</code> 或 <code>()</code> 直接对成员进行初始化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">public:</span><br><span class="line">    A(<span class="type">int</span> a, <span class="type">int</span> b) : x(a), y(b) &#123;&#125;  <span class="comment">// 初始化列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>区别</strong>：</p>
<ul>
<li><strong>初始化列表</strong> → 在对象创建时直接初始化成员。</li>
<li><strong>构造函数体赋值</strong> → 先默认初始化，再在函数体里赋值。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>必须用初始化列表的情况</strong></p>
<ol>
<li><strong><code>const</code> 成员</strong></li>
<li><strong>引用成员 <code>&amp;</code></strong></li>
<li><strong>无默认构造函数的成员对象</strong></li>
<li><strong>基类构造函数调用</strong></li>
</ol>
</blockquote>
<hr />
<h2 id="没有参数的函数能不能被重载"><a class="markdownIt-Anchor" href="#没有参数的函数能不能被重载"></a> 没有参数的函数能不能被重载</h2>
<ul>
<li>
<p><strong>可以重载</strong>，但前提是 <strong>参数列表不同</strong>。</p>
</li>
<li>
<p>如果都是 <strong>无参数</strong>，则无法区分，编译报错。</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span>;          <span class="comment">//  定义1</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">int</span> x)</span>;     <span class="comment">//  定义2（重载）</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">(<span class="type">double</span> x)</span>;  <span class="comment">//  定义3（重载）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误：重复定义</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span>;          </span><br><span class="line"><span class="type">void</span> <span class="title function_">fun</span><span class="params">()</span>;  </span><br></pre></td></tr></table></figure>
<hr />
<h1 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h1>
<h2 id="常见的排序算法"><a class="markdownIt-Anchor" href="#常见的排序算法"></a> 常见的排序算法</h2>
<ul>
<li>
<p><strong>冒泡排序：</strong> 相邻元素两两比较，大的往后移，循环多次把最大值“冒”到最后。</p>
</li>
<li>
<p><strong>插入排序：</strong> 前面保持有序序列，取下一个元素，按大小插入到合适位置。</p>
</li>
<li>
<p><strong>选择排序：</strong> 每一轮从未排序区选择最小（或最大）的，与当前位置元素交换。</p>
</li>
<li>
<p><strong>快速排序：</strong> 取一个基准值，把小于的放左边，大于的放右边，然后递归分区排序。</p>
</li>
<li>
<p><strong>归并排序：</strong> 不断二分数组，递归到底后再逐层合并两个有序序列（需辅助数组）。</p>
</li>
<li>
<p><strong>基数排序：</strong> 按数位（个位、十位、百位…）依次排序，常用稳定排序作为子过程。</p>
</li>
<li>
<p><strong>希尔排序：</strong> 基于插入排序，先按较大间隔分组排序，再逐渐缩小间隔至 1。</p>
</li>
<li>
<p><strong>堆排序：</strong> 利用大顶堆/小顶堆，每次取堆顶元素放到末尾，再调整堆结构。</p>
</li>
<li>
<p><strong>计数排序：</strong> 统计每个元素出现次数，通过计数下标映射回输出（需额外数组）。</p>
</li>
<li>
<p><strong>桶排序：</strong> 按数值范围映射到不同桶内，每个桶独立排序，最后合并所有桶。</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2025/09/01/FE5rBgRM7qsvGCI.png" alt="" /></p>
<hr />
<h2 id="二叉树通过中序遍历和后序遍历判断前序遍历"><a class="markdownIt-Anchor" href="#二叉树通过中序遍历和后序遍历判断前序遍历"></a> 二叉树通过中序遍历和后序遍历，判断前序遍历</h2>
<p><strong>前序遍历：中左右；中序遍历：左中右；后序遍历：左右中。</strong></p>
<p><strong>例子</strong></p>
<ul>
<li>中序：<code>D B E A F C</code></li>
<li>后序：<code>D E B F C A</code></li>
</ul>
<p><strong>推导过程</strong></p>
<ol>
<li><strong>后序末尾 = A</strong> → 整棵树根。
<ul>
<li>在中序里，<code>A</code> 左边是 <code>D B E</code>，右边是 <code>F C</code>。</li>
</ul>
</li>
<li><strong>左子树 = <code>D B E</code></strong>
<ul>
<li>在对应后序子序列 <code>D E B</code>，末尾 <code>B</code> 是根。</li>
<li>在中序 <code>D B E</code> 中，<code>B</code> 左边是 <code>D</code>，右边是 <code>E</code>。</li>
<li>→ 左子树前序 = <code>B D E</code>。</li>
</ul>
</li>
<li><strong>右子树 = <code>F C</code></strong>
<ul>
<li>在对应后序子序列 <code>F C</code>，末尾 <code>C</code> 是根。</li>
<li>在中序 <code>F C</code> 中，<code>C</code> 左边是 <code>F</code>，右边为空。</li>
<li>→ 右子树前序 = <code>C F</code>。</li>
</ul>
</li>
<li><strong>拼接前序</strong>
<ul>
<li>根 <code>A</code> + 左子树 <code>B D E</code> + 右子树 <code>C F</code></li>
<li>→ <strong>前序 = A B D E C F</strong>。</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>后序定根，中序分左右，递归拼前序</strong>。</p>
</blockquote>
<hr />
<h2 id="什么是搜索二叉树"><a class="markdownIt-Anchor" href="#什么是搜索二叉树"></a> 什么是搜索二叉树</h2>
<ol>
<li>
<p>左子树所有节点的值 <strong>小于</strong> 根节点值；</p>
</li>
<li>
<p>右子树所有节点的值 <strong>大于</strong> 根节点值；</p>
</li>
</ol>
<blockquote>
<p>中序遍历结果是 <strong>递增序列</strong>。</p>
</blockquote>
<h2 id="什么是平衡二叉树"><a class="markdownIt-Anchor" href="#什么是平衡二叉树"></a> 什么是平衡二叉树</h2>
<ul>
<li>一种二叉搜索树，<strong>任意节点的左右子树高度差不超过 1</strong>。</li>
<li><strong>作用</strong>：保持查找、插入、删除的时间复杂度 O(log n)。</li>
</ul>
<blockquote>
<p><strong>典型实现</strong>：AVL 树、红黑树。</p>
</blockquote>
<hr />
<h2 id="二叉树通过中序遍历和后序遍历判断前序遍历-2"><a class="markdownIt-Anchor" href="#二叉树通过中序遍历和后序遍历判断前序遍历-2"></a> 二叉树通过中序遍历和后序遍历，判断前序遍历</h2>
<p><strong>前序遍历：中左右；中序遍历：左中右；后序遍历：左右中。</strong></p>
<p><strong>例子</strong></p>
<ul>
<li>中序：<code>D B E A F C</code></li>
<li>后序：<code>D E B F C A</code></li>
</ul>
<p><strong>推导过程</strong></p>
<ol>
<li><strong>后序末尾 = A</strong> → 整棵树根。
<ul>
<li>在中序里，<code>A</code> 左边是 <code>D B E</code>，右边是 <code>F C</code>。</li>
</ul>
</li>
<li><strong>左子树 = <code>D B E</code></strong>
<ul>
<li>在对应后序子序列 <code>D E B</code>，末尾 <code>B</code> 是根。</li>
<li>在中序 <code>D B E</code> 中，<code>B</code> 左边是 <code>D</code>，右边是 <code>E</code>。</li>
<li>→ 左子树前序 = <code>B D E</code>。</li>
</ul>
</li>
<li><strong>右子树 = <code>F C</code></strong>
<ul>
<li>在对应后序子序列 <code>F C</code>，末尾 <code>C</code> 是根。</li>
<li>在中序 <code>F C</code> 中，<code>C</code> 左边是 <code>F</code>，右边为空。</li>
<li>→ 右子树前序 = <code>C F</code>。</li>
</ul>
</li>
<li><strong>拼接前序</strong>
<ul>
<li>根 <code>A</code> + 左子树 <code>B D E</code> + 右子树 <code>C F</code></li>
<li>→ <strong>前序 = A B D E C F</strong>。</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>后序定根，中序分左右，递归拼前序</strong>。</p>
</blockquote>
<hr />
<h1 id="计算机网络"><a class="markdownIt-Anchor" href="#计算机网络"></a> 计算机网络</h1>
<h2 id="osi-四层模型-七层模型"><a class="markdownIt-Anchor" href="#osi-四层模型-七层模型"></a> OSI 四层模型 / 七层模型</h2>
<ul>
<li>
<p><strong>四层模型</strong>：</p>
<ol>
<li>
<p><strong>应用层</strong>：提供应用服务（HTTP、FTP、SMTP、DNS）。</p>
</li>
<li>
<p><strong>传输层</strong>：端到端通信，保证可靠/快速（TCP、UDP）。</p>
</li>
<li>
<p><strong>网络层</strong>：选择路径、寻址转发（IP、ICMP）。</p>
</li>
<li>
<p><strong>网络接口层</strong>：封装/解封装成帧并传输（以太网、PPP、物理层比特流）。</p>
</li>
</ol>
</li>
<li>
<p><strong>七层模型</strong>：</p>
<ol>
<li>
<p><strong>应用层</strong>：面向用户的软件（HTTP、FTP、SMTP）。</p>
</li>
<li>
<p><strong>表示层</strong>：数据表示、加密/解密、压缩/解压缩。</p>
</li>
<li>
<p><strong>会话层</strong>：会话建立、管理和终止。</p>
</li>
<li>
<p><strong>传输层</strong>：端到端通信，流量控制、差错控制（TCP、UDP）。</p>
</li>
<li>
<p><strong>网络层</strong>：逻辑寻址和路由选择（IP、ICMP）。</p>
</li>
<li>
<p><strong>数据链路层</strong>：成帧、差错检测、MAC 地址（ARP、PPP、以太网）。</p>
</li>
<li>
<p><strong>物理层</strong>：比特流传输（网线、网卡标准）。</p>
</li>
</ol>
</li>
</ul>
<hr />
<h2 id="http是什么"><a class="markdownIt-Anchor" href="#http是什么"></a> HTTP是什么</h2>
<p><strong>定义</strong>：超文本传输协议（HyperText Transfer Protocol），基于 TCP/IP 的应用层协议，用于浏览器和服务器之间传输数据。</p>
<hr />
<h2 id="http-的发展史"><a class="markdownIt-Anchor" href="#http-的发展史"></a> HTTP 的发展史</h2>
<ul>
<li><strong>HTTP/1.0</strong>：<strong>短连接</strong>，请求一次建立一次 TCP 连接。</li>
<li><strong>HTTP/1.1</strong>：默认<strong>长连接</strong>，支持流水线。</li>
<li><strong>HTTPS</strong>：HTTP + SSL/TLS，<strong>加密传输</strong>。</li>
<li><strong>HTTP/2.0</strong>：<strong>多路复用</strong>、头部压缩、<strong>二进制帧</strong>，用流的形式发送。</li>
<li><strong>HTTP/3.0</strong>：基于 <strong>QUIC 协议（UDP）</strong>，减少握手延迟。</li>
</ul>
<hr />
<h2 id="http请求和响应报文包含哪些字段"><a class="markdownIt-Anchor" href="#http请求和响应报文包含哪些字段"></a> HTTP请求和响应报文包含哪些字段</h2>
<ul>
<li><strong>请求报文</strong>
<ul>
<li>请求行</li>
<li>请求头</li>
<li>请求体</li>
</ul>
</li>
<li><strong>响应报文</strong>
<ul>
<li>状态行</li>
<li>响应头</li>
<li>响应体</li>
</ul>
</li>
</ul>
<hr />
<h2 id="http请求流程"><a class="markdownIt-Anchor" href="#http请求流程"></a> HTTP请求流程</h2>
<ol>
<li>DNS解析域名IP</li>
<li>根据IP，建立TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器响应请求，得到HTML代码</li>
<li>关闭TCP连接</li>
<li>浏览器解析HTML代码，并请求相关资源（js、css、图片）</li>
<li>浏览器渲染页面呈现</li>
</ol>
<hr />
<h2 id="get和post的区别"><a class="markdownIt-Anchor" href="#get和post的区别"></a> GET和POST的区别</h2>
<ul>
<li>GET是<strong>获取</strong>数据，POST是<strong>修改</strong>数据</li>
<li><strong>GET是幂等，POST不是幂等</strong></li>
<li>GET后服务器响应200 ok；POST后服务器先响应100 Continue，再响应200 ok</li>
</ul>
<blockquote>
<p>因此<strong>POST会产生两个TCP数据包</strong></p>
</blockquote>
<ul>
<li>GET提交的数据有上限，POST没有上限</li>
</ul>
<hr />
<h2 id="http和https的区别"><a class="markdownIt-Anchor" href="#http和https的区别"></a> HTTP和HTTPS的区别</h2>
<ul>
<li>
<p>HTTPS协议是由<strong>SSL+HTTP协议</strong>构建的可加密传输的网络协议；</p>
</li>
<li>
<p>HTTPS需要申请<strong>CA证书</strong>；</p>
</li>
<li>
<p><strong>HTTPS</strong>使用<strong>443端口</strong>，<strong>HTTP</strong>使用<strong>80端口</strong>。</p>
</li>
</ul>
<hr />
<h2 id="对称加密和非对称加密"><a class="markdownIt-Anchor" href="#对称加密和非对称加密"></a> 对称加密和非对称加密</h2>
<ul>
<li><strong>对称加密</strong>
<ul>
<li>加密和解密使用<strong>同一个密钥</strong>。</li>
<li>速度快，适合加密大量数据。</li>
<li>核心问题：如何安全地共享密钥。</li>
</ul>
</li>
<li><strong>非对称加密</strong>
<ul>
<li>使用一对密钥：<strong>公钥</strong>和<strong>私钥</strong>。</li>
<li><strong>公钥加密</strong>的数据，只能用对应的<strong>私钥解密</strong>。</li>
<li><strong>私钥签名</strong>的数据，可以用对应的<strong>公钥验证</strong>来源。</li>
<li>速度慢，主要用于密钥交换和数字签名。</li>
</ul>
</li>
</ul>
<hr />
<h2 id="https请求流程"><a class="markdownIt-Anchor" href="#https请求流程"></a> HTTPS请求流程</h2>
<ol>
<li>先通过 <strong>DNS 解析获取</strong>服务器的 <strong>IP 地址</strong>；</li>
<li>接着 <strong>TCP 三次握手</strong>建立网络连接；</li>
<li><strong>客户端向服务端发起一个 HTTPS 请求</strong>（含有<strong>Client Random</strong>、<strong>SSL/TLS套件版本</strong>）；</li>
<li>服务器会将其<strong>数字证书（包含公钥）发送给客户端</strong>（含有<strong>Server Random</strong>）；</li>
<li>客户端会验证该证书的合法性，包括检查其是否由可信机构颁发、是否在有效期内以及域名是否匹配等。验证通过后，<strong>客户端</strong>会生成一个用于后续<strong>对称加密</strong>的 <strong>Pre-Master Secret</strong>（预主密钥）；</li>
<li><strong>客户端用服务器证书中的公钥进行加密</strong>后发送给服务器；</li>
<li><strong>服务器使用自己的私钥解密</strong>，获取该预主密钥；</li>
<li>随后，客户端和服务器会利用握手过程中交换的 <strong>Client Random</strong>（客户端随机数）、<strong>Server Random</strong>（服务端随机数）和刚刚协商出的 <strong>Pre-Master Secret</strong>，各自独立计算生成相同的<strong>会话密钥</strong>（Master Secret）；</li>
<li>此后的所有通信数据都将使用这个会话密钥进行<strong>对称加密和解密</strong>，确保数据传输的机密性和完整性。</li>
</ol>
<hr />
<h2 id="常见http状态码"><a class="markdownIt-Anchor" href="#常见http状态码"></a> 常见HTTP状态码</h2>
<p>HTTP状态码是服务器对请求处理结果的标识。</p>
<ul>
<li>
<p><strong>1xx（信息性状态码）</strong>：表示请求已被接收，需要继续处理。</p>
<ul>
<li><strong>100 Continue</strong>（客户端可继续发送请求）</li>
</ul>
</li>
<li>
<p><strong>2xx（成功状态码）</strong>：表示请求已成功被服务器接收、理解并处理。</p>
<ul>
<li><strong>200 OK</strong>（请求成功）</li>
<li><strong>201 Created</strong> 表示新资源被创建</li>
<li><strong>204 No Content</strong> 表示成功但无内容返回</li>
</ul>
</li>
<li>
<p><strong>3xx（重定向状态码）</strong>：表示需要进一步操作以完成请求。</p>
<ul>
<li><strong>301 Moved Permanently</strong> 是永久重定向</li>
<li><strong>302 Found</strong> 是临时重定向</li>
<li><strong>304 Not Modified</strong> 告知客户端可使用缓存资源</li>
</ul>
</li>
<li>
<p><strong>4xx（客户端错误状态码）</strong>：表示请求可能出错。</p>
<ul>
<li><strong>400 Bad Request</strong> 指请求有语法错误</li>
<li><strong>401 Unauthorized</strong> 表示需要身份验证</li>
<li><strong>403 Forbidden</strong> 是服务器拒绝请求</li>
<li><strong>404 Not Found</strong> 表示资源不存在</li>
</ul>
</li>
<li>
<p><strong>5xx（服务器错误状态码）</strong>：表示服务器处理请求时出错。</p>
<ul>
<li><strong>500 Internal Server Error</strong> 是服务器内部错误</li>
<li><strong>503 Service Unavailable</strong> 表示服务暂时不可用</li>
</ul>
</li>
</ul>
<hr />
<h2 id="什么是dns"><a class="markdownIt-Anchor" href="#什么是dns"></a> 什么是DNS</h2>
<p>Domain Name System，域名系统；是<strong>域名和IP地址相互映射</strong>的<strong>数据库</strong>。</p>
<p>DNS域名解析通过<strong>UDP</strong>协议，输入域名后流程：</p>
<ol>
<li>检查<strong>浏览器缓存</strong>是否包含这个域名映射的IP地址；若没有，执行2；</li>
<li>检查<strong>操作系统缓存</strong>；若没有，执行3；</li>
<li>检查<strong>本地域名服务器解析（LDNS）</strong>；若没有，执行4；</li>
<li>检查<strong>根域名服务器</strong>(.com)，一步一步往下传，最终返回对应的IP地址。</li>
</ol>
<hr />
<h2 id="dns-负载均衡"><a class="markdownIt-Anchor" href="#dns-负载均衡"></a> DNS 负载均衡</h2>
<p>DNS 负载均衡是一种通过 <strong>DNS 解析过程</strong> 来分配网络流量的策略。其核心是 <strong>一个域名对应多个 IP 地址</strong>。当用户访问这个域名时，DNS 服务器会根据预设的策略，从这些 IP 地址中选择一个返回给用户，从而将访问流量分散到不同的服务器上。</p>
<hr />
<h2 id="tcp-和-udp-的区别"><a class="markdownIt-Anchor" href="#tcp-和-udp-的区别"></a> TCP 和 UDP 的区别</h2>
<ul>
<li><strong>TCP</strong>：面向<strong>连接</strong>，可靠传输，基于字节流的，速度慢。</li>
<li><strong>UDP</strong>：面向<strong>报文</strong>，无连接，不可靠传输，速度快。</li>
</ul>
<hr />
<h2 id="mtu和mss分别是什么"><a class="markdownIt-Anchor" href="#mtu和mss分别是什么"></a> MTU和MSS分别是什么</h2>
<p>Maximum Transmission Unit，最大传输单元，即<strong>IP头+TCP头+DATA</strong>。</p>
<p>Maximum Segment Size，最大段长，即<strong>DATA</strong>。</p>
<hr />
<h2 id="tcp-粘包和拆包问题怎么解决"><a class="markdownIt-Anchor" href="#tcp-粘包和拆包问题怎么解决"></a> TCP 粘包和拆包问题，怎么解决</h2>
<ul>
<li><strong>原因</strong>：TCP 是字节流协议，不保证消息边界 → 多个包合并或一个包被拆分。</li>
<li><strong>解决方法</strong>：
<ul>
<li>固定长度消息</li>
<li>使用分隔符</li>
<li>在消息头加长度字段</li>
<li>应用层协议处理（如 HTTP、MQTT）</li>
</ul>
</li>
</ul>
<hr />
<h2 id="tcp-通信如何保证通信的可靠性"><a class="markdownIt-Anchor" href="#tcp-通信如何保证通信的可靠性"></a> TCP 通信如何保证通信的可靠性</h2>
<ul>
<li><strong>确认应答机制</strong>（ACK）</li>
<li><strong>校验和</strong></li>
<li><strong>有序性保证</strong>（序列号保证数据按顺序到达）</li>
<li><strong>超时重传</strong></li>
<li><strong>滑动窗口</strong>（流量控制）：当接收方来不及处理发送方数据，可以通过滑动窗口，提示发送方降低发送速率</li>
<li><strong>拥塞控制</strong>（慢启动、拥塞避免、拥塞发生、快速重传/恢复）</li>
</ul>
<hr />
<h2 id="如何区分流量控制和拥塞控制"><a class="markdownIt-Anchor" href="#如何区分流量控制和拥塞控制"></a> 如何区分流量控制和拥塞控制</h2>
<ul>
<li>流量控制属于通信双方协商，拥塞控制涉及通信链路全局</li>
<li>流量控制需要通信双方各维护一个发送窗和接收窗；发送窗由接受方响应的TCP窗口大小确定，接收窗由自身决定</li>
<li>拥塞控制的窗口大小变化由试探性发送一定数据量数据探查网络状态后自适应调整</li>
<li>实际发送窗口 = min{流量发送窗口，拥塞窗口}</li>
</ul>
<hr />
<img src="https://s2.loli.net/2025/09/03/ElWFZOK9QrVpbPR.png" style="zoom:67%;" />
<h2 id="tcp-三次握手连接建立"><a class="markdownIt-Anchor" href="#tcp-三次握手连接建立"></a> TCP 三次握手（连接建立）</h2>
<ol>
<li><strong>客户端 → 服务端</strong>：发送 <strong>SYN=1, seq=x</strong>
<ul>
<li>表示请求建立连接，并告知初始序列号 <code>x</code>。</li>
<li>客户端进入 <strong>SYN_SENT</strong> 状态**（半连接）**。</li>
</ul>
</li>
<li><strong>服务端 → 客户端</strong>：发送 <strong>SYN=1, ACK=1, seq=y, ack=x+1</strong>
<ul>
<li>确认收到了客户端的 SYN，同时自己也发起连接请求。</li>
<li>服务端进入 <strong>SYN_RCVD</strong> 状态。</li>
</ul>
</li>
<li><strong>客户端 → 服务端</strong>：发送 <strong>ACK=1, ack=y+1</strong>
<ul>
<li>确认收到了服务端的 SYN。</li>
<li>客户端进入 <strong>ESTABLISHED</strong> 状态。</li>
<li>服务端收到 ACK 后，也进入 <strong>ESTABLISHED（全连接）</strong>。</li>
</ul>
</li>
</ol>
<blockquote>
<p>👉 <strong>为什么三次？</strong></p>
<ul>
<li>防止已失效的连接请求报文突然到达而引起错误（历史 SYN 报文问题）。</li>
<li>双方要确认 <strong>对方的收发能力</strong>。</li>
</ul>
<p>🍊 <strong>什么是半连接队列和全连接队列？</strong></p>
<ul>
<li><strong>服务器第一次接收到客户端的SYN</strong>，会处于SYN_RECV状态，此时是半连接队列。</li>
<li><strong>服务器第二次接收到客户端的SYN+ACK</strong>，会处于SYN_ACK状态，此时是<strong>全连接</strong>队列。</li>
</ul>
<p>⚙️ 三次握手可以携带数据吗？</p>
<ul>
<li><strong>第一次</strong>和<strong>第二次</strong>握手<strong>不允许携带</strong>；<strong>第三次可以携带</strong>。</li>
</ul>
</blockquote>
<hr />
<h2 id="tcp-四次挥手连接释放"><a class="markdownIt-Anchor" href="#tcp-四次挥手连接释放"></a> TCP 四次挥手（连接释放）</h2>
<ol>
<li><strong>客户端 → 服务端</strong>：发送 <strong>FIN=1, seq=u</strong>
<ul>
<li>表示“客户端已无数据要发”，请求关闭连接。</li>
<li>客户端进入 <strong>FIN_WAIT_1</strong> 状态。</li>
</ul>
</li>
<li><strong>服务端 → 客户端</strong>：发送 <strong>ACK=1, ack=u+1</strong>
<ul>
<li>确认收到了 FIN，但可能还有数据要发。</li>
<li>服务端进入 <strong>CLOSE_WAIT</strong> 状态；客户端进入 <strong>FIN_WAIT_2</strong>。</li>
</ul>
</li>
<li><strong>服务端 → 客户端</strong>：发送 <strong>FIN=1, seq=v</strong>
<ul>
<li>当服务端也没有数据要发时，主动关闭。</li>
<li>服务端进入 <strong>LAST_ACK</strong> 状态。</li>
</ul>
</li>
<li><strong>客户端 → 服务端</strong>：发送 <strong>ACK=1, ack=v+1</strong>
<ul>
<li>确认收到服务端的 FIN。</li>
<li>客户端进入 <strong>TIME_WAIT</strong>，等待 2MSL 确保最后 ACK 不丢失。</li>
<li>服务端收到 ACK 后进入 <strong>CLOSED</strong>，释放连接。</li>
</ul>
</li>
</ol>
<blockquote>
<p>👉 <strong>为什么要四次？</strong></p>
<ul>
<li>TCP 是全双工的，关闭要分成两个方向。</li>
<li>一方发送 FIN 表示“我这边没数据了”，但另一方可能还有数据要发 → 所以 ACK 和 FIN 分开发。</li>
</ul>
</blockquote>
<hr />
<h2 id="为什么客户端最后还要等待2msl"><a class="markdownIt-Anchor" href="#为什么客户端最后还要等待2msl"></a> 为什么客户端最后还要等待2MSL</h2>
<p><strong>MSL（Maximum Segment Lifetime）</strong>：报文在网络中的最长存活时间。</p>
<p><strong>等待 2MSL 的原因</strong>：</p>
<ol>
<li><strong>保证 ACK 能到达</strong>
<ul>
<li>客户端最后发给服务端的 ACK 可能丢失。</li>
<li>等待 2MSL 可确保服务端若未收到 ACK，重发 FIN，客户端还能再次回应。</li>
</ul>
</li>
<li><strong>清除旧报文</strong>
<ul>
<li>2MSL 时间足够让网络中的所有旧 TCP 报文消失，避免影响后续新的连接。</li>
</ul>
</li>
</ol>
<hr />
<h2 id="什么是-cookie"><a class="markdownIt-Anchor" href="#什么是-cookie"></a> 什么是 Cookie</h2>
<p><strong>Cookie 是</strong>服务器发送到用户浏览器并<strong>保存在本地的一小块文本数据</strong>。浏览器会存储它，并在后续向同一服务器发起的请求中自动携带。</p>
<ul>
<li><strong>会话状态管理</strong>（如保持登录）</li>
<li><strong>个性化设置</strong>（如语言偏好）</li>
<li><strong>浏览器行为追踪</strong>。</li>
</ul>
<hr />
<h2 id="什么是-session"><a class="markdownIt-Anchor" href="#什么是-session"></a> 什么是 Session</h2>
<p><strong>Session 是</strong>一种在<strong>服务器端保存用户状态信息</strong>的机制。服务器会为每个用户会话创建一个唯一的标识（Session ID），通常通过 Cookie 传递给客户端。后续请求中，客户端凭此 ID 即可让服务器识别出用户并访问其对应的会话数据，从而<strong>在无状态的 HTTP 协议上实现有状态的交互</strong>。</p>
<hr />
<h2 id="socket网络编程中用到哪些函数"><a class="markdownIt-Anchor" href="#socket网络编程中用到哪些函数"></a> socket网络编程中用到哪些函数</h2>
<ul>
<li><strong>服务端（Server）</strong></li>
</ul>
<ol>
<li><strong><code>socket()</code></strong> → 创建套接字。</li>
<li><strong><code>bind()</code></strong> → 绑定 IP 和端口。</li>
<li><strong><code>listen()</code></strong> → 监听端口，等待连接。</li>
<li><strong><code>accept()</code></strong> → 接收客户端连接，返回新的套接字。</li>
<li><strong><code>recv()</code> / <code>send()</code></strong> 或 <strong><code>read()</code> / <code>write()</code></strong> → 收发数据。</li>
<li><strong><code>close()</code></strong> → 关闭连接。</li>
</ol>
<hr />
<ul>
<li><strong>客户端（Client）</strong></li>
</ul>
<ol>
<li><strong><code>socket()</code></strong> → 创建套接字。</li>
<li><strong><code>connect()</code></strong> → 连接服务端。</li>
<li><strong><code>recv()</code> / <code>send()</code></strong> 或 <strong><code>read()</code> / <code>write()</code></strong> → 收发数据。</li>
<li><strong><code>close()</code></strong> → 关闭连接。</li>
</ol>
<hr />
<h2 id="dhcp-协议dynamic-host-configuration-protocol了解"><a class="markdownIt-Anchor" href="#dhcp-协议dynamic-host-configuration-protocol了解"></a> DHCP 协议（Dynamic Host Configuration Protocol）（了解）</h2>
<ul>
<li><strong>作用</strong>：自动为主机分配网络参数（IP 地址、子网掩码、网关、DNS 等），避免手工配置。</li>
<li><strong>工作方式</strong>：基于 UDP，通常通过广播通信。</li>
</ul>
<p><strong>应用层</strong>：DHCP 协议本身（运行在客户端和服务器之间，分配网络参数）。</p>
<p><strong>传输层</strong>：使用 <strong>UDP</strong>（客户端端口 68，服务器端口 67）。</p>
<p><strong>网络层</strong>：依赖 IP（广播 255.255.255.255 或子网广播地址）。</p>
<p><strong>链路层</strong>：在第一次请求时，客户端可能还没有 IP，会用 <strong>MAC 地址</strong>标识自己。</p>
<hr />
<h2 id="arp和rarp"><a class="markdownIt-Anchor" href="#arp和rarp"></a> ARP和RARP</h2>
<p><strong>ARP：IP地址转物理地址</strong></p>
<p><strong>RARP：物理地址转IP地址</strong></p>
<hr />
<h2 id="ping命令基于什么协议了解"><a class="markdownIt-Anchor" href="#ping命令基于什么协议了解"></a> Ping命令基于什么协议（了解）</h2>
<p>Ping是<strong>基于网络层的ICMP协议实现</strong>。通过向对方发送一个<strong>ICMP回送请求报文</strong>。</p>
<h2 id="ip-地址-子网掩码-网关和-dns-作用"><a class="markdownIt-Anchor" href="#ip-地址-子网掩码-网关和-dns-作用"></a> IP 地址、子网掩码、网关和 DNS 作用</h2>
<ul>
<li><strong>IP 地址</strong>：设备在网络中的唯一标识。</li>
<li><strong>子网掩码</strong>：划分网络号和主机号。
<ul>
<li><strong>网络号 = IP 地址 &amp; 子网掩码</strong></li>
<li><strong>主机号 = IP 地址 &amp; (子网掩码取反)</strong></li>
</ul>
</li>
<li><strong>网关</strong>：跨网络通信的出口。</li>
<li><strong>DNS</strong>：域名解析，将域名转换为 IP 地址。</li>
</ul>
<hr />
<h2 id="ipv4-和-ipv6-的区别了解"><a class="markdownIt-Anchor" href="#ipv4-和-ipv6-的区别了解"></a> IPv4 和 IPv6 的区别（了解）</h2>
<p><strong>地址长度</strong></p>
<ul>
<li>IPv4：32 位地址，约 43 亿个地址。</li>
<li>IPv6：128 位地址，几乎无限，解决地址枯竭问题。</li>
</ul>
<p><strong>地址表示</strong></p>
<ul>
<li>IPv4：点分十进制（<code>192.168.0.1</code>）。</li>
<li>IPv6：冒号十六进制（<code>2001:db8::1</code>）。</li>
</ul>
<p><strong>首部结构</strong></p>
<ul>
<li>IPv4：首部字段复杂，最多 60 字节。</li>
<li>IPv6：首部简化，固定 40 字节，处理更高效。</li>
</ul>
<p><strong>地址配置</strong></p>
<ul>
<li>IPv4：可手动、DHCP。</li>
<li>IPv6：支持自动配置（无状态地址自动配置，SLAAC）。</li>
</ul>
<p><strong>安全性</strong></p>
<ul>
<li>IPv4：依赖应用层/扩展（如 IPSec 可选）。</li>
<li>IPv6：IPSec 是强制支持的。</li>
</ul>
<p><strong>广播方式</strong></p>
<ul>
<li>IPv4：支持广播。</li>
<li>IPv6：取消广播，改用 <strong>组播/任播</strong>。</li>
</ul>
<hr />
<h2 id="常用的网络拓扑类型了解"><a class="markdownIt-Anchor" href="#常用的网络拓扑类型了解"></a> 常用的网络拓扑类型（了解）</h2>
<ul>
<li><strong>星型</strong>：所有节点通过中心设备连接，可靠但中心单点故障。</li>
<li><strong>总线型</strong>：共享一条总线，成本低但冲突多。</li>
<li><strong>环型</strong>：形成闭环，适合定时传输。</li>
<li><strong>树型</strong>：层次化管理。</li>
<li><strong>网状型</strong>：高可靠性，多路径冗余。</li>
</ul>
<hr />
<h1 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统"></a> 操作系统</h1>
<h2 id="进程-线程和协程的区别"><a class="markdownIt-Anchor" href="#进程-线程和协程的区别"></a> 进程、线程和协程的区别</h2>
<p><strong>进程（Process）</strong></p>
<ul>
<li>操作系统进行 <strong>资源分配</strong> 的基本单位。</li>
<li>进程间相互独立，通信需要 IPC（Inter-Process Communication）。</li>
<li>切换开销大。</li>
</ul>
<p><strong>线程（Thread）</strong></p>
<ul>
<li>CPU <strong>资源调度</strong>的最小单位。</li>
<li><strong>共享内存资源</strong>（代码段、堆），但有独立的栈和寄存器。</li>
<li>切换开销比进程小，但仍<strong>需内核参与</strong>。</li>
</ul>
<p><strong>协程（Coroutine）</strong></p>
<ul>
<li>用户态的 <strong>轻量级线程</strong>，由<strong>程序自身调度</strong>。</li>
<li>主动让出 CPU（<strong>非抢占式</strong>），切换<strong>只保存寄存器/栈指针</strong>，开销极小。</li>
<li>适合大量并发 IO 场景（如异步网络请求）。</li>
</ul>
<hr />
<h2 id="进程间通信方式"><a class="markdownIt-Anchor" href="#进程间通信方式"></a> 进程间通信方式</h2>
<p><strong>管道（Pipe）</strong></p>
<ul>
<li>分 <strong>无名管道</strong>（只能在有血缘关系的进程间通信）和 <strong>有名管道</strong>（FIFO，可在无血缘进程间通信）。</li>
<li><strong>半双工</strong>：同一时间只能单向传输。</li>
</ul>
<p><strong>消息队列（Message Queue）</strong></p>
<ul>
<li>内核维护的 <strong>消息链表</strong>。</li>
<li>适合多对多通信，但消息体积受内核限制。</li>
</ul>
<p><strong>共享内存（Shared Memory）</strong></p>
<ul>
<li>多个进程共享同一块物理内存。</li>
<li><strong>速度最快</strong>，因为数据不需要在内核与用户空间拷贝。</li>
<li>通常需要配合 <strong>信号量</strong> 做同步。</li>
</ul>
<p><strong>信号量（Semaphore）</strong></p>
<ul>
<li>一个 <strong>计数器</strong>，用于控制对共享资源的访问。</li>
<li>常用于 <strong>进程/线程间的互斥与同步</strong>，本身不传递数据。</li>
</ul>
<p><strong>信号（Signal）</strong></p>
<ul>
<li>一种 <strong>异步通知机制</strong>，用于告诉进程发生了某事件（如 <code>Ctrl+C</code> 触发 <code>SIGINT</code>）。</li>
<li>常用于进程控制、异常处理。</li>
</ul>
<p><strong>套接字（Socket）</strong></p>
<ul>
<li>可用于 <strong>同一台机器</strong> 或 <strong>不同机器</strong> 之间的通信。</li>
<li>支持 <strong>双向通信</strong>，是网络编程的核心。</li>
</ul>
<hr />
<h2 id="进程间通信的选择"><a class="markdownIt-Anchor" href="#进程间通信的选择"></a> 进程间通信的选择</h2>
<ul>
<li><strong>管道（Pipe）</strong>
<ul>
<li>简单、快速，适合 <strong>父子进程间少量数据传递</strong>。</li>
</ul>
</li>
<li><strong>消息队列（Message Queue）</strong>
<ul>
<li>适合 <strong>多进程间有序/分类消息传递</strong>，但大数据效率较低。</li>
</ul>
</li>
<li><strong>共享内存（Shared Memory）</strong>
<ul>
<li><strong>最快</strong>，适合 <strong>大量数据、高性能通信</strong>；需配合信号量保证同步。</li>
</ul>
</li>
<li><strong>信号量（Semaphore）</strong>
<ul>
<li>计数器，<strong>控制同步与互斥</strong>，通常与共享内存结合使用。</li>
</ul>
</li>
<li><strong>信号（Signal）</strong>
<ul>
<li><strong>事件通知/异常处理</strong>，不适合传递大数据，如Ctrl+C。</li>
</ul>
</li>
<li><strong>套接字（Socket）</strong>
<ul>
<li>可<strong>跨主机通信</strong>，适合分布式系统和网络通信。</li>
</ul>
</li>
</ul>
<blockquote>
<p>简单父子通信 → 管道</p>
<p>多进程消息传递 → 消息队列</p>
<p>大量数据共享 → 共享内存 + 信号量</p>
<p>事件通知 → 信号</p>
<p>跨主机/网络 → 套接字</p>
</blockquote>
<hr />
<h2 id="进程间的状态"><a class="markdownIt-Anchor" href="#进程间的状态"></a> 进程间的状态</h2>
<ul>
<li><strong>创建（new）</strong>：进程创建中。</li>
<li><strong>就绪（ready）</strong>：等待 CPU 调度。</li>
<li><strong>运行（running）</strong>：占用 CPU 正在执行。</li>
<li><strong>阻塞（waiting）</strong>：等待 I/O 或事件。</li>
<li><strong>终止（terminated）</strong>：执行完成或被终止。</li>
</ul>
<hr />
<h2 id="线程间通信方式"><a class="markdownIt-Anchor" href="#线程间通信方式"></a> 线程间通信方式</h2>
<p><strong>临界区（Critical Section）</strong></p>
<ul>
<li>保护共享资源的<strong>那段代码片段</strong>，一次只允许一个线程进入。</li>
</ul>
<p><strong>互斥量（Mutex）</strong></p>
<ul>
<li>互斥锁机制，线程必须先获取锁才能访问资源。</li>
<li>适合 <strong>独占访问</strong>。</li>
</ul>
<p><strong>信号量（Semaphore）</strong></p>
<ul>
<li><strong>计数器</strong>，允许多个线程同时访问一定数量的资源。</li>
<li>适合 <strong>并发限流</strong>。</li>
</ul>
<p><strong>条件变量（Condition Variable）</strong></p>
<ul>
<li>线程可等待某条件满足后再执行，常与互斥锁配合。</li>
<li>适合 <strong>线程间同步/通知</strong>。</li>
</ul>
<p><strong>读写锁（RWLock）</strong></p>
<ul>
<li>同时允许多个读，但写时独占。</li>
<li>适合 <strong>读多写少</strong> 的场景。</li>
</ul>
<p><strong>事件（Event，对象/信号量变体）</strong></p>
<ul>
<li>一个线程发出信号，唤醒等待的线程。</li>
<li>常用于 <strong>线程间通知/状态同步</strong>。</li>
</ul>
<blockquote>
<p><strong>互斥量/临界区</strong> → 独占资源</p>
<p><strong>信号量</strong> → 限制并发数量</p>
<p><strong>条件变量/事件</strong> → 通知与同步</p>
<p><strong>读写锁</strong> → 读多写少优化</p>
</blockquote>
<hr />
<h2 id="多进程和多线程的适用场景区别"><a class="markdownIt-Anchor" href="#多进程和多线程的适用场景区别"></a> 多进程和多线程的适用场景区别</h2>
<ul>
<li><strong>多进程</strong>：<strong>稳定性好</strong>，进程隔离，<strong>不限制开销和效率的场景</strong>。适合多核 CPU、大规模并发服务。</li>
<li><strong>多线程</strong>：共享内存，<strong>切换开销小，效率高</strong>。适合计算密集型、轻量级并发。</li>
</ul>
<hr />
<h2 id="什么是线程池"><a class="markdownIt-Anchor" href="#什么是线程池"></a> 什么是线程池</h2>
<ul>
<li><strong>线程池</strong>：预先创建一定数量的线程，重复利用来执行任务。</li>
<li><strong>优点</strong>：减少频繁创建/销毁线程的开销，提高并发性能。</li>
</ul>
<blockquote>
<p><strong>典型应用</strong>：服务器请求处理。</p>
</blockquote>
<hr />
<h2 id="什么是线程安全"><a class="markdownIt-Anchor" href="#什么是线程安全"></a> 什么是线程安全</h2>
<ul>
<li>一个函数/代码段在多线程环境下被多个线程同时调用时，能保证结果正确。</li>
<li><strong>实现方法</strong>：加锁、原子操作、TLS（线程局部存储）。</li>
</ul>
<hr />
<h2 id="僵尸进程-孤儿进程和守护进程"><a class="markdownIt-Anchor" href="#僵尸进程-孤儿进程和守护进程"></a> 僵尸进程、孤儿进程和守护进程</h2>
<ul>
<li><strong>僵尸进程</strong>：子进程结束但父进程未回收（未调用 <code>wait</code>）。</li>
<li><strong>孤儿进程</strong>：父进程退出，子进程被 <code>init</code>/<code>systemd</code> 接管。</li>
<li><strong>守护进程</strong>：在后台运行、无终端控制的进程。</li>
</ul>
<hr />
<h2 id="僵尸进程有什么危害如何解决"><a class="markdownIt-Anchor" href="#僵尸进程有什么危害如何解决"></a> 僵尸进程有什么危害，如何解决</h2>
<ul>
<li>
<p>占用进程号（PID），大量僵尸进程会耗尽系统可用 PID，导致新进程无法创建。</p>
</li>
<li>
<p>占用少量内核资源（PCB）。</p>
</li>
</ul>
<p><strong>解决方法</strong></p>
<ul>
<li>
<p><strong>父进程调用 <code>wait()</code> / <code>waitpid()</code></strong> → 正常回收子进程。</p>
</li>
<li>
<p><strong>父进程结束</strong> → 子进程由 <code>init</code>（PID 1）接管并回收。</p>
</li>
<li>
<p><strong>发送信号杀父进程</strong> → 触发系统回收子进程。</p>
</li>
</ul>
<hr />
<h2 id="什么是内核线程和用户线程"><a class="markdownIt-Anchor" href="#什么是内核线程和用户线程"></a> 什么是内核线程和用户线程</h2>
<ul>
<li>
<p><strong>内核线程（Kernel Thread）</strong></p>
<ul>
<li>
<p>由 <strong>操作系统内核</strong> 创建和管理。</p>
</li>
<li>
<p>线程调度、切换都在内核态完成。</p>
</li>
<li>
<p>开销较大，但能充分利用多核 CPU。</p>
</li>
</ul>
</li>
<li>
<p><strong>用户线程（User Thread）</strong></p>
<ul>
<li>
<p>完全由 <strong>用户态库</strong> 实现，内核无感知。</p>
</li>
<li>
<p>线程切换开销小（不陷入内核）。</p>
</li>
<li>
<p>缺点：若一个线程阻塞，整个进程都会阻塞（N:1 模型）。</p>
</li>
</ul>
</li>
</ul>
<hr />
<h2 id="进程调度算法有哪些"><a class="markdownIt-Anchor" href="#进程调度算法有哪些"></a> 进程调度算法有哪些</h2>
<ul>
<li>
<p><strong>先来先服务（FCFS）</strong></p>
<ul>
<li>按到达顺序调度，公平但可能等待时间长。</li>
</ul>
</li>
<li>
<p><strong>短作业优先（SJF）</strong></p>
<ul>
<li>选择运行时间最短的进程，平均等待时间最小；对长作业不利。</li>
</ul>
</li>
<li>
<p><strong>最短剩余时间优先（SRTF）</strong></p>
<ul>
<li>SJF 的抢占式版本，剩余时间短的优先。</li>
</ul>
</li>
<li>
<p><strong>优先级调度</strong></p>
<ul>
<li>按优先级选择进程，高优先级可能导致低优先级饥饿。</li>
</ul>
</li>
<li>
<p><strong>时间片轮转（RR）</strong></p>
<ul>
<li>每个进程按时间片轮流执行，适合分时系统。</li>
</ul>
</li>
<li>
<p><strong>多级队列调度</strong></p>
<ul>
<li>不同类型进程放在不同队列，队列间有优先级。</li>
</ul>
</li>
<li>
<p><strong>多级反馈队列调度（MLFQ）</strong></p>
<ul>
<li>进程可在队列间动态调整，综合考虑响应与效率。</li>
</ul>
</li>
</ul>
<hr />
<h2 id="并发和并行"><a class="markdownIt-Anchor" href="#并发和并行"></a> 并发和并行</h2>
<p><strong>并发（Concurrency）- 单CPU</strong></p>
<ul>
<li><strong>逻辑上同时发生</strong>：在同一时间段内交替执行多个任务。</li>
<li>依赖 <strong>操作系统调度</strong>，强调 <strong>任务切换</strong>。</li>
</ul>
<p><strong>并行（Parallelism）- 多CPU</strong></p>
<ul>
<li><strong>物理上同时发生</strong>：在同一时刻由多个处理器同时执行。</li>
<li>需要 <strong>多核/多处理器</strong> 支持，强调 <strong>真正同时运行</strong>。</li>
</ul>
<hr />
<h2 id="单核机械上写多线程程序是否考虑加锁了解"><a class="markdownIt-Anchor" href="#单核机械上写多线程程序是否考虑加锁了解"></a> 单核机械上写多线程程序，是否考虑加锁（了解）</h2>
<p><strong>要考虑加锁</strong>，原因：</p>
<ul>
<li><strong>可抢占与切换</strong>：单核也会在任意时刻发生线程切换，共享可变数据会产生 <strong>竞态</strong>。</li>
<li><strong>内存可见性</strong>：没有同步就没有 <strong>happens-before</strong> 关系；编译器/CPU 重排序、缓存导致线程间 <strong>看不见彼此更新</strong>。</li>
<li><strong>原子性</strong>：读取-修改-写入这类复合操作在无锁下会被打断，出现数据损坏。</li>
</ul>
<hr />
<h2 id="内存交换和覆盖有什么区别"><a class="markdownIt-Anchor" href="#内存交换和覆盖有什么区别"></a> 内存交换和覆盖有什么区别</h2>
<p><strong>内存交换</strong>技术主要在<strong>不同进程间</strong>进行，而<strong>内存覆盖</strong>是在<strong>同一个进程</strong>中。</p>
<hr />
<h2 id="为什么使用虚拟内存"><a class="markdownIt-Anchor" href="#为什么使用虚拟内存"></a> 为什么使用虚拟内存</h2>
<ul>
<li>
<p><strong>隔离</strong>：<strong>进程互不干扰</strong>，更安全。</p>
</li>
<li>
<p><strong>扩展</strong>：<strong>地址空间大于物理内存，扩大空间</strong>。</p>
</li>
<li>
<p><strong>简化</strong>：程序只管虚拟地址，底层分配由系统处理。</p>
</li>
<li>
<p><strong>保护</strong>：<strong>防止非法访问</strong>。</p>
</li>
<li>
<p><strong>共享</strong>：<strong>可让多个进程共享一块物理内存</strong>。</p>
</li>
</ul>
<hr />
<h2 id="逻辑地址转化为物理地址的基本流程"><a class="markdownIt-Anchor" href="#逻辑地址转化为物理地址的基本流程"></a> 逻辑地址转化为物理地址的基本流程</h2>
<ol>
<li>
<p>CPU执行指令时生成<strong>逻辑地址</strong>（虚拟地址），该地址<strong>由页号和页内偏移量</strong>组成。</p>
</li>
<li>
<p><strong>内存管理单元</strong>（MMU）负责截<strong>获此逻辑地址</strong>。</p>
</li>
<li>
<p>MMU首<strong>先查询快表</strong>（TLB），若找到缓存的页表项（即TLB命中）则直接获取物理页框号；<strong>若未命中</strong>，则需<strong>查询内存中的页表以获取对应的物理页框号</strong>，并更新TLB。</p>
</li>
<li>
<p><strong>获取物理页框号后，将其与逻辑地址中的页内偏移量组合形成物理地址</strong>，计算公式为：物理地址 = 物理页框号 × 页面大小 + 页内偏移量。最终，使用该物理地址访问实际内存单元。</p>
</li>
</ol>
<blockquote>
<p>假设：</p>
<ul>
<li>
<p><strong>页面大小</strong>为 1024 字节。</p>
</li>
<li>
<p><strong>页表</strong>如下（记录了逻辑页号与物理块号的映射关系）：</p>
<table>
<thead>
<tr>
<th style="text-align:center">逻辑页号 (p)</th>
<th style="text-align:center">物理块号 (f)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">8</td>
</tr>
</tbody>
</table>
</li>
</ul>
<p>现在需要将<strong>逻辑地址 2500</strong> 转换为物理地址。</p>
<p><strong>转换过程如下：</strong></p>
<ol>
<li><strong>计算页号和页内偏移</strong><br />
页号 (p) = 逻辑地址 / 页面大小 = 2500 / 1024 ≈ 2.44 → ​<strong>​取整数部分，得到页号 2​</strong>​<br />
页内偏移 (d) = 逻辑地址 % 页面大小 = 2500 % 1024 = ​<strong>​452​</strong>​ (这里的 <code>%</code> 是取余运算)</li>
<li><strong>查页表，获取物理块号</strong><br />
根据计算得到的​<strong>​逻辑页号 p = 2​</strong>​，查找页表，找到其对应的​<strong>​物理块号 f = 8​</strong>​。</li>
<li><strong>组合物理地址</strong><br />
物理地址 = (物理块号 × 页面大小) + 页内偏移 = (8 × 1024) + 452 = 8192 + 452 = ​<strong>​8644​</strong>​<br />
所以，逻辑地址 2500 对应的物理地址是 ​<strong>​8644​</strong>​。</li>
</ol>
</blockquote>
<hr />
<h2 id="动态分区分配算法"><a class="markdownIt-Anchor" href="#动态分区分配算法"></a> 动态分区分配算法</h2>
<ul>
<li><strong>首次适应算法（First Fit, FF）</strong>
<ul>
<li>从<strong>低地址开始</strong>顺序查找空闲分区链（表），找到<strong>第一个</strong>能满足大小的空闲分区即进行分配。</li>
</ul>
</li>
<li><strong>临近适应算法（Next Fit, NF）</strong>
<ul>
<li>从<strong>上次分配的位置之后</strong>开始顺序查找，找到第一个能满足要求的空闲分区。</li>
</ul>
</li>
<li><strong>最佳适应算法（Best Fit, BF）</strong>
<ul>
<li>空闲分区按<strong>容量从小到大</strong>排序，分配时找到<strong>能满足要求的最小</strong>空闲分区，以减少浪费。</li>
</ul>
</li>
<li><strong>最坏适应算法（Worst Fit, WF）</strong>
<ul>
<li>空闲分区按<strong>容量从大到小</strong>排序，分配时总是选择<strong>最大的</strong>空闲分区进行分割。</li>
</ul>
</li>
</ul>
<hr />
<h2 id="磁盘调度算法"><a class="markdownIt-Anchor" href="#磁盘调度算法"></a> 磁盘调度算法</h2>
<ul>
<li><strong>先来先服务 (FCFS)</strong> 严格按照请求到达的<strong>先后顺序</strong>进行调度。</li>
<li><strong>最短寻道时间优先 (SSTF)</strong> 优先选择<strong>距当前磁头所在磁道距离最近</strong>的磁道进行访问，以使每次的寻找时间最短。</li>
<li><strong>扫描算法 (SCAN)</strong> 在磁头当前移动方向上选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象（也称<strong>电梯算法</strong>）。</li>
<li><strong>循环扫描算法 (CSCAN)</strong> 在SCAN算法基础上规定磁头<strong>单向移动</strong>来提供服务，回返时直接快速移动至起始端而不服务任何请求。</li>
</ul>
<hr />
<h2 id="页面置换算法"><a class="markdownIt-Anchor" href="#页面置换算法"></a> 页面置换算法</h2>
<p>好的，这是按照您要求的格式整理的页面置换算法：</p>
<h2 id="页面置换算法-2"><a class="markdownIt-Anchor" href="#页面置换算法-2"></a> 页面置换算法</h2>
<ul>
<li><strong>最佳置换算法（OPT, Optimal）</strong> 淘汰<strong>在未来最长时间内不会被访问</strong>的页面。这是理论上的最优算法，但<strong>无法实际实现</strong>（需要预知未来的页面访问序列），主要用于评估其他算法的性能。</li>
<li><strong>先进先出置换算法（FIFO, First-In First-Out）</strong> 淘汰<strong>最早进入内存</strong>的页面。实现简单，但可能会产生<strong>Belady异常</strong>（即分配更多物理块时缺页率反而升高）。</li>
<li><strong>最近最久未使用置换算法（LRU, Least Recently Used）</strong> 淘汰<strong>最长时间没有被访问</strong>的页面。性能接近OPT算法，能有效利用程序运行的局部性原理，但实现开销较大（需记录或维护页面访问时间或顺序）。</li>
<li><strong>时钟置换算法（CLOCK）</strong> 一种LRU的近似算法。通过一个循环队列和<strong>使用位（Use Bit）</strong> 来模拟页面访问历史。检查页面时，若使用位为1则置0并留下；若为0则淘汰。是实际系统中常用的折中方案。</li>
<li><strong>改进型时钟置换算法（Enhanced CLOCK）</strong> 在简单时钟算法基础上，额外考虑<strong>修改位（Modify Bit）</strong>。优先淘汰既未使用又未修改的页面，以减少将修改过的页面写回磁盘的I/O开销。</li>
</ul>
<p>希望这个清单对您有帮助。</p>
<hr />
<h2 id="fork-exec-wait函数"><a class="markdownIt-Anchor" href="#fork-exec-wait函数"></a> fork、exec、wait函数</h2>
<p><strong>fork()</strong></p>
<ul>
<li><strong>创建一个子进程</strong>。</li>
<li>子进程拷贝父进程的 <strong>页表</strong>（写时拷贝，COW），看似共享同一份内存。</li>
</ul>
<p><strong>exec()</strong></p>
<ul>
<li>在子进程中调用，用新的程序（如 elf 文件）<strong>替换当前进程的代码和数据</strong>。</li>
<li><strong>从此子进程运行新的程序，不再执行原来的代码</strong>。（分离父进程和子进程）</li>
</ul>
<p><strong>wait()</strong></p>
<ul>
<li>父进程调用 <code>wait</code>/<code>waitpid</code> 后会 <strong>阻塞</strong>，直到子进程结束或状态改变。</li>
<li>用于回收子进程资源，避免僵尸进程。</li>
</ul>
<blockquote>
<p>父进程通过fork函数创建一个子进程，此时这个子进程拷贝了父进程的页表，两个进程都读同一个内存，exec函数可以加载一个elf文件去替换父进程，从此子进程就可以运行不同的程序，父进程wait函数之后会阻塞，直到子进程状态发生改变</p>
</blockquote>
<hr />
<h2 id="fork-和-vfork-的区别"><a class="markdownIt-Anchor" href="#fork-和-vfork-的区别"></a> fork 和 vfork 的区别</h2>
<ul>
<li><strong>fork</strong>：子进程复制父进程地址空间（写时拷贝），<strong>父子进程几乎独立</strong>。</li>
<li><strong>vfork</strong>：子进程与父进程<strong>共享地址空间</strong>，直到执行 <code>exec</code> 或 <code>exit</code>。效率更高，但风险更大。</li>
</ul>
<hr />
<h2 id="当-for-循环遇到-fork-函数了解"><a class="markdownIt-Anchor" href="#当-for-循环遇到-fork-函数了解"></a> 当 for 循环遇到 fork 函数（了解）</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    fork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每次 <code>fork</code> 都会创建新进程，最终进程数为 <code>2^3 = 8</code>。</li>
</ul>
<hr />
<h2 id="读写锁-自旋锁和互斥锁的区别"><a class="markdownIt-Anchor" href="#读写锁-自旋锁和互斥锁的区别"></a> 读写锁、自旋锁和互斥锁的区别</h2>
<ul>
<li><strong>互斥锁 (mutex)</strong>：一个任务独占，阻塞等待。</li>
<li><strong>自旋锁 (spinlock)</strong>：忙等，不释放 CPU，适合临界区很短的情况。</li>
<li><strong>读写锁 (rwlock)</strong>：允许多个读者，但写者独占，读多写少时效率高。</li>
</ul>
<hr />
<h2 id="什么是原子操作"><a class="markdownIt-Anchor" href="#什么是原子操作"></a> 什么是原子操作？</h2>
<ul>
<li><strong>不可分割的操作</strong>，执行过程不会被中断。</li>
<li><strong>特点</strong>：<strong>要么完全执行，要么完全不执行</strong>。</li>
<li>典型例子：加减计数、位操作。</li>
<li>实现方式：关中断、总线锁、CPU 提供的原子指令。</li>
</ul>
<hr />
<h2 id="原子性问题可见性问题有序性问题"><a class="markdownIt-Anchor" href="#原子性问题可见性问题有序性问题"></a> 原子性问题，可见性问题，有序性问题</h2>
<p><strong>原子性问题</strong></p>
<ul>
<li>操作不可分割，中途不能被打断。</li>
</ul>
<p><strong>可见性问题</strong></p>
<ul>
<li>一个线程对共享变量的修改，其他线程不能立即看到。</li>
</ul>
<p><strong>有序性问题</strong></p>
<ul>
<li>程序执行顺序与代码顺序不一致。</li>
</ul>
<hr />
<h2 id="局部性原理是什么"><a class="markdownIt-Anchor" href="#局部性原理是什么"></a> 局部性原理是什么</h2>
<p>主要包括<strong>时间局部性</strong>和<strong>空间局部性</strong>。</p>
<ul>
<li><strong>时间局部性</strong>：如果执行了某个<strong>指令</strong>，那么不久后<strong>这条指令很有可能再被执行</strong>。</li>
<li><strong>空间局部性</strong>：如果访问了某个<strong>内存</strong>，那么不久后<strong>这个内存或其附近的内存很有可能再被访问</strong>。</li>
</ul>
<hr />
<h2 id="什么是死锁"><a class="markdownIt-Anchor" href="#什么是死锁"></a> 什么是死锁</h2>
<ul>
<li><strong>定义</strong>：多个进程/线程在执行过程中，因争夺资源而相互等待，导致无法继续推进。</li>
<li><strong>产生条件（死锁四要素）</strong>：
<ul>
<li><strong>互斥</strong>：资源一次只能被一个进程占用。</li>
<li><strong>请求保持</strong>：进程已持有资源，同时又提出新的资源请求。</li>
<li><strong>不可剥夺</strong>：资源只能由占有它的进程主动释放。</li>
<li><strong>循环等待</strong>：多个进程形成环形等待链。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>预防方法</strong></p>
<ul>
<li>
<p><strong>资源一次性分配</strong>：避免请求保持。</p>
</li>
<li>
<p><strong>可剥夺资源</strong>：当请求未满足时，主动释放已有资源。</p>
</li>
<li>
<p><strong>资源有序分配</strong>：给资源编号，进程按顺序申请，按逆序释放，避免环路等待。</p>
</li>
</ul>
</blockquote>
<hr />
<h1 id="linux"><a class="markdownIt-Anchor" href="#linux"></a> Linux</h1>
<h2 id="什么是系统调用"><a class="markdownIt-Anchor" href="#什么是系统调用"></a> 什么是系统调用</h2>
<ul>
<li><strong>用户态进程向内核请求服务</strong>的接口。</li>
<li>通过软中断或陷阱指令进入内核。</li>
</ul>
<hr />
<h2 id="linux-驱动的三大类型"><a class="markdownIt-Anchor" href="#linux-驱动的三大类型"></a> Linux 驱动的三大类型</h2>
<ul>
<li><strong>字符设备驱动</strong>：顺序访问，按字节流操作，如串口。</li>
<li><strong>块设备驱动</strong>：以数据块为单位，如硬盘。</li>
<li><strong>网络设备驱动</strong>：面向数据包，如网卡。</li>
</ul>
<hr />
<h2 id="什么是交叉编译"><a class="markdownIt-Anchor" href="#什么是交叉编译"></a> 什么是交叉编译</h2>
<ul>
<li>在 <strong>一个平台</strong> 上编译生成 <strong>另一个平台</strong> 可运行的程序。</li>
<li>常见于嵌入式开发（如在 PC 上编译 ARM 设备的程序）。</li>
</ul>
<hr />
<h2 id="linux-和-rtos-的区别"><a class="markdownIt-Anchor" href="#linux-和-rtos-的区别"></a> Linux 和 RTOS 的区别</h2>
<ul>
<li><strong>Linux</strong>：通用操作系统，功能强大，调度非实时。</li>
<li><strong>RTOS</strong>：实时操作系统，保证任务实时性，资源占用小。</li>
</ul>
<hr />
<h2 id="linux-内核由哪些构成"><a class="markdownIt-Anchor" href="#linux-内核由哪些构成"></a> Linux 内核由哪些构成？</h2>
<ul>
<li><strong>进程管理</strong></li>
<li><strong>内存管理</strong></li>
<li><strong>虚拟文件系统</strong></li>
<li><strong>网络接口</strong></li>
<li><strong>中断进程间通信</strong></li>
</ul>
<hr />
<h2 id="linux-系统组成部分"><a class="markdownIt-Anchor" href="#linux-系统组成部分"></a> Linux 系统组成部分</h2>
<ul>
<li><strong>内核（Kernel）</strong>：管理硬件资源（CPU、内存、设备、进程调度等）。</li>
<li><strong>Shell</strong>：命令解释器，用户与内核交互的接口。</li>
<li><strong>文件系统（File System）</strong>：统一管理数据存储与访问。</li>
<li><strong>应用程序（Applications）</strong>：运行在用户空间的软件。</li>
</ul>
<hr />
<h2 id="什么是根文件系统"><a class="markdownIt-Anchor" href="#什么是根文件系统"></a> 什么是根文件系统</h2>
<ul>
<li>Linux 系统启动后挂载的第一个文件系统 <code>/</code>。</li>
<li>包含：驱动、库文件、系统命令、配置文件.</li>
</ul>
<hr />
<h2 id="什么是临界区"><a class="markdownIt-Anchor" href="#什么是临界区"></a> 什么是临界区</h2>
<ul>
<li>多个线程/进程访问共享资源的代码区域。</li>
<li><strong>要求</strong>：在同一时刻只允许一个执行，通常用锁保护。</li>
</ul>
<hr />
<h2 id="什么是设备树"><a class="markdownIt-Anchor" href="#什么是设备树"></a> 什么是设备树</h2>
<ul>
<li><strong>定义</strong>：一种 <strong>树状的数据结构</strong>，用文本/二进制文件（<code>.dts</code> / <code>.dtb</code>）描述硬件资源（CPU、内存、外设、中断等）。</li>
<li><strong>作用</strong>：
<ul>
<li>把硬件信息从内核代码中抽离 → <strong>内核与硬件解耦</strong>。</li>
<li>让同一个内核可以适配不同硬件平台，只需更换设备树文件，而无需重新编译内核</li>
</ul>
</li>
</ul>
<hr />
<h2 id="select-poll-epoll-的区别与用处"><a class="markdownIt-Anchor" href="#select-poll-epoll-的区别与用处"></a> select / poll / epoll 的区别与用处</h2>
<ul>
<li><strong>select</strong>
<ul>
<li>用 <strong>位图</strong> 保存 fd，最大支持数有限（通常 1024）。</li>
<li>每次调用都要 <strong>重新设置 fd 集合</strong>。</li>
<li>内核返回后还需遍历所有 fd，效率低。</li>
<li>适合 <strong>少量连接</strong>、简单场景。</li>
</ul>
</li>
<li><strong>poll</strong>
<ul>
<li>用 <strong>数组（链表形式）</strong> 保存 fd，<strong>没有数量限制</strong>。</li>
<li>每次调用仍需遍历所有 fd，效率依旧不高。</li>
<li>比 select 灵活，但高并发时性能差。</li>
</ul>
</li>
<li><strong>epoll</strong>
<ul>
<li>内核用 <strong>红黑树管理 fd</strong>，就绪 fd 放在 <strong>就绪队列</strong>。</li>
<li>用户只需处理“就绪的 fd”，无需遍历全部。</li>
<li>支持 <strong>LT（水平触发）</strong> 和 <strong>ET（边缘触发）</strong> 两种模式。</li>
<li>在 <strong>大规模并发连接</strong>（如服务器）场景下性能最好。</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>
<p>fd（File Descriptor，文件描述符）： 就是“内核给打开的文件/资源的编号”，程序靠它操作资源。</p>
</li>
<li>
<p>位图（Bitmap）：用一组 <strong>二进制位（bit）</strong> 来表示某些状态或资源是否存在/可用。</p>
</li>
</ul>
</blockquote>
<hr />
<h2 id="为什么-linux-的中断分为上半部分和下半部分"><a class="markdownIt-Anchor" href="#为什么-linux-的中断分为上半部分和下半部分"></a> 为什么 Linux 的中断分为上半部分和下半部分？</h2>
<ul>
<li><strong>上半部分</strong>：<strong>快速处理中断</strong>（响应快），只做必要操作。</li>
<li><strong>下半部分</strong>：<strong>延迟处理耗时任务</strong>（软中断、tasklet、工作队列）。</li>
<li><strong>原因</strong>：缩短中断屏蔽时间，提高系统实时性。</li>
</ul>
<hr />
<h2 id="硬中断-vs-软中断"><a class="markdownIt-Anchor" href="#硬中断-vs-软中断"></a> 硬中断 vs 软中断</h2>
<ul>
<li><strong>硬中断（Hardware Interrupt）</strong>
<ul>
<li>来源：<strong>外部硬件设备</strong>（键盘、网卡、磁盘等）。</li>
<li>特点：<strong>异步</strong>发生，由硬件信号触发，CPU 立即响应。</li>
<li>用途：处理 I/O 请求、定时器等。</li>
</ul>
</li>
<li><strong>软中断（Software Interrupt）</strong>
<ul>
<li>来源：<strong>软件指令触发</strong>（如 <code>int</code> 指令、系统调用）。</li>
<li>特点：<strong>同步</strong>发生，由程序主动触发，用于进入内核。</li>
<li>用途：系统调用、调试、异常处理。</li>
</ul>
</li>
</ul>
<hr />
<h2 id="linux常见指令"><a class="markdownIt-Anchor" href="#linux常见指令"></a> Linux常见指令</h2>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/wzk4869/article/details/132855372">【Linux】Linux常用命令60条（含完整命令语句）_linux必学的60个命令-CSDN博客</a></p>
<hr />
<h1 id="stm32"><a class="markdownIt-Anchor" href="#stm32"></a> STM32</h1>
<p><strong>STM32学习笔记里记录地很详细，推荐看那里的，这里是引申。</strong></p>
<h2 id="arm-中的寄存器都有什么用"><a class="markdownIt-Anchor" href="#arm-中的寄存器都有什么用"></a> ARM 中的寄存器，都有什么用</h2>
<ul>
<li>
<p><strong>通用寄存器 (R0–R12)</strong></p>
<ul>
<li>临时存储、函数参数、返回值。</li>
<li>约定：
<ul>
<li><code>R0–R3</code>：函数参数 &amp; 返回值</li>
<li><code>R4–R11</code>：通常作为被调用者保存</li>
<li><code>R12 (IP)</code>：暂存寄存器</li>
</ul>
</li>
</ul>
<p><strong>SP (Stack Pointer, 栈指针)</strong></p>
<ul>
<li>指向当前栈顶。</li>
<li>分为：
<ul>
<li><strong>MSP (Main SP)</strong>：异常/中断、启动时使用</li>
<li><strong>PSP (Process SP)</strong>：线程模式任务栈（RTOS 常用）</li>
</ul>
</li>
</ul>
<p><strong>LR (Link Register, 链接寄存器)</strong></p>
<ul>
<li>保存函数返回地址。</li>
<li>在异常返回时，LR 含特殊值（如 <code>EXC_RETURN</code>），决定返回到线程/处理模式和使用 MSP/PSP。</li>
</ul>
<p><strong>PC (Program Counter, 程序计数器)</strong></p>
<ul>
<li>指向将要执行的下一条指令。</li>
<li>ARM 架构中一般是“取值 = 当前指令地址 + 偏移”。</li>
</ul>
<p><strong>xPSR (Program Status Register, 程序状态寄存器)</strong></p>
<ul>
<li>包含条件标志位 (N, Z, C, V)，执行状态，当前异常号等信息。</li>
</ul>
</li>
</ul>
<hr />
<h2 id="大小端是什么"><a class="markdownIt-Anchor" href="#大小端是什么"></a> 大小端是什么</h2>
<ul>
<li>
<p><strong>大端</strong>：<strong>高</strong>字节存储在<strong>低</strong>地址。</p>
</li>
<li>
<p><strong>小端</strong>：<strong>低</strong>字节存储在<strong>低</strong>地址。</p>
</li>
</ul>
<blockquote>
<p><strong>例子</strong>：<code>int a = 0x12345678;</code>（<strong>默认LSB优先</strong>）</p>
<ul>
<li>大端存储：<code>12 34 56 78</code></li>
<li>小端存储：<code>78 56 34 12</code></li>
</ul>
</blockquote>
<hr />
<h2 id="cortex-m3-和-cortex-m4-的区别"><a class="markdownIt-Anchor" href="#cortex-m3-和-cortex-m4-的区别"></a> Cortex-M3 和 Cortex-M4 的区别</h2>
<p><strong>同时支持大端/小端模式</strong></p>
<ul>
<li><strong>Cortex-M3</strong>：支持基本的 ARMv7-M 架构，32 位 RISC 内核，适合通用控制。</li>
<li><strong>Cortex-M4</strong>：在 M3 基础上增加 <strong>DSP 指令集</strong> 和 <strong>单精度浮点运算 (FPU)</strong>，适合信号处理。</li>
</ul>
<blockquote>
<p>M4 = M3 + DSP + 可选FPU</p>
</blockquote>
<hr />
<h2 id="gpio-工作模式"><a class="markdownIt-Anchor" href="#gpio-工作模式"></a> GPIO 工作模式</h2>
<ul>
<li><strong>输入模式</strong>：上拉输入、下拉输入、浮空输入、模拟输入</li>
<li><strong>输出模式</strong>：推挽输出、开漏输出</li>
<li><strong>复用功能</strong>：外设复用（USART、SPI 等）</li>
</ul>
<hr />
<h2 id="什么是-io-口悬空可能带来哪些问题"><a class="markdownIt-Anchor" href="#什么是-io-口悬空可能带来哪些问题"></a> 什么是 IO 口悬空，可能带来哪些问题</h2>
<ul>
<li><strong>IO 悬空</strong>：输入引脚未接电路。</li>
<li><strong>问题</strong>：电平不确定，可能产生抖动、功耗增加、误触发。</li>
<li><strong>解决</strong>：加上拉或下拉电阻。</li>
</ul>
<hr />
<h2 id="中断栈和任务栈有什么区别保存在哪里"><a class="markdownIt-Anchor" href="#中断栈和任务栈有什么区别保存在哪里"></a> 中断栈和任务栈有什么区别，保存在哪里</h2>
<p><strong>任务栈</strong></p>
<ul>
<li>每个任务都有独立栈，用来保存<strong>任务自己的局部变量、函数调用现场、寄存器</strong>。</li>
<li>由 RTOS 在创建任务时分配，通常放在 <strong>SRAM</strong>。</li>
</ul>
<p><strong>中断栈</strong></p>
<ul>
<li>中断发生时，CPU 自动把部分寄存器（PC、xPSR、LR 等）<strong>压入当前正在使用的栈</strong>。</li>
<li><strong>裸机</strong>：使用主栈指针 <strong>MSP</strong> 作为中断栈。</li>
<li><strong>RTOS</strong>（如 FreeRTOS）：通常把中断都跑在 <strong>MSP</strong> 上，而任务各自用 <strong>PSP</strong>。</li>
</ul>
<hr />
<h2 id="为什么-i2c-需要开漏输出-上拉电阻"><a class="markdownIt-Anchor" href="#为什么-i2c-需要开漏输出-上拉电阻"></a> 为什么 I2C 需要开漏输出 + 上拉电阻</h2>
<ul>
<li><strong>开漏输出</strong>：只能拉低电平，不能输出高电平。</li>
<li><strong>上拉电阻</strong>：总线空闲时保持高电平，实现线与。</li>
<li><strong>原因</strong>：多个设备共享总线，避免总线冲突。</li>
</ul>
<hr />
<h2 id="spi-的工作模式有哪些"><a class="markdownIt-Anchor" href="#spi-的工作模式有哪些"></a> SPI 的工作模式有哪些</h2>
<ul>
<li>
<p>由 <strong>CPOL（时钟极性）</strong> 和 <strong>CPHA（时钟相位）</strong> 决定，共 <strong>4 种模式</strong>：</p>
<p><strong>CPOL（Clock Polarity，时钟极性）</strong></p>
<ul>
<li>=0：时钟空闲时为 <strong>低电平</strong></li>
<li>=1：时钟空闲时为 <strong>高电平</strong></li>
</ul>
<p><strong>CPHA（Clock Phase，相位）</strong></p>
<ul>
<li>=0：<strong>第 1 个边沿采样</strong>（第一个有效边沿采样数据）</li>
<li>=1：<strong>第 2 个边沿采样</strong>（先在第一个边沿切换数据，第二个边沿采样）</li>
</ul>
</li>
<li>
<p>模式 0：CPOL=0, CPHA=0</p>
</li>
<li>
<p>模式 1：CPOL=0, CPHA=1</p>
</li>
<li>
<p>模式 2：CPOL=1, CPHA=0</p>
</li>
<li>
<p>模式 3：CPOL=1, CPHA=1</p>
</li>
</ul>
<hr />
<h2 id="spi往屏上刷一个像素点如何操作"><a class="markdownIt-Anchor" href="#spi往屏上刷一个像素点如何操作"></a> SPI往屏上刷一个像素点，如何操作</h2>
<ol>
<li>初始化SPI总线和设备</li>
<li>设置地址窗口到(x, y)</li>
<li>发送像素颜色（RGB565两字节，高在前）</li>
</ol>
<hr />
<h2 id="rs232-和-rs485-的区别"><a class="markdownIt-Anchor" href="#rs232-和-rs485-的区别"></a> RS232 和 RS485 的区别</h2>
<ul>
<li><strong>RS232</strong>：
<ul>
<li><strong>单端信号</strong>，<strong>点对点</strong>通信</li>
<li><strong>距离短</strong></li>
<li>抗干扰弱</li>
<li>逻辑“1”≈ −3V ~ −15V，逻辑“0”≈ +3V ~ +15V</li>
</ul>
</li>
<li><strong>RS485</strong>：
<ul>
<li><strong>差分信号</strong>，支持<strong>多点</strong>总线</li>
<li><strong>距离远</strong></li>
<li>抗干扰强</li>
<li>A、B 线电压差 +2V~+6V 表示逻辑 1，−2V~−6V 表示逻辑 0</li>
</ul>
</li>
</ul>
<hr />
<h2 id="stm32-上电后到-__main-的过程"><a class="markdownIt-Anchor" href="#stm32-上电后到-__main-的过程"></a> STM32 上电后到 <code>__main</code> 的过程</h2>
<ol>
<li><strong>硬件复位</strong></li>
</ol>
<ul>
<li>上电/复位后，Cortex-M 内核自动完成：
<ul>
<li>取向量表第 0 项 → <strong>Initial_SP</strong>，装入 MSP。</li>
<li>取向量表第 1 项 → <strong>Reset_Handler</strong> 地址，跳转执行。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>Reset_Handler</strong>（启动文件 <code>startup_xx.s</code> 中定义）</li>
</ol>
<ul>
<li>设置堆栈指针（MSP）、初始化中断向量表基址。</li>
<li>调用 <strong><code>SystemInit()</code></strong>：
<ul>
<li>配置系统时钟（HSE/PLL 等）。</li>
<li>配置 Flash 访问延时、总线分频。</li>
<li>初始化外设时钟（FPU、Cache、MPU 等）。</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>有的厂商库里叫 <strong><code>HardwareInit()</code> / <code>SystemClock_Config()</code></strong>，作用类似。</li>
</ul>
</blockquote>
<ol start="3">
<li><strong>C 运行时环境初始化</strong></li>
</ol>
<ul>
<li><strong>数据段初始化</strong>：将已初始化全局变量从 Flash 拷贝到 RAM。</li>
<li><strong>BSS 段清零</strong>：未初始化的全局/静态变量置 0。</li>
<li>可能还会初始化堆区指针。</li>
</ul>
<ol start="4">
<li><strong>调用 <code>__main</code></strong>（C 库入口函数）</li>
</ol>
<ul>
<li>进一步完成 C/C++ 环境初始化：
<ul>
<li>运行全局/静态对象的构造函数（C++）。</li>
<li>设置标准库需要的运行环境。</li>
</ul>
</li>
<li>最终调用 <code>main()</code>。</li>
</ul>
<hr />
<h2 id="msp-和-psp-两个指针是什么都在什么时候用"><a class="markdownIt-Anchor" href="#msp-和-psp-两个指针是什么都在什么时候用"></a> MSP 和 PSP 两个指针是什么，都在什么时候用</h2>
<ul>
<li><strong>MSP (Main Stack Pointer)</strong>：主堆栈指针，复位后默认使用，主要用于中断和异常。</li>
<li><strong>PSP (Process Stack Pointer)</strong>：进程堆栈指针，通常用于线程/任务。</li>
<li><strong>FreeRTOS</strong>：任务使用 PSP，内核/异常使用 MSP。</li>
</ul>
<hr />
<h2 id="中断能有返回值和参数吗"><a class="markdownIt-Anchor" href="#中断能有返回值和参数吗"></a> 中断能有返回值和参数吗？</h2>
<ul>
<li><strong>不能</strong>：中断服务函数由硬件调用，没有返回值和参数。</li>
<li><strong>传参方法</strong>：使用全局变量、队列、消息通知等方式。</li>
</ul>
<hr />
<h2 id="ram-rom-和-flash-的区别"><a class="markdownIt-Anchor" href="#ram-rom-和-flash-的区别"></a> RAM、ROM 和 Flash 的区别</h2>
<ul>
<li><strong>RAM</strong>（随机存取存储器）：读写速度快，断电数据丢失。</li>
<li><strong>ROM</strong>（只读存储器）：出厂时写入，通常不可修改。</li>
<li><strong>Flash</strong>：非易失存储，可擦写，常用于固件和数据存储。</li>
</ul>
<hr />
<h2 id="cache-是什么cache-一致性又是什么"><a class="markdownIt-Anchor" href="#cache-是什么cache-一致性又是什么"></a> Cache 是什么，Cache 一致性又是什么</h2>
<ul>
<li><strong>Cache</strong>：CPU 与内存之间的<strong>高速缓存</strong>，加快数据访问速度，它<strong>既能存指令，也能存数据</strong>。</li>
<li><strong>Cache 一致性</strong>：多核 CPU 或 DMA 等访问共享数据时，确保各个缓存的数据与主存一致。
<ul>
<li>解决方式：<strong>MESI协议</strong></li>
</ul>
</li>
</ul>
<hr />
<h2 id="什么是-smp了解"><a class="markdownIt-Anchor" href="#什么是-smp了解"></a> 什么是 SMP（了解）</h2>
<ul>
<li><strong>SMP (Symmetric Multi-Processing，对称多处理)</strong>：多个 CPU 核心共享同一内存和 I/O，运行同一个操作系统。</li>
<li><strong>特点</strong>：负载均衡、可并行执行任务，常用于多核处理器系统。</li>
</ul>
<hr />
<h2 id="为什么单片机不使用-malloc-函数"><a class="markdownIt-Anchor" href="#为什么单片机不使用-malloc-函数"></a> 为什么单片机不使用 malloc 函数</h2>
<ul>
<li>
<p><strong>资源限制</strong>：</p>
<ul>
<li>单片机 RAM 很小（几 KB ~ 几十 KB），<strong>动态分配容易造成内存碎片</strong>。</li>
</ul>
</li>
<li>
<p><strong>实时性要求</strong>：</p>
<ul>
<li><code>malloc/free</code> 的执行时间 <strong>不可预测</strong>，会破坏实时性。</li>
</ul>
</li>
<li>
<p><strong>可靠性问题</strong>：</p>
<ul>
<li>容易导致内存泄漏，调试困难，系统长期运行不稳定</li>
</ul>
</li>
</ul>
<hr />
<h2 id="什么是中断嵌套"><a class="markdownIt-Anchor" href="#什么是中断嵌套"></a> 什么是中断嵌套</h2>
<p>在处理中断 A 时，允许更高优先级的中断 B 打断执行。</p>
<ul>
<li><strong>优点</strong>：提高实时性。</li>
<li><strong>缺点</strong>：过多嵌套可能导致栈溢出</li>
</ul>
<hr />
<h2 id="如何处理-flash-擦写寿命问题"><a class="markdownIt-Anchor" href="#如何处理-flash-擦写寿命问题"></a> 如何处理 Flash 擦写寿命问题</h2>
<ul>
<li><strong>磨损均衡 (Wear Leveling)</strong>：均匀分布写入次数。</li>
<li><strong>文件系统优化</strong>：使用专门的嵌入式文件系统（如 FATFS + WL）。</li>
<li><strong>缓存/批量写入</strong>：减少频繁擦写。</li>
</ul>
<hr />
<h2 id="中断上下文和进程上下文的区别"><a class="markdownIt-Anchor" href="#中断上下文和进程上下文的区别"></a> 中断上下文和进程上下文的区别</h2>
<ul>
<li><strong>进程上下文</strong>：任务在用户态或内核态下运行，<strong>可以休眠/调度</strong>。</li>
<li><strong>中断上下文</strong>：响应硬件中断时执行，<strong>不能休眠，不能调用阻塞函数</strong>。</li>
</ul>
<hr />
<h2 id="can-通信的缺点"><a class="markdownIt-Anchor" href="#can-通信的缺点"></a> CAN 通信的缺点</h2>
<ul>
<li><strong>速率较低</strong>（典型 1Mbps）。</li>
<li><strong>帧长度有限</strong>（8字节数据）。</li>
<li>总线型拓扑，节点过多易导致仲裁延迟。</li>
<li><strong>无内置安全机制</strong>，易受干扰。</li>
</ul>
<hr />
<h1 id="freertos"><a class="markdownIt-Anchor" href="#freertos"></a> FreeRTOS</h1>
<h2 id="freertos-中使用的调度算法"><a class="markdownIt-Anchor" href="#freertos-中使用的调度算法"></a> FreeRTOS 中使用的调度算法</h2>
<ul>
<li>
<p><strong>基于优先级的抢占式调度</strong>。</p>
</li>
<li>
<p>相同优先级下，采用 <strong>时间片轮转</strong>。</p>
</li>
<li>
<p><strong>协作式调度</strong>，任务<strong>不会被强制打断</strong>，只有当任务主动调用、阻塞或结束时，才会切换到其他就绪任务</p>
</li>
</ul>
<hr />
<h2 id="freertos-的时间片的大小"><a class="markdownIt-Anchor" href="#freertos-的时间片的大小"></a> FreeRTOS 的时间片的大小</h2>
<ul>
<li>时间片由 <strong>SysTick 定时器中断周期</strong>决定。</li>
</ul>
<hr />
<h2 id="freertos-中任务的状态"><a class="markdownIt-Anchor" href="#freertos-中任务的状态"></a> FreeRTOS 中任务的状态</h2>
<ul>
<li><strong>就绪态（Ready）</strong></li>
<li><strong>运行态（Running）</strong></li>
<li><strong>阻塞态（Blocked）</strong>（等待事件或超时）</li>
<li><strong>挂起态（Suspended）</strong>（不可被调度，需手动恢复）</li>
<li><strong>终止态（Deleted）</strong></li>
</ul>
<hr />
<h2 id="freertos-创建任务的方法和区别"><a class="markdownIt-Anchor" href="#freertos-创建任务的方法和区别"></a> FreeRTOS 创建任务的方法和区别</h2>
<ul>
<li><strong>xTaskCreate</strong>：普通创建任务。</li>
<li><strong>xTaskCreateStatic</strong>：静态创建，用户提供栈和 TCB。</li>
<li><strong>区别</strong>：静态方式更安全，避免动态内存分配。</li>
</ul>
<hr />
<h2 id="freertos-的空闲任务以及它的作用"><a class="markdownIt-Anchor" href="#freertos-的空闲任务以及它的作用"></a> FreeRTOS 的空闲任务以及它的作用</h2>
<ul>
<li><strong>空闲任务 (Idle Task)</strong>：系统启动后自动创建。</li>
<li><strong>默认优先级最低</strong>，永远存在。</li>
<li><strong>作用</strong>：
<ul>
<li>回收已删除任务的资源。</li>
<li>执行用户定义的钩子函数（如省电模式）。</li>
</ul>
</li>
</ul>
<hr />
<h2 id="freertos-如何实现任务同步"><a class="markdownIt-Anchor" href="#freertos-如何实现任务同步"></a> FreeRTOS 如何实现任务同步</h2>
<ul>
<li><strong>信号量</strong>：用于任务间同步（包括二值信号量、计数信号量）。</li>
<li><strong>互斥量</strong>：解决资源互斥。</li>
<li><strong>队列</strong>：任务间数据传递。</li>
<li><strong>事件组</strong>：多任务事件同步</li>
</ul>
<hr />
<h2 id="freertos-中的-svc-systick-和-pendsv-的作用和区别"><a class="markdownIt-Anchor" href="#freertos-中的-svc-systick-和-pendsv-的作用和区别"></a> FreeRTOS 中的 SVC、SysTick 和 PendSV 的作用和区别</h2>
<ul>
<li><strong>SVC (Supervisor Call)</strong>：系统调用，进入内核模式。
<ul>
<li>系统启动时用 <strong>SVC_Handler</strong> 进入第一个任务（第一次上下文切换）。</li>
<li>相当于“进入内核”的入口。</li>
</ul>
</li>
<li><strong>SysTick</strong>：系统定时器中断，触发任务调度，给操作系统提供 <strong>时间基准 (tick)</strong>。
<ul>
<li>周期性触发 <code>SysTick_Handler</code>。</li>
<li>内核更新系统时钟（<code>xTickCount</code>）。</li>
</ul>
</li>
<li><strong>PendSV</strong>：<strong>最低优先级中断</strong>，用于<strong>任务上下文切换</strong>。
<ul>
<li>因优先级最低，确保不会打断其他更重要的中断。</li>
<li>保存当前任务寄存器（上下文），切换栈指针（PSP），恢复下一个任务的上下文。</li>
</ul>
</li>
</ul>
<hr />
<h2 id="要实现任务调度可以只有systick中断吗"><a class="markdownIt-Anchor" href="#要实现任务调度可以只有systick中断吗"></a> 要实现任务调度，可以只有systick中断吗</h2>
<p>理论上可以：</p>
<ul>
<li>SysTick 定时中断里直接做任务切换（保存现场、恢复下一个任务）。</li>
</ul>
<p>但这样会导致：</p>
<ul>
<li><strong>调度逻辑绑死在 SysTick</strong>，不灵活。</li>
<li>若有其它触发（信号量、事件、外设中断唤醒任务），也必须塞进 SysTick，复杂度高。</li>
</ul>
<hr />
<h2 id="freertos-为什么要用-pendsv"><a class="markdownIt-Anchor" href="#freertos-为什么要用-pendsv"></a> FreeRTOS 为什么要用 PendSV</h2>
<ul>
<li>PendSV 可设为<strong>最低优先级</strong>，确保任务切换<strong>不会打断其他中断处理</strong>。</li>
<li>这样 <strong>上下文切换延迟最小，效率最高</strong>。</li>
</ul>
<hr />
<h2 id="freertos-中的任务控制块是什么"><a class="markdownIt-Anchor" href="#freertos-中的任务控制块是什么"></a> FreeRTOS 中的任务控制块是什么</h2>
<ul>
<li><strong>任务控制块 (TCB, Task Control Block)</strong>：保存任务的所有信息。</li>
<li><strong>主要内容</strong>：
<ul>
<li>栈指针（pxTopOfStack）</li>
<li>任务优先级（uxPriority）</li>
<li>任务状态（xStateListItem）</li>
<li>延时/阻塞时间（pxStack）</li>
<li>任务名（pcTaskName）</li>
</ul>
</li>
</ul>
<hr />
<h2 id="freertos-如何实现任务切换过程是什么"><a class="markdownIt-Anchor" href="#freertos-如何实现任务切换过程是什么"></a> FreeRTOS 如何实现任务切换，过程是什么</h2>
<p><strong>触发条件</strong></p>
<ul>
<li>周期性 <strong>SysTick</strong> 中断（时间片/延时到期）。</li>
<li>任务调用阻塞函数（如 <code>vTaskDelay</code>、<code>xQueueReceive</code>）。</li>
<li>高优先级任务进入就绪态。</li>
</ul>
<p><strong>切换机制</strong></p>
<ol>
<li><strong>触发调度请求</strong>：SysTick 或 <code>taskYIELD()</code> 设置 <strong>PendSV</strong> 异常挂起。</li>
<li><strong>保存上下文</strong>：<code>PendSV_Handler</code> 将当前任务的 CPU 寄存器压入其任务栈（PSP）。</li>
<li><strong>调度器决策</strong>：根据优先级选择下一个要运行的任务。</li>
<li><strong>恢复上下文</strong>：从新任务栈中弹出寄存器，恢复执行环境。</li>
<li><strong>返回任务</strong>：CPU 跳转到新任务的断点继续运行。</li>
</ol>
<hr />
<h2 id="freertos-有哪两种内存分配方式有哪五种分配算法"><a class="markdownIt-Anchor" href="#freertos-有哪两种内存分配方式有哪五种分配算法"></a> FreeRTOS 有哪两种内存分配方式，有哪五种分配算法</h2>
<ul>
<li><strong>方式</strong>：
<ul>
<li><strong>静态分配</strong>：用户提供内存（更安全）。</li>
<li><strong>动态分配</strong>：系统在堆中申请。</li>
</ul>
</li>
<li><strong>算法（heap_1 ~ heap_5）</strong>：
<ul>
<li>heap_1：最简单，<strong>不</strong>允许<strong>释放</strong>，<strong>无内存碎片</strong>。</li>
<li>heap_2：允许<strong>释放</strong>，<strong>但可能产生碎片</strong>。</li>
<li>heap_3：直接调用 <code>malloc/free</code>。</li>
<li>heap_4：<strong>合并相邻空闲块</strong>，减少碎片。</li>
<li>heap_5：支持<strong>多个非连续内存区域碎片合并</strong>。</li>
</ul>
</li>
</ul>
<hr />
<h2 id="为什么在-freertos-中信号量-队列等设计了两套函数"><a class="markdownIt-Anchor" href="#为什么在-freertos-中信号量-队列等设计了两套函数"></a> 为什么在 FreeRTOS 中信号量、队列等设计了两套函数</h2>
<ul>
<li>FreeRTOS 提供 <strong>带阻塞时间</strong> 和 <strong>不带阻塞时间</strong> 两套接口。</li>
<li><strong>原因</strong>：
<ul>
<li>带阻塞时间：任务可在等待期间挂起，避免忙等。</li>
<li>不带阻塞时间：适合中断服务例程 (ISR)，因为中断中不能阻塞。</li>
</ul>
</li>
</ul>
<hr />
<h2 id="vtaskdelay-和-vtaskdelayuntil-的区别"><a class="markdownIt-Anchor" href="#vtaskdelay-和-vtaskdelayuntil-的区别"></a> vTaskDelay 和 vTaskDelayUntil 的区别</h2>
<ul>
<li><strong>vTaskDelay</strong>：延时相对当前时间。</li>
<li><strong>vTaskDelayUntil</strong>：延时基于绝对时间（适合周期性任务，抖动小）。</li>
</ul>
<hr />
<h1 id="硬件电路"><a class="markdownIt-Anchor" href="#硬件电路"></a> 硬件电路</h1>
<h2 id="stm32最小单元板构成"><a class="markdownIt-Anchor" href="#stm32最小单元板构成"></a> STM32最小单元板构成</h2>
<ul>
<li><strong>MCU</strong></li>
<li><strong>时钟电路</strong></li>
<li><strong>复位电路</strong></li>
<li><strong>电源电路</strong></li>
<li><strong>外设接口</strong></li>
</ul>
<hr />
<h2 id="ldo稳压器了解"><a class="markdownIt-Anchor" href="#ldo稳压器了解"></a> LDO稳压器（了解）</h2>
<p><strong>定义</strong>：LDO（Low Dropout Regulator）是一种 <strong>低压差线性稳压器</strong>，只能 <strong>降压</strong>，即输出电压 &lt; 输入电压。</p>
<ul>
<li>
<p>比较 <strong>取样的输出电压</strong> 和 <strong>基准电压</strong>。根据差值调节功率管。</p>
</li>
<li>
<p><strong>优点</strong>：<strong>电路简单，噪声低，纹波小</strong>，适合模拟/射频电路供电。</p>
</li>
<li>
<p><strong>缺点</strong>：<strong>效率低</strong>（受输入/输出电压差限制），<strong>只能降压</strong>，不能升压。</p>
</li>
</ul>
<hr />
<h1 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h1>
<h2 id="电脑1g的空间malloc12g-为什么可能成功"><a class="markdownIt-Anchor" href="#电脑1g的空间malloc12g-为什么可能成功"></a> 电脑1G的空间，malloc(1.2G) 为什么可能成功</h2>
<ul>
<li><strong>虚拟内存机制</strong>：<code>malloc</code> 申请的是虚拟地址空间，<strong>不一定立刻分配物理内存</strong>。</li>
<li><strong>实际情况</strong>：只要虚拟内存够（物理内存+交换空间），就能申请成功。</li>
</ul>
<hr />
<h2 id="常用的调试方法有什么了解"><a class="markdownIt-Anchor" href="#常用的调试方法有什么了解"></a> 常用的调试方法有什么（了解）</h2>
<ul>
<li><strong>软件调试</strong>：<code>printf</code>、日志输出、断点调试（gdb）。</li>
<li><strong>硬件调试</strong>：示波器、逻辑分析仪、JTAG/SWD。</li>
<li><strong>分析工具</strong>：perf、valgrind、strace、Wireshark。</li>
</ul>
<hr />
<h2 id="gdb-常见命令了解"><a class="markdownIt-Anchor" href="#gdb-常见命令了解"></a> gdb 常见命令（了解）</h2>
<ul>
<li><strong>启动调试</strong>
<ul>
<li><code>gdb ./a.out</code> → 以 gdb 打开可执行文件。</li>
<li><code>run</code> (简写 <code>r</code>) → 开始运行程序。</li>
</ul>
</li>
<li><strong>断点控制</strong>
<ul>
<li><code>break main</code> (简写 <code>b main</code>) → 在 <code>main</code> 函数入口设置断点。</li>
<li><code>break 10</code> → 在源码第 10 行设置断点。</li>
<li><code>delete</code> → 删除断点。</li>
</ul>
</li>
<li><strong>单步调试</strong>
<ul>
<li><code>next</code> (简写 <code>n</code>) → 单步执行，<strong>函数整体当成一步</strong>（不进入函数体）。</li>
<li><code>step</code> (简写 <code>s</code>) → 单步执行，<strong>遇到函数会进入</strong>函数体。</li>
<li><code>finish</code> → 运行到当前函数结束并返回。</li>
</ul>
</li>
<li><strong>程序控制</strong>
<ul>
<li><code>continue</code> (简写 <code>c</code>) → 继续运行，直到下一个断点或程序结束。</li>
<li><code>quit</code> (简写 <code>q</code>) → 退出 gdb。</li>
</ul>
</li>
<li><strong>信息查看</strong>
<ul>
<li><code>print x</code> (简写 <code>p x</code>) → 打印变量 <code>x</code> 的值。</li>
<li><code>bt</code> (backtrace) → 查看调用栈，显示当前函数调用路径。</li>
<li><code>info locals</code> → 查看当前函数的局部变量。</li>
<li><code>list</code> (简写 <code>l</code>) → 查看当前源码附近的代码。</li>
</ul>
</li>
</ul>
<hr />
<h1 id="说明"><a class="markdownIt-Anchor" href="#说明"></a> 说明</h1>
<p><strong>随缘更新</strong>，有问题跟我讲，有好的问题也可以分享。</p>

      </div>
    </div>
</div>

<div class="post-category">

    <div id="p-meta-i">
        
              
                <a class="hover-with-bg" href="/categories/C%E8%AF%AD%E8%A8%80/">C语言</a>
              
                <a class="hover-with-bg" href="/categories/C%E8%AF%AD%E8%A8%80/STM32/">STM32</a>
              
                <a class="hover-with-bg" href="/categories/C%E8%AF%AD%E8%A8%80/STM32/FreeRTOS/">FreeRTOS</a>
              
                <a class="hover-with-bg" href="/categories/C%E8%AF%AD%E8%A8%80/STM32/FreeRTOS/Linux/">Linux</a>
              
                <a class="hover-with-bg" href="/categories/C%E8%AF%AD%E8%A8%80/STM32/FreeRTOS/Linux/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
              
                <a class="hover-with-bg" href="/categories/C%E8%AF%AD%E8%A8%80/STM32/FreeRTOS/Linux/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
              
          
          
              
                <a class="hover-with-bg" href="/tags/%E8%AF%AD%E6%B3%95/"># 语法</a>
              
          
    </div>
</div>


<div class="post-footer">
  

</div>

</article>


        </div>
        
<footer class="text-center">
    
    
    
    
    
    <p>&copy;  2022 - 2025&nbsp;&nbsp;本书</p>
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme by <a href="https://github.com/oCoke/hexo-theme-miracle" target="_blank">Miracle</a></p>
    
    
</footer>

<div class="p-btn">
    
        <a class="toc-btn" id="toc-btn"><i id="i-menu"></i></a>
    
    
      <a class="toc-btn" id="share-btn"><i>
        <svg t="1670124379155" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2683" width="25" height="25"><path d="M395.946667 234.666667v64H256v469.333333h512V522.666667h64V768a64 64 0 0 1-64 64H256a64 64 0 0 1-64-64V298.666667a64 64 0 0 1 64-64h139.946667z m335.850666-87.914667l150.848 150.826667-158.378666 158.4-45.269334-45.248L748.394667 341.333333H672c-121.685333 0-220.714667 97.024-223.914667 217.941334L448 565.333333v85.333334h-64v-85.333334C384 406.272 512.938667 277.333333 672 277.333333h99.861333l-85.312-85.333333 45.248-45.248z" p-id="2684" fill="var(--first-text-color)"></path></svg>
      </i></a>
    
    <a href="javascript:window.scrollTo({top:0,behavior:'smooth'});" class="click-btn">
      <i id="i-up"></i>
    </a>
</div>

<!-- SCRIPTS -->






<script>
    document.getElementById("btn-dropdown").addEventListener('click', () => {
      toggleClass("#dropdown-menus","display-inline");
    });
    console.log('\n' + ' %c Powered by Hexo Theme Miracle ' + ' %c https://github.com/oCoke/hexo-theme-miracle ' + '\n' + '\n', 'color: #fff; background: #4F9BFA; padding:5px 0;', 'background: #FFF; padding:5px 0;');

    

    
  /* 小彩蛋: 饮茶先啦 */
  setTimeout(() => {
    var time = new Date();
    if (time.getHours() == 15) {
      let comment = document.createComment(' 三点几嚟！饮茶先啦！ ');
      document.body.insertBefore(comment, document.getElementsByTagName('header')[0]);
    }
  },1);
    
</script>


<script>
    var postImg = document.querySelectorAll("article[class=page] img");
    for (let imgi = 0; imgi < postImg.length; imgi++) {
        postImg[imgi].onclick = () => {
            let zoomImg = document.createElement("div");
            zoomImg.id = "zoomImg";
            zoomImg.innerHTML = `<div id="zoom-picture"></div>
    <div class="poptrox-overlay"
        style="position: fixed; left: 0px; top: 0px; z-index: 20000; width: 100%; height: 100%; text-align: center; cursor: zoom-out; opacity: 1;">
        <div style="display:inline-block;height:100%;vertical-align:middle;"></div>
        <div
            style="position:absolute;left:0;top:0;width:100%;height:100%;background:#000000;opacity:0;filter:alpha(opacity=0);">
        </div>
        <div class="poptrox-popup"
            style="display: inline-block; vertical-align: middle; position: relative; z-index: 1; cursor: zoom-out; min-width: 10px; min-height: 10px; width: auto; height: auto;">
            <div class="loader" style="display: none;"></div>
            <div class="pic" style="text-indent: 0px;"><img
                    src="${ postImg[imgi].srcset || postImg[imgi].src }" alt="Loading..."
                    style="vertical-align: bottom; max-width: 85vw; max-height: 85vh;"></div>
        </div>
    </div>`;
            document.body.appendChild(zoomImg);
                document.querySelector("#zoomImg").onclick = () => {
                    document.querySelector("#zoomImg").remove();
                }
        }
    }
    
</script>




    <script>
        query("#toc-btn")[0].onclick = () => {
            if (query(".post-toc")[0].innerHTML) {
                toggleClass(".post-toc", "display-inline");
            }
        }

        if (!query(".post-toc")[0].innerHTML) {
            addClass("#toc-btn","display-none");
        }
    </script>



    <script>
        query("#share-btn")[0].onclick = async () => {
            let url = `${location.protocol}//${location.hostname}${location.port ? ":"+location.port:location.port}${location.pathname}#read=${sessionStorage.getItem(location.pathname+"_read_y") || ""}`;
            try {
                await navigator.clipboard.writeText(url);
                prompt_core("分享链接已经复制至剪贴板", 4800, true);
            } catch(e) {
                prompt_core("分享链接复制失败，请手动复制<br/>"+url, 4800, false);
            }
        }
    </script>







    <script>
        const getScrollPosition = (el = window) => ({
            x: el.pageXOffset !== undefined ? el.pageXOffset : el.scrollLeft,
            y: el.pageYOffset !== undefined ? el.pageYOffset : el.scrollTop
        });
        // 此处的 750 是「页面元素的最大宽度」
        var wx = document.getElementsByClassName("article-m")[0].clientWidth;
        var wy = document.getElementsByClassName("article-m")[0].clientHeight;
        function windowScroll() {
            // 反复修改 确保页面尺寸不改变
            wx = document.getElementsByClassName("article-m")[0].clientWidth;
            wy = document.getElementsByClassName("article-m")[0].clientHeight;
            let y = Math.round(getScrollPosition().y);
            // console.log(y);
            // 组合字符串，同时记录页面坐标，页面宽度和高度
            let p = `${y}:${wx}:${wy}`;
            // 写入到 sessionStorage 中
            sessionStorage.setItem(location.pathname + "_read_y", p);
        }
        // URL 中是否包含传递的坐标信息
        setTimeout(() => {
            if (location.hash.split("#read=").length > 1) {
                prompt_core("已有阅读进度，正在跳转", 4800, true);
                // 分离字符串
                let read_y = location.hash.split("#read=")[1];
                read_y = read_y.split(":");
                // 组合乘积，顺滑移动至坐标
                window.scrollTo({top: Math.round(Number(read_y[0]) * Number(read_y[1] * Number(read_y[2] / wx / wy))), behavior: "smooth"});
            } else {
                // 从 sessionStorage 中获取
                let read_y = sessionStorage.getItem(location.pathname + "_read_y") || "0:0:0";
                read_y = read_y.split(":");
                if (read_y[0] != "0") prompt_core("已有阅读进度，正在跳转", 4800, true);
                window.scrollTo({top: Math.round(Number(read_y[0]) * Number(read_y[1] * Number(read_y[2] / wx / wy))), behavior: "smooth"});
            }
        }, 500);
        window.onscroll = windowScroll;
    </script>





        </div>
        <div id="css-loading">
            <h3 class="text-center">加载中...</h3>
        </div>
        
    </body>
</html>

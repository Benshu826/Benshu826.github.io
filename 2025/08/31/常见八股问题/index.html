<!DOCTYPE html>
<html lang="en">


<head>
    <meta charset="UTF-8">
    
    <link rel="apple-touch-icon" sizes="76x76" href="/null">
    <link rel="icon" type="image/png" href="/null">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
    <title>C/C++常见问题 - Ben Shu &#39;s Blog</title>
    
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
    
    
    <meta name="description" content="">
    <meta name="author" content="Big Ben">
    <meta name="keywords" content="">
    <meta property="og:title" content="C/C++常见问题"/>
    <style>


    
    :root{
        --shadow-color: rgba(0,0,0,0.2);
        --sec-shadow: rgba(0,0,0,0.03);
        --shadow-hover-color: rgba(0,0,0,0.28);
        --first-text-color: #475b6d;
        --second-text-color: #37475b;
        --third-text-color: #858585;
        --default-text-color: #505050;
        --default-link-color: #007bff;
        --link-color: #000000;
        --second-link-color: #4F9BFA;
        --code-color:rgba(27,31,35,.05);
        --post-bkg-color: #fff;
        --page-bkg-color: #f2f5f8;
        --nav-a-hover-color: #3498db;
        --post-sec-text-color: #718096;
        --sec-bkg: #f2f5f8;
        --color-mode: 'light';
        --bkg-h: rgba(255,255,255,0.6);
        --bkg-m: #e1e4e8;
        --home-title-color: #4169E1;
        --shadow: 0 4px 10px rgba(0,2,4,0.06),0 0 1px rgba(0,2,4,0.11);
        --hr-color: #ddd;
        --bg-t: #f4f4f4;
        --nav-bkg: rgba(255,255,255,0.6);
    }

@media (prefers-color-scheme: dark) {
  :root {
    --color-mode: 'dark';
  }

  :root:not([data-theme]) {
    --first-text-color: hsla(0,0%,100%,0.92);
    --second-text-color: hsla(0,0%,100%,0.86);
    --third-text-color: #a7a9ad;
    --default-text-color: #505050;
    --default-link-color: #1589e9;
    --link-color: #000000;
    --second-link-color: #30a9de;
    --post-bkg-color: #252d38;
    --page-bkg-color: #181c27;
    --nav-a-hover-color: #3498db;
    --post-sec-text-color: #a7a9ad;
    --sec-bkg: #364151;
    --bkg-h: rgba(255,255,255,0.2);
    --bkg-m: rgba(255,255,255,0.1);
    --home-title-color: rgb(226, 82, 90);
    --code-color:#3e4b5e;
    --shadow: none;
    --hr-color: #718096;
    --bg-t: #364151;
    --nav-bkg: rgba(13,17,23,0.6);
  }
}

[data-theme='dark'] {
    --shadow-color: rgba(0,0,0,0.2);
    --shadow-hover-color: rgba(0,0,0,0.28);
    --first-text-color: hsla(0,0%,100%,0.92);
    --second-text-color: hsla(0,0%,100%,0.86);
    --third-text-color: #a7a9ad;
    --default-text-color: #505050;
    --default-link-color: #1589e9;
    --link-color: #000000;
    --second-link-color: #30a9de;
    --post-bkg-color: #252d38;
    --page-bkg-color: #181c27;
    --nav-a-hover-color: #3498db;
    --post-sec-text-color: #a7a9ad;
    --sec-bkg: #364151;
    --bkg-h: rgba(255,255,255,0.2);
    --bkg-m: rgba(255,255,255,0.1);
    --home-title-color: rgb(226, 82, 90);
    --code-color:#3e4b5e;
    --shadow: none;
    --hr-color: #718096;
    --bg-t: #364151;
    --nav-bkg: rgba(13,17,23,0.6);
}

</style>



<style>
#page-main,footer,.p-btn{
    display: none;
}
html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
}
body {
    background-color: var(--page-bkg-color);
    color: var(--second-text-color);
    overflow-y: scroll;
    overflow-x: hidden;
    transition: all .3s;
}
a {
    color: var(--default-link-color);
    text-decoration: none;
    background-color: transparent;
}
a:hover{
    color: var(--second-link-color);
}
.main-content,.post-card-main{
    margin: 30px;
}



@media (max-width: 410px){
    .post-card-main{
        max-width: 350px!important;
    }
}

@media (max-width: 980px){
    .post-card-main{
        max-width: 520px!important;
    }
}


@media (min-width: 780px){ 
    h3{
        font-size: 1.5rem;
        line-height: 1.5em;
    }
}
@media (min-width: 1280px){ 
    h3{
        font-size: 1.7rem;
        line-height: 1.5em;
    }
}
@media (min-width: 2096px){ 
    h3{
        font-size: 1.8rem;
        line-height: 1.5em;
    }
}

.text-center{
    text-align: center!important;
}
.middle-center{
    display: -webkit-box;
    display: -ms-flexbox;
    display: flex;
    -webkit-box-align: center;
    -ms-flex-align: center;
    align-items: center;
    -webkit-box-pack: center;
    -ms-flex-pack: center;
    justify-content: center;
    height: 100%;
}
header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    position: fixed;
    height: 54px;
    padding: 0 1.25rem;
    top: 0;
    left: 0;
    right: 0;
    z-index: 10;
    border-bottom: 1px solid var(--bkg-m);
    background-color: var(--nav-bkg);
    backdrop-filter: blur(4px);
    transition: all .3s;
}
header .header__left, header .header__right {
    display: flex;
    align-items: center;
    font-family: rubik,sans-serif,Varela Round;
}
header .header__left .logo__text {
    font-size: 18px;
    font-weight: 450;
    padding: 14.5px 10px;
    border-radius: 5px;
    color: var(--second-text-color);
}
header .header__right .navbar__menus {
    height: 54px;
    padding: 0 0 0 15px;
}
header .header__right .button {
    color: var(--second-text-color);
}
header .header__right .navbar__menus .navbar-menu {
    display: inline-block;
    align-items: center;
    height: 54px;
    padding: 0 10px;
    font-size: 16px;
    line-height: 54px;
}
header .header__right .dropdown-icon {
    display: none;
    height: 54px;
    padding: 15px 10px;
    border: 0;
    background-color: transparent;
}
header .header__right .dropdown-menus {
    line-height: 2rem;
    animation: slide-in .15s ease 1;
    display: none;
    position: absolute;
    left: 12px;
    right: 12px;
    top: calc(54px + 10px);
    border-radius: 6px;
    padding: 24px;
    background-color: var(--page-bkg-color);
    border: 1px solid var(--bkg-m);
    z-index: 9999;
    justify-items: center;
    justify-content: center;
    flex-direction: column;
}
header .header__right #btn-search, header .header__right #btn-toggle-dark{
    display: inline-block;
    padding:  18px 10px;
    height: 25px;
}
header .header__right #btn-dropdown{
  display: inline-block;
  padding:  13.5px 0;
}
header .header__right .dropdown-menus .dropdown-menu {
    padding: 10px;
    color: var(--second-text-color);
}
@media screen and (max-width: 764px){
.navbar__menus {
    display: none!important;
}
.dropdown-icon {
    display: inline-block!important;
}
}
.p-btn{
    position: fixed;
    bottom: 1.2rem;
    right: 1.2rem;
    contain: layout;
}
.toc-btn,.click-btn{
    cursor: pointer;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    align-items: center;
    margin-top: .5rem;
    font-size: .75rem;
    background-color: var(--sec-bkg);
    display: block;
    padding: 0.9rem;
    box-shadow: 0 0.3rem 0.6rem rgba(48,55,66,.15);
    border: none;
    border-radius: 0.5rem;
    line-height: 1;
    color: var(--first-text-color);
}
.toc-link{
    color: var(--second-text-color);
}

#css-loading h3{
    font-weight: 500;
    font-size: 1.4rem;
    text-align: center;
    position: fixed;
    top: 200px;
    left: 0;
    right: 0;
    opacity: 0;
    animation: cssLoad;
    animation-delay: 0.3s;
    -webkit-animation: cssLoad;
    -webkit-animation-delay: 0.3s;
}
@keyframes cssLoad {
    from {
        opacity: 0;
    }
    to {
        opacity: 0.9;
    }
}


.memorial {
    -webkit-filter: grayscale(100%);
    -moz-filter: grayscale(100%);
    -ms-filter: grayscale(100%);
    -o-filter: grayscale(100%);
    filter: grayscale(100%);
    filter:progid:DXImageTransform.Microsoft.BasicImage(grayscale=1); filter:gray;
}


    .post-copyright:after {
        position: absolute;
        color: #fff;
        background: url("data:image/svg+xml;charset=utf-8,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 496 512'%3E%3Cpath fill='gray' d='M245.8 214.9l-33.2 17.3c-9.4-19.6-25.2-20-27.4-20-22.2 0-33.3 14.6-33.3 43.9 0 23.5 9.2 43.8 33.3 43.8 14.4 0 24.6-7 30.5-21.3l30.6 15.5a73.2 73.2 0 01-65.1 39c-22.6 0-74-10.3-74-77 0-58.7 43-77 72.6-77 30.8-.1 52.7 11.9 66 35.8zm143 0l-32.7 17.3c-9.5-19.8-25.7-20-27.9-20-22.1 0-33.2 14.6-33.2 43.9 0 23.5 9.2 43.8 33.2 43.8 14.5 0 24.7-7 30.5-21.3l31 15.5c-2 3.8-21.3 39-65 39-22.7 0-74-9.9-74-77 0-58.7 43-77 72.6-77C354 179 376 191 389 214.8zM247.7 8C104.7 8 0 123 0 256c0 138.4 113.6 248 247.6 248C377.5 504 496 403 496 256 496 118 389.4 8 247.6 8zm.8 450.8c-112.5 0-203.7-93-203.7-202.8 0-105.5 85.5-203.3 203.8-203.3A201.7 201.7 0 01451.3 256c0 121.7-99.7 202.9-202.9 202.9z'/%3E%3C/svg%3E");
        content: ' ';
        height: 10rem;
        width: 10rem;
        right: -2rem;
        top: -2rem;
        opacity: .1;
    }

</style>

    

    
        <!--
        <link rel="stylesheet" href="/css/page.css" media="print"
            onload="this.media='all';this.onload=null">
        <noscript>-->
            <link rel="stylesheet" href="/css/page.css">
        <!--</noscript>-->
    
    
    <link rel="stylesheet" href="/css/main.css" media="print" onload="this.media='all';this.onload=null">
    <noscript>
        <link rel="stylesheet" href="/css/main.css">
    </noscript>

    
    <script src="/js/main.js"></script>
    
      
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" integrity="sha512-fHwaWebuwA7NSF5Qg/af4UeDx9XqUpYpOGgubo3yWu+b2IQR4UeQwbb42Ti7gVAjNtVoI/I9TEoYeu9omwcC6g==" crossorigin="anonymous" referrerpolicy="no-referrer" /><!-- hexo injector head_end end --><meta name="generator" content="Hexo 7.3.0"></head>

    <body>
        <header>
            
<div class="header__left">
	<a href="/" class="button"><span class="logo__text">主页</span></a>
</div>
<div class="header__right">
	<div class="navbar__menus">
		
		<a href="/" class="button">
			<div class="navbar-menu">首页</div>
		</a>
		
		<a href="/archives/" class="button">
			<div class="navbar-menu">归档</div>
		</a>
		
		<a href="/categories/" class="button">
			<div class="navbar-menu">分类</div>
		</a>
		
		<a href="/tags/" class="button">
			<div class="navbar-menu">标签</div>
		</a>
		
		<a href="/about/" class="button">
			<div class="navbar-menu">关于</div>
		</a>
		
	</div>
	
	<a href="/search/" class="button">
		<div id="btn-search">
			<svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 1024 1024" width="24" height="24" fill="currentColor"
				stroke="currentColor" stroke-width="32">
				<path
					d="M192 448c0-141.152 114.848-256 256-256s256 114.848 256 256-114.848 256-256 256-256-114.848-256-256z m710.624 409.376l-206.88-206.88A318.784 318.784 0 0 0 768 448c0-176.736-143.264-320-320-320S128 271.264 128 448s143.264 320 320 320a318.784 318.784 0 0 0 202.496-72.256l206.88 206.88 45.248-45.248z">
				</path>
			</svg>
		</div>
	</a>
	
	<a href="javaScript:void(0);" class="button" id="btn-toggle-dark">
		<div>
			<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewbox="0 0 24 24" fill="none"
				stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
				<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
			</svg>
		</div>
	</a>
	<a href="javaScript:void(0);" class="dropdown-icon button">
		<div id="btn-dropdown">
			<svg xmlns="http://www.w3.org/2000/svg" viewbox="0 0 1024 1024" width="24" height="24" fill="currentColor"
				stroke="currentColor" stroke-width="32" stroke-linecap="round">
				<path
					d="M903.43 561.52H148.8c-13.25 0-24-10.75-24-24s10.75-24 24-24h754.63c13.25 0 24 10.75 24 24s-10.75 24-24 24zM903.43 204.31H148.8c-13.25 0-24-10.75-24-24s10.75-24 24-24h754.63c13.25 0 24 10.75 24 24s-10.75 24-24 24zM903.43 918.73H148.8c-13.25 0-24-10.75-24-24s10.75-24 24-24h754.63c13.25 0 24 10.75 24 24s-10.75 24-24 24z"
					fill="currentColor"></path>
			</svg>
		</div>
	</a>
	<div class="dropdown-menus" id="dropdown-menus">
		
		<a href="/" class="dropdown-menu button">首页</a>
		<br>
		
		<a href="/archives/" class="dropdown-menu button">归档</a>
		<br>
		
		<a href="/categories/" class="dropdown-menu button">分类</a>
		<br>
		
		<a href="/tags/" class="dropdown-menu button">标签</a>
		<br>
		
		<a href="/about/" class="dropdown-menu button">关于</a>
		<br>
		
	</div>
</div>

        </header>
        <div id="top"></div>
        <div id="page-main" class="main-content">
        <div class="mg-top">
            

<article class="page">
<div id="post-meta-m">
    <div class="post-meta" id="post-meta">
  <h3>C/C++常见问题</h3>
    
      <span class="post-meta-label">
        Big Ben
      </span>
    
    
      <span class="post-meta-label">
        <span class="p-dot"></span>
        <time datetime="2025-08-31 20:51" pubdate>
          2025-08-31
        </time>
      </span>
    
    
      
      <span class="post-meta">
        <span class="p-dot"></span>
        共 6.3k 字
      </span>
    
    
    
  </div>
  
</div>
<div class="article-m">
  <div class="post-toc">
    
      <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BA%8C%E5%8F%89%E6%A0%91%E9%80%9A%E8%BF%87%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%92%8C%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%88%A4%E6%96%AD%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-number">1.</span> <span class="toc-text"> 1. 二叉树通过中序遍历和后序遍历，判断前序遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E5%B8%B8%E8%A7%81%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text"> 2.常见的排序算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E5%B0%86%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E6%94%B9%E6%88%90%E9%9D%9E%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E4%B8%80%E8%88%AC%E7%94%A8%E6%A0%88"><span class="toc-number">3.</span> <span class="toc-text"> 3.将递归算法改成非递归算法，一般用栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E5%85%B3%E4%BA%8E%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84"><span class="toc-number">4.</span> <span class="toc-text"> 4.关于指针和数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E5%B8%B8%E9%87%8F%E6%8C%87%E9%92%88%E5%92%8C%E6%8C%87%E9%92%88%E5%B8%B8%E9%87%8F"><span class="toc-number">5.</span> <span class="toc-text"> 5.常量指针和指针常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6vector%E4%B8%8B%E7%9A%84resize%E5%92%8Creserve%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">6.</span> <span class="toc-text"> 6.Vector下的Resize和Reserve的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7%E6%8C%87%E9%92%88%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">7.</span> <span class="toc-text"> 7.指针的大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8strlen%E5%92%8Csizeof%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">8.</span> <span class="toc-text"> 8.strlen和sizeof的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9c%E8%AF%AD%E8%A8%80%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">9.</span> <span class="toc-text"> 9.C语言内存分配的方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E8%81%94%E5%90%88%E4%BD%93%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">10.</span> <span class="toc-text"> 10.结构体和联合体的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11%E9%87%8E%E6%8C%87%E9%92%88%E5%92%8C%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88"><span class="toc-number">11.</span> <span class="toc-text"> 11.野指针和悬空指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12%E6%95%B0%E7%BB%84%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">12.</span> <span class="toc-text"> 12.数组和链表的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13%E5%AE%8F%E5%87%BD%E6%95%B0%E6%B3%A8%E6%84%8F%E7%82%B9"><span class="toc-number">13.</span> <span class="toc-text"> 13.宏函数注意点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14include-%E5%92%8C-include-%E5%8C%BA%E5%88%AB"><span class="toc-number">14.</span> <span class="toc-text"> 14.#include &quot;&quot; 和 #include &lt;&gt; 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">15.</span> <span class="toc-text"> 15.全局变量和局部变量的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16define-typedef-const-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">16.</span> <span class="toc-text"> 16.#define、typedef、const 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17static-%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">17.</span> <span class="toc-text"> 17.static 的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18memcpy-%E5%92%8C-strcpy-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%93%AA%E4%B8%AA%E5%AE%89%E5%85%A8"><span class="toc-number">18.</span> <span class="toc-text"> 18.memcpy 和 strcpy 的区别，哪个安全？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">19.</span> <span class="toc-text"> 19.堆和栈的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20malloc-%E5%92%8C-new-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">20.</span> <span class="toc-text"> 20.malloc 和 new 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21struct-%E5%92%8C-class-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">21.</span> <span class="toc-text"> 21.struct 和 class 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22c-%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">22.</span> <span class="toc-text"> 22.C++ 类的访问权限</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="toc-number">23.</span> <span class="toc-text"> 23.内联函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24%E7%A8%8B%E5%BA%8F%E5%88%86%E4%B8%BA%E5%87%A0%E4%B8%AA%E6%AE%B5"><span class="toc-number">24.</span> <span class="toc-text"> 24.程序分为几个段？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25%E4%B8%80%E4%B8%AA-c-%E6%96%87%E4%BB%B6%E6%80%8E%E4%B9%88%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8F%AF%E6%89%A7%E8%A1%8C%E7%A8%8B%E5%BA%8F"><span class="toc-number">25.</span> <span class="toc-text"> 25.一个 .c 文件怎么转换为可执行程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91"><span class="toc-number">26.</span> <span class="toc-text"> 26.什么是交叉编译</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27tcp-%E5%92%8C-udp-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">27.</span> <span class="toc-text"> 27.TCP 和 UDP 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">28.</span> <span class="toc-text"> 28.进程、线程和协程的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">29.</span> <span class="toc-text"> 29.进程间通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">30.</span> <span class="toc-text"> 30.线程间通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">31.</span> <span class="toc-text"> 31.进程间的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B-%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-number">32.</span> <span class="toc-text"> 32.僵尸进程、孤儿进程和守护进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33%E5%A4%9A%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8C%BA%E5%88%AB"><span class="toc-number">33.</span> <span class="toc-text"> 33.多进程和多线程的适用场景区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34freertos-%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">34.</span> <span class="toc-text"> 34.FreeRTOS 中使用的调度算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35freertos-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E5%90%8C%E6%AD%A5"><span class="toc-number">35.</span> <span class="toc-text"> 35.FreeRTOS 如何实现任务同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36freertos-%E7%9A%84%E6%97%B6%E9%97%B4%E7%89%87%E7%9A%84%E5%A4%A7%E5%B0%8F"><span class="toc-number">36.</span> <span class="toc-text"> 36.FreeRTOS 的时间片的大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37freertos-%E4%B8%AD%E4%BB%BB%E5%8A%A1%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">37.</span> <span class="toc-text"> 37.FreeRTOS 中任务的状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38rs232-%E5%92%8C-rs485-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">38.</span> <span class="toc-text"> 38.RS232 和 RS485 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39%E5%A4%A7%E5%B0%8F%E7%AB%AF%E7%9A%84%E6%A6%82%E5%BF%B5%E4%BB%A5%E5%8F%8A%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E4%BE%8B%E5%AD%90"><span class="toc-number">39.</span> <span class="toc-text"> 39.大小端的概念，以及提供一个例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40%E4%BB%80%E4%B9%88%E6%98%AF%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">40.</span> <span class="toc-text"> 40.什么是系统调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41http-%E7%9A%84%E5%8F%91%E5%B1%95%E5%8F%B2"><span class="toc-number">41.</span> <span class="toc-text"> 41.HTTP 的发展史</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42%E4%B8%BA%E4%BB%80%E4%B9%88-i2c-%E9%9C%80%E8%A6%81%E5%BC%80%E6%BC%8F%E8%BE%93%E5%87%BA-%E4%B8%8A%E6%8B%89%E7%94%B5%E9%98%BB"><span class="toc-number">42.</span> <span class="toc-text"> 42.为什么 I2C 需要开漏输出 + 上拉电阻</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43%E5%8F%96%E6%B6%88%E5%86%85%E5%AD%98%E5%AF%B9%E9%BD%90%E7%9A%84%E6%96%B9%E6%B3%95%E4%BA%86%E8%A7%A3"><span class="toc-number">43.</span> <span class="toc-text"> 43.取消内存对齐的方法（了解）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44linux-%E9%A9%B1%E5%8A%A8%E7%9A%84%E4%B8%89%E5%A4%A7%E7%B1%BB%E5%9E%8B"><span class="toc-number">44.</span> <span class="toc-text"> 44.Linux 驱动的三大类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45linux-%E5%92%8C-rtos-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">45.</span> <span class="toc-text"> 45.Linux 和 RTOS 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-number">46.</span> <span class="toc-text"> 46.什么是回调函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-select-poll-epoll-%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E7%94%A8%E5%A4%84"><span class="toc-number">47.</span> <span class="toc-text"> 47. select &#x2F; poll &#x2F; epoll 的区别与用处</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E5%BE%81"><span class="toc-number">48.</span> <span class="toc-text"> 48.面向对象的三大特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49%E4%BB%80%E4%B9%88%E6%98%AF%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88c-%E7%9A%84%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%9C%E7%94%A8%E5%8F%88%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">49.</span> <span class="toc-text"> 49.什么是智能指针，C++ 的智能指针有哪些，作用又是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50fork-%E5%92%8C-vfork-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">50.</span> <span class="toc-text"> 50.fork 和 vfork 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51%E6%B7%B1%E6%8B%B7%E8%B4%9D%E5%92%8C%E6%B5%85%E6%8B%B7%E8%B4%9D%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">51.</span> <span class="toc-text"> 51.深拷贝和浅拷贝的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52%E5%BD%93-for-%E5%BE%AA%E7%8E%AF%E9%81%87%E5%88%B0-fork-%E5%87%BD%E6%95%B0"><span class="toc-number">52.</span> <span class="toc-text"> 52.当 for 循环遇到 fork 函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53spi-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">53.</span> <span class="toc-text"> 53.SPI 的工作模式有哪些</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54%E7%94%A8%E4%BD%8D%E8%BF%90%E7%AE%97%E8%AE%A1%E7%AE%97%E4%BD%99%E6%95%B0"><span class="toc-number">54.</span> <span class="toc-text"> 54.用位运算计算余数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">55.</span> <span class="toc-text"> 55. 什么是虚函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#56gpio-%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F"><span class="toc-number">56.</span> <span class="toc-text"> 56.GPIO 工作模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#57osi-%E5%9B%9B%E5%B1%82%E6%A8%A1%E5%9E%8B-%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B"><span class="toc-number">57.</span> <span class="toc-text"> 57.OSI 四层模型 &#x2F; 七层模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#58tcp-%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">58.</span> <span class="toc-text"> 58.TCP 粘包和拆包问题，怎么解决</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#59freertos-%E5%88%9B%E5%BB%BA%E4%BB%BB%E5%8A%A1%E7%9A%84%E6%96%B9%E6%B3%95%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-number">59.</span> <span class="toc-text"> 59.FreeRTOS 创建任务的方法和区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#60-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B"><span class="toc-number">60.</span> <span class="toc-text"> 60. TCP 三次握手（连接建立）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#61-tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE"><span class="toc-number">61.</span> <span class="toc-text"> 61. TCP 四次挥手（连接释放）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62freertos-%E7%9A%84%E7%A9%BA%E9%97%B2%E4%BB%BB%E5%8A%A1%E4%BB%A5%E5%8F%8A%E5%AE%83%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">62.</span> <span class="toc-text"> 62.FreeRTOS 的空闲任务以及它的作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63freertos-%E4%B8%AD%E7%9A%84-svc-systick-%E5%92%8C-pendsv-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E5%8C%BA%E5%88%AB"><span class="toc-number">63.</span> <span class="toc-text"> 63.FreeRTOS 中的 SVC、SysTick 和 PendSV 的作用和区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#64freertos-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8-pendsv"><span class="toc-number">64.</span> <span class="toc-text"> 64.FreeRTOS 为什么要用 PendSV</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#65%E8%AF%BB%E5%86%99%E9%94%81-%E8%87%AA%E6%97%8B%E9%94%81%E5%92%8C%E4%BA%92%E6%96%A5%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">65.</span> <span class="toc-text"> 65.读写锁、自旋锁和互斥锁的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#66freertos-%E4%B8%AD%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%8E%A7%E5%88%B6%E5%9D%97%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">66.</span> <span class="toc-text"> 66.FreeRTOS 中的任务控制块是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#67freertos-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BB%BB%E5%8A%A1%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">67.</span> <span class="toc-text"> 67.FreeRTOS 如何实现任务切换，过程是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#68msp-%E5%92%8C-psp-%E4%B8%A4%E4%B8%AA%E6%8C%87%E9%92%88%E6%98%AF%E4%BB%80%E4%B9%88%E9%83%BD%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E7%94%A8"><span class="toc-number">68.</span> <span class="toc-text"> 68.MSP 和 PSP 两个指针是什么，都在什么时候用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#69stm32-%E4%B8%8A%E7%94%B5%E5%90%8E%E5%88%B0-__main-%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">69.</span> <span class="toc-text"> 69.STM32 上电后到 __main 的过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#70%E4%B8%AD%E6%96%AD%E8%83%BD%E6%9C%89%E8%BF%94%E5%9B%9E%E5%80%BC%E5%92%8C%E5%8F%82%E6%95%B0%E5%90%97"><span class="toc-number">70.</span> <span class="toc-text"> 70.中断能有返回值和参数吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#71-vector-%E5%92%8C-list-%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-number">71.</span> <span class="toc-text"> 71. vector 和 list 的使用场景与区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#72%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5%E5%92%8C%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">72.</span> <span class="toc-text"> 72.静态链接和动态链接的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#73arm-%E4%B8%AD%E7%9A%84%E5%AF%84%E5%AD%98%E5%99%A8%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8"><span class="toc-number">73.</span> <span class="toc-text"> 73.ARM 中的寄存器，都有什么用</span></a></li></ol>
    
  </div>
    <div id="article">
      <div id="post-content" class="markdown-body textretty">
        <h2 id="1-二叉树通过中序遍历和后序遍历判断前序遍历"><a class="markdownIt-Anchor" href="#1-二叉树通过中序遍历和后序遍历判断前序遍历"></a> 1. 二叉树通过中序遍历和后序遍历，判断前序遍历</h2>
<p><strong>前序遍历：中左右；中序遍历：左中右；后序遍历：左右中。</strong></p>
<ul>
<li>先从后序找根节点</li>
<li>根据根节点，从中序遍历区分左子树和右子树</li>
<li>区分后再找对应的根据节点，循环往复</li>
</ul>
<p>已知中序：32145，后序32145</p>
<p>先看后序最末尾，5是根节点，对应中序遍历中5的左侧为左子树，右侧为右子树，可知3214是左子树；再看后续，3214已知是左子树，那么4就是根节点，对应中序遍历中4的左侧为左子树，右侧为右子树，可知321是左子树，…，可知，前序遍历是32145。</p>
<h2 id="2常见的排序算法"><a class="markdownIt-Anchor" href="#2常见的排序算法"></a> 2.常见的排序算法</h2>
<ul>
<li>
<p><strong>冒泡排序：</strong> 相邻元素两两比较，大的往后移，循环多次把最大值“冒”到最后。</p>
</li>
<li>
<p><strong>插入排序：</strong> 前面保持有序序列，取下一个元素，按大小插入到合适位置。</p>
</li>
<li>
<p><strong>选择排序：</strong> 每一轮从未排序区选择最小（或最大）的，与当前位置元素交换。</p>
</li>
<li>
<p><strong>快速排序：</strong> 取一个基准值，把小于的放左边，大于的放右边，然后递归分区排序。</p>
</li>
<li>
<p><strong>归并排序：</strong> 不断二分数组，递归到底后再逐层合并两个有序序列（需辅助数组）。</p>
</li>
<li>
<p><strong>基数排序：</strong> 按数位（个位、十位、百位…）依次排序，常用稳定排序作为子过程。</p>
</li>
<li>
<p><strong>希尔排序：</strong> 基于插入排序，先按较大间隔分组排序，再逐渐缩小间隔至 1。</p>
</li>
<li>
<p><strong>堆排序：</strong> 利用大顶堆/小顶堆，每次取堆顶元素放到末尾，再调整堆结构。</p>
</li>
<li>
<p><strong>计数排序：</strong> 统计每个元素出现次数，通过计数下标映射回输出（需额外数组）。</p>
</li>
<li>
<p><strong>桶排序：</strong> 按数值范围映射到不同桶内，每个桶独立排序，最后合并所有桶。</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2025/09/01/FE5rBgRM7qsvGCI.png" alt="" /></p>
<h2 id="3将递归算法改成非递归算法一般用栈"><a class="markdownIt-Anchor" href="#3将递归算法改成非递归算法一般用栈"></a> 3.将递归算法改成非递归算法，一般用栈</h2>
<h2 id="4关于指针和数组"><a class="markdownIt-Anchor" href="#4关于指针和数组"></a> 4.关于指针和数组</h2>
<p><strong>指针数组： int *arr[10];</strong></p>
<p>数组里的<strong>每个元素都是一个指针</strong>，arr是数组名，arr[i]是一个指针。</p>
<p><strong>数组指针： int (*p)[10];</strong></p>
<p><strong>一个指针，指向整个数组</strong></p>
<ul>
<li>
<p>a，类型int*，即首元素的指针</p>
</li>
<li>
<p><strong>&amp;a，类型int (*)[6]，即整个数组地址</strong></p>
</li>
<li>
<p>*a，等价于a[0] —&gt; *(a+i) = a[i]</p>
</li>
</ul>
<blockquote>
<p><strong>Q1：int a[6] = {1, 2, 3, 4, 5, 6};printf(“%d\n”, *(int *)(&amp;a + 1) - 1)的输出</strong></p>
<p>A：(&amp;a + 1)是a + 6， 这里的*(int *)没什么意义,*((int *)(&amp;a + 1) - 1)是a + 5，即6。</p>
</blockquote>
<blockquote>
<p><strong>Q2：char *buff[] = {“char”, “int”, “double”}; printf(“%c\n”, *(buff+1)[1])的输出</strong></p>
<p>A：(buff+1)是&quot;int&quot;，<strong>[]的优先级大于*</strong>，所以*(buff+1)[1]=*(buff+1+1)=*(buff+2)，取&quot;double&quot;的首元素&quot;d&quot;。</p>
</blockquote>
<h2 id="5常量指针和指针常量"><a class="markdownIt-Anchor" href="#5常量指针和指针常量"></a> 5.常量指针和指针常量</h2>
<p><strong>常量指针：const int *a; / int const *a;</strong></p>
<p><strong>底层Const</strong>，指针<strong>所指内容</strong>是常量，<strong>不能通过指针修改</strong>（但指针可以指向别处）</p>
<p><strong>指针常量：int *const a;</strong></p>
<p><strong>顶层Const</strong>，<strong>指针</strong>本身是常量，<strong>初始化后不能再指向别的地址</strong>。</p>
<h2 id="6vector下的resize和reserve的区别"><a class="markdownIt-Anchor" href="#6vector下的resize和reserve的区别"></a> 6.Vector下的Resize和Reserve的区别</h2>
<p><strong><code>resize(n)</code></strong>：改变大小，若变大则会构造新元素（对内置类型填充为 0，对类调用默认构造），可能导致 <strong>迭代器失效</strong>。</p>
<p><strong><code>reserve(n)</code></strong>：只调整容量，不改变元素数量；不会插入新元素，所以<strong>不会填充 0</strong>，只是预留空间；若实际扩容则 <strong>迭代器失效</strong>。</p>
<h2 id="7指针的大小"><a class="markdownIt-Anchor" href="#7指针的大小"></a> 7.指针的大小</h2>
<ul>
<li>32 位平台：指针大小通常 <strong>4 字节</strong>。</li>
<li>64 位平台：指针大小通常 <strong>8 字节</strong>。</li>
</ul>
<blockquote>
<p>不管 <code>int*</code>、<code>char*</code>、<code>double*</code>，指针大小都一样。</p>
</blockquote>
<h2 id="8strlen和sizeof的区别"><a class="markdownIt-Anchor" href="#8strlen和sizeof的区别"></a> 8.strlen和sizeof的区别</h2>
<p><strong><code>strlen(s)</code></strong>：计算 <strong>字符串内容长度</strong>（遇到 <code>\0</code> 停止，不含 <code>\0</code>），需在运行时遍历。</p>
<p><strong><code>sizeof(x)</code></strong>：计算 <strong>对象/类型所占内存字节数</strong>，在编译期确定（数组包含 <code>\0</code>）。</p>
<blockquote>
<p><strong>区别</strong>：<code>strlen</code> 得到“内容长度”，<code>sizeof</code> 得到“占用空间”。</p>
<p>数组的大小：sizeof(x) / sizeof(x[0])</p>
</blockquote>
<h2 id="9c语言内存分配的方式"><a class="markdownIt-Anchor" href="#9c语言内存分配的方式"></a> 9.C语言内存分配的方式</h2>
<ul>
<li>
<p><strong>静态存储区</strong>：全局变量、静态变量，程序运行期间始终存在。</p>
</li>
<li>
<p><strong>栈（Stack）</strong>：局部变量、函数参数，由编译器自动分配/释放。</p>
</li>
<li>
<p><strong>堆（Heap）</strong>：动态内存（<code>malloc/free</code>、<code>calloc</code>、<code>realloc</code>），由程序员手动管理</p>
</li>
</ul>
<h2 id="10结构体和联合体的区别"><a class="markdownIt-Anchor" href="#10结构体和联合体的区别"></a> 10.结构体和联合体的区别</h2>
<p><strong>结构体 (struct)</strong>：成员 <strong>独立存储</strong>，总大小 ≥ 成员之和，受 <strong>内存对齐</strong> 影响。</p>
<p><strong>联合体 (union)</strong>：所有成员 <strong>共用同一块内存</strong>，大小 = 最大成员大小，整体大小也需按 <strong>最大成员的对齐要求</strong> 对齐。</p>
<blockquote>
<p><strong>Q1：下面这个的输出是多少？</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span>&#123;</span></span><br><span class="line">	<span class="type">char</span> c[<span class="number">2</span>];</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%zu\n&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">struct</span> S));</span><br></pre></td></tr></table></figure>
<p>A：结果是12 Byte，对齐int类型</p>
<p><strong>Q2：如何用联合体来判断大小端？</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">U</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>  i;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> <span class="title">U</span> <span class="title">u</span>;</span></span><br><span class="line">    u.i = <span class="number">0x1234</span>;</span><br><span class="line">    <span class="keyword">if</span> (u.c == <span class="number">0x34</span>)         </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;小端\n&quot;</span>); <span class="comment">// 低地址存低字节</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;大端\n&quot;</span>); <span class="comment">// 低地址存高字节</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="11野指针和悬空指针"><a class="markdownIt-Anchor" href="#11野指针和悬空指针"></a> 11.野指针和悬空指针</h2>
<ul>
<li><strong>野指针</strong>：<strong>未初始化或指向不可知区域的指针</strong>。</li>
<li><strong>悬空指针</strong>：<strong>指向的内存已释放</strong>/失效，<strong>但没有置<code>NULL</code></strong>，仍被使用。</li>
</ul>
<blockquote>
<p><strong>避免方法</strong>：指针初始化为 <code>NULL</code>；释放后及时置为 <code>NULL</code>。</p>
</blockquote>
<h2 id="12数组和链表的区别"><a class="markdownIt-Anchor" href="#12数组和链表的区别"></a> 12.数组和链表的区别</h2>
<ul>
<li><strong>数组</strong>：<strong>连续内存</strong>，存储的是同一类型数据，<strong>支持随机访问，插入/删除效率低</strong>。</li>
<li><strong>链表</strong>：<strong>离散内存</strong>，<strong>插入/删除效率高，查找效率低</strong>。</li>
</ul>
<blockquote>
<p><strong>使用场景</strong>：查询多 → 数组；插入删除多 → 链表。</p>
</blockquote>
<h2 id="13宏函数注意点"><a class="markdownIt-Anchor" href="#13宏函数注意点"></a> 13.宏函数注意点</h2>
<ul>
<li>宏函数通过 <code>#define</code> 定义，<strong>预处理阶段替换</strong>，<strong>无类型检查</strong>。</li>
<li><strong>缺点</strong>：可能重复计算参数，调试困难。</li>
<li><strong>改进</strong>：参数和表达式用括号保护，推荐使用 <strong>内联函数</strong> 替代。</li>
</ul>
<h2 id="14include-和-include-区别"><a class="markdownIt-Anchor" href="#14include-和-include-区别"></a> 14.<code>#include &quot;&quot;</code> 和 <code>#include &lt;&gt;</code> 区别</h2>
<ul>
<li><strong><code>#include &quot;&quot;</code></strong>：先从<strong>当前目录</strong>查找，再去<strong>系统目录</strong>查找。</li>
<li><strong><code>#include &lt;&gt;</code></strong>：只从<strong>系统目录</strong>查找。</li>
</ul>
<h2 id="15全局变量和局部变量的区别"><a class="markdownIt-Anchor" href="#15全局变量和局部变量的区别"></a> 15.全局变量和局部变量的区别</h2>
<ul>
<li><strong>全局变量</strong>：定义在函数外，作用域是整个文件或程序，<strong>存储在静态区</strong>。</li>
<li><strong>局部变量</strong>：定义在函数/代码块内，<strong>存储在栈</strong>，作用域仅在定义范围内。</li>
</ul>
<h2 id="16define-typedef-const-的区别"><a class="markdownIt-Anchor" href="#16define-typedef-const-的区别"></a> 16.<code>#define</code>、<code>typedef</code>、<code>const</code> 的区别</h2>
<ul>
<li><strong><code>#define</code></strong>：预处理宏替换，<strong>无类型检查</strong>。</li>
<li><strong><code>typedef</code></strong>：<strong>给类型取别名</strong>，<strong>有类型检查</strong>。</li>
<li><strong><code>const</code></strong>：定义常量，编译器<strong>检查类型</strong>，<strong>分配内存</strong>。</li>
</ul>
<blockquote>
<p>建议：常量用 <code>const</code>，类型别名用 <code>typedef</code>/<code>using</code>，少用 <code>#define</code>。</p>
</blockquote>
<h2 id="17static-的作用"><a class="markdownIt-Anchor" href="#17static-的作用"></a> 17.static 的作用</h2>
<ul>
<li>
<p><strong>在 C 中</strong>：</p>
<ul>
<li>局部静态变量：存储在<strong>静态存储区</strong>，函数结束不销毁。</li>
<li>全局静态变量：存储在<strong>静态存储区</strong>，仅在本文件可见。</li>
<li>静态函数：<strong>仅在本文件内可见</strong>。</li>
</ul>
</li>
<li>
<p><strong>在 C++ 中</strong>：</p>
<p><strong>类里</strong></p>
<ul>
<li><strong>静态成员变量</strong>：属于类本身，<strong>所有对象共享一份</strong>，不随对象创建/销毁而改变。</li>
<li><strong>静态成员函数</strong>：不依赖具体对象，只能访问类的静态成员（不能访问 this）。</li>
</ul>
</li>
</ul>
<h2 id="18memcpy-和-strcpy-的区别哪个安全"><a class="markdownIt-Anchor" href="#18memcpy-和-strcpy-的区别哪个安全"></a> 18.memcpy 和 strcpy 的区别，哪个安全？</h2>
<ul>
<li><strong><code>memcpy</code></strong>：按字节拷贝，适合任意类型数据（需指定长度）。</li>
<li><strong><code>strcpy</code></strong>：拷贝字符串，遇到 <code>\0</code> 停止，需保证目标空间足够大。</li>
<li><strong>安全性</strong>：<code>memcpy</code> 更通用更安全；<code>strcpy</code> 可能造成溢出，推荐用 <code>strncpy</code>。</li>
</ul>
<h2 id="19堆和栈的区别"><a class="markdownIt-Anchor" href="#19堆和栈的区别"></a> 19.堆和栈的区别</h2>
<ul>
<li><strong>栈（Stack）</strong>：<strong>系统自动分配/释放</strong>，空间小，效率高。</li>
<li><strong>堆（Heap）</strong>：<strong>自己手动申请/释放</strong>，空间大，效率低。</li>
</ul>
<blockquote>
<p>常见问题：堆使用不当可能导致 <strong>内存泄漏</strong>。</p>
</blockquote>
<h2 id="20malloc-和-new-的区别"><a class="markdownIt-Anchor" href="#20malloc-和-new-的区别"></a> 20.malloc 和 new 的区别</h2>
<ul>
<li><strong>malloc</strong>（C语言库函数）：分配内存，返回 <code>void*</code>，需手动 <code>free</code>。<strong>不会调用构造函数</strong>。</li>
<li><strong>new</strong>（C++ 运算符）：分配内存并调用构造函数，失败抛出异常 <code>bad_alloc</code>，需用 <code>delete</code> 释放。</li>
</ul>
<h2 id="21struct-和-class-的区别"><a class="markdownIt-Anchor" href="#21struct-和-class-的区别"></a> 21.struct 和 class 的区别</h2>
<ul>
<li><strong>在 C++ 中</strong>：
<ul>
<li><code>struct</code> 默认成员权限是 <strong>public</strong>。</li>
<li><code>class</code> 默认成员权限是 <strong>private</strong>。</li>
</ul>
</li>
<li>除此之外，两者在功能上基本相同。</li>
</ul>
<h2 id="22c-类的访问权限"><a class="markdownIt-Anchor" href="#22c-类的访问权限"></a> 22.C++ 类的访问权限</h2>
<ul>
<li><strong>public</strong>：对所有代码可见。</li>
<li><strong>protected</strong>：仅类本身和派生类可见。</li>
<li><strong>private</strong>：仅类本身可见。</li>
</ul>
<h2 id="23内联函数"><a class="markdownIt-Anchor" href="#23内联函数"></a> 23.内联函数</h2>
<ul>
<li>用 <code>inline</code> 修饰，编译时用函数体替换调用处，<strong>减少函数调用开销</strong>。</li>
<li><strong>注意</strong>：
<ul>
<li>仅是建议，编译器可能忽略。</li>
<li>递归、函数过大时不适合。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>弊端</strong>：</p>
<ul>
<li>代码被展开，会导致 <strong>二进制体积增大</strong>（代码膨胀）。</li>
<li>修改后需重新编译所有调用处，<strong>编译依赖增加</strong>。</li>
<li>频繁内联反而可能 <strong>影响指令缓存性能</strong>。</li>
</ul>
</blockquote>
<h2 id="24程序分为几个段"><a class="markdownIt-Anchor" href="#24程序分为几个段"></a> 24.程序分为几个段？</h2>
<p>典型的 C/C++ 程序在内存中分为：</p>
<ul>
<li><strong>代码段（text）</strong>：存放程序代码。</li>
<li><strong>数据段（data）</strong>：存放已初始化的全局变量、静态变量。</li>
<li><strong>BSS 段</strong>：存放未初始化的全局变量、静态变量。</li>
<li><strong>堆（heap）</strong>：动态分配的内存。</li>
<li><strong>共享内存段</strong>：静态变量</li>
<li><strong>栈（stack）</strong>：局部变量、函数参数。</li>
</ul>
<h2 id="25一个-c-文件怎么转换为可执行程序"><a class="markdownIt-Anchor" href="#25一个-c-文件怎么转换为可执行程序"></a> 25.一个 .c 文件怎么转换为可执行程序</h2>
<ol>
<li><strong>预处理</strong>：宏展开、头文件展开，生成 <code>.i</code> 文件。</li>
<li><strong>编译</strong>：把预处理结果转为汇编代码 <code>.s</code>。</li>
<li><strong>汇编</strong>：汇编器将 <code>.s</code> 转为机器码 <code>.o</code>。</li>
<li><strong>链接</strong>：把多个目标文件和库链接成可执行文件。</li>
</ol>
<h2 id="26什么是交叉编译"><a class="markdownIt-Anchor" href="#26什么是交叉编译"></a> 26.什么是交叉编译</h2>
<ul>
<li>在 <strong>一个平台</strong> 上编译生成 <strong>另一个平台</strong> 可运行的程序。</li>
<li>常见于嵌入式开发（如在 PC 上编译 ARM 设备的程序）。</li>
</ul>
<h2 id="27tcp-和-udp-的区别"><a class="markdownIt-Anchor" href="#27tcp-和-udp-的区别"></a> 27.TCP 和 UDP 的区别</h2>
<ul>
<li><strong>TCP</strong>：面向连接，可靠传输，基于字节流的，速度慢。</li>
<li><strong>UDP</strong>：无连接，不可靠传输，速度快。</li>
</ul>
<h2 id="28进程-线程和协程的区别"><a class="markdownIt-Anchor" href="#28进程-线程和协程的区别"></a> 28.进程、线程和协程的区别</h2>
<ul>
<li><strong>进程</strong>：资源分配的最小单位。</li>
<li><strong>线程</strong>：CPU 调度的最小单位，<strong>共享进程资源</strong>。</li>
<li><strong>协程</strong>：用户态的轻量级线程，会主动让出 CPU，切换开销小。</li>
</ul>
<h2 id="29进程间通信方式"><a class="markdownIt-Anchor" href="#29进程间通信方式"></a> 29.进程间通信方式</h2>
<ul>
<li>管道（pipe）</li>
<li>消息队列</li>
<li>共享内存</li>
<li>信号量</li>
<li>信号（signal）</li>
<li>套接字（socket）</li>
</ul>
<h2 id="30线程间通信方式"><a class="markdownIt-Anchor" href="#30线程间通信方式"></a> 30.线程间通信方式</h2>
<ul>
<li><strong>共享内存</strong>（全局变量、堆内存）。</li>
<li><strong>同步机制</strong>：互斥锁、读写锁、信号量、条件变量。</li>
<li><strong>消息队列</strong>（用户实现，通常基于锁或无锁结构）。</li>
</ul>
<h2 id="31进程间的状态"><a class="markdownIt-Anchor" href="#31进程间的状态"></a> 31.进程间的状态</h2>
<ul>
<li><strong>新建（new）</strong>：进程创建中。</li>
<li><strong>就绪（ready）</strong>：等待 CPU 调度。</li>
<li><strong>运行（running）</strong>：占用 CPU 正在执行。</li>
<li><strong>阻塞（waiting）</strong>：等待 I/O 或事件。</li>
<li><strong>结束（terminated）</strong>：执行完成或被终止。</li>
</ul>
<h2 id="32僵尸进程-孤儿进程和守护进程"><a class="markdownIt-Anchor" href="#32僵尸进程-孤儿进程和守护进程"></a> 32.僵尸进程、孤儿进程和守护进程</h2>
<ul>
<li><strong>僵尸进程</strong>：子进程结束但父进程未回收（未调用 <code>wait</code>）。</li>
<li><strong>孤儿进程</strong>：父进程退出，子进程被 <code>init</code>/<code>systemd</code> 接管。</li>
<li><strong>守护进程</strong>：在后台运行、无终端控制的进程。</li>
</ul>
<h2 id="33多进程和多线程的适用场景区别"><a class="markdownIt-Anchor" href="#33多进程和多线程的适用场景区别"></a> 33.多进程和多线程的适用场景区别</h2>
<ul>
<li><strong>多进程</strong>：稳定性好，进程隔离，不易相互影响。适合多核 CPU、大规模并发服务。</li>
<li><strong>多线程</strong>：共享内存，切换开销小。适合计算密集型、轻量级并发。</li>
</ul>
<h2 id="34freertos-中使用的调度算法"><a class="markdownIt-Anchor" href="#34freertos-中使用的调度算法"></a> 34.FreeRTOS 中使用的调度算法</h2>
<ul>
<li>
<p><strong>基于优先级的抢占式调度</strong>。</p>
</li>
<li>
<p>相同优先级下，采用 <strong>时间片轮转</strong>。</p>
</li>
<li>
<p><strong>协作式调度</strong>，任务<strong>不会被强制打断</strong>，只有当任务主动调用、阻塞或结束时，才会切换到其他就绪任务</p>
</li>
</ul>
<h2 id="35freertos-如何实现任务同步"><a class="markdownIt-Anchor" href="#35freertos-如何实现任务同步"></a> 35.FreeRTOS 如何实现任务同步</h2>
<ul>
<li><strong>信号量</strong>：用于任务间同步（包括二值信号量、计数信号量）。</li>
<li><strong>互斥量</strong>：解决资源互斥。</li>
<li><strong>队列</strong>：任务间数据传递。</li>
<li><strong>事件组</strong>：多任务事件同步</li>
</ul>
<h2 id="36freertos-的时间片的大小"><a class="markdownIt-Anchor" href="#36freertos-的时间片的大小"></a> 36.FreeRTOS 的时间片的大小</h2>
<ul>
<li>时间片由 <strong>SysTick 定时器中断周期</strong>决定。</li>
</ul>
<h2 id="37freertos-中任务的状态"><a class="markdownIt-Anchor" href="#37freertos-中任务的状态"></a> 37.FreeRTOS 中任务的状态</h2>
<ul>
<li><strong>就绪态（Ready）</strong></li>
<li><strong>运行态（Running）</strong></li>
<li><strong>阻塞态（Blocked）</strong>（等待事件或超时）</li>
<li><strong>挂起态（Suspended）</strong>（不可被调度，需手动恢复）</li>
<li><strong>终止态（Deleted）</strong></li>
</ul>
<h2 id="38rs232-和-rs485-的区别"><a class="markdownIt-Anchor" href="#38rs232-和-rs485-的区别"></a> 38.RS232 和 RS485 的区别</h2>
<ul>
<li><strong>RS232</strong>：
<ul>
<li>单端信号，<strong>点对点</strong>通信</li>
<li><strong>距离短</strong></li>
<li>抗干扰弱</li>
<li>逻辑“1”≈ −3V ~ −15V，逻辑“0”≈ +3V ~ +15V</li>
</ul>
</li>
<li><strong>RS485</strong>：
<ul>
<li>差分信号，支持多点总线</li>
<li><strong>距离远</strong></li>
<li>抗干扰强</li>
<li>A、B 线电压差 +2V~+6V 表示逻辑 1，−2V~−6V 表示逻辑 0</li>
</ul>
</li>
</ul>
<h2 id="39大小端的概念以及提供一个例子"><a class="markdownIt-Anchor" href="#39大小端的概念以及提供一个例子"></a> 39.大小端的概念，以及提供一个例子</h2>
<ul>
<li>
<p><strong>大端</strong>：高字节存储在低地址。</p>
</li>
<li>
<p><strong>小端</strong>：低字节存储在低地址。</p>
</li>
</ul>
<blockquote>
<p><strong>例子</strong>：<code>int a = 0x12345678;</code>（默认LSB优先）</p>
<ul>
<li>大端存储：<code>12 34 56 78</code></li>
<li>小端存储：<code>78 56 34 12</code></li>
</ul>
</blockquote>
<h2 id="40什么是系统调用"><a class="markdownIt-Anchor" href="#40什么是系统调用"></a> 40.什么是系统调用</h2>
<ul>
<li><strong>用户态进程向内核请求服务</strong>的接口。</li>
<li>通过软中断或陷阱指令进入内核。</li>
</ul>
<h2 id="41http-的发展史"><a class="markdownIt-Anchor" href="#41http-的发展史"></a> 41.HTTP 的发展史</h2>
<ul>
<li><strong>HTTP/1.0</strong>：<strong>短连接</strong>，请求一次建立一次 TCP 连接。</li>
<li><strong>HTTP/1.1</strong>：默认<strong>长连接</strong>，支持流水线。</li>
<li><strong>HTTPS</strong>：HTTP + SSL/TLS，<strong>加密传输</strong>。</li>
<li><strong>HTTP/2.0</strong>：<strong>多路复用</strong>、头部压缩、<strong>二进制帧</strong>，用流的形式发送。</li>
<li><strong>HTTP/3.0</strong>：基于 <strong>QUIC 协议（UDP）</strong>，减少握手延迟。</li>
</ul>
<h2 id="42为什么-i2c-需要开漏输出-上拉电阻"><a class="markdownIt-Anchor" href="#42为什么-i2c-需要开漏输出-上拉电阻"></a> 42.为什么 I2C 需要开漏输出 + 上拉电阻</h2>
<ul>
<li><strong>开漏输出</strong>：只能拉低电平，不能输出高电平。</li>
<li><strong>上拉电阻</strong>：总线空闲时保持高电平，实现线与。</li>
<li><strong>原因</strong>：多个设备共享总线，避免总线冲突。</li>
</ul>
<h2 id="43取消内存对齐的方法了解"><a class="markdownIt-Anchor" href="#43取消内存对齐的方法了解"></a> 43.取消内存对齐的方法（了解）</h2>
<ul>
<li><strong>GCC</strong>：<code>__attribute__((packed))</code></li>
<li><strong>MSVC</strong>：<code>#pragma pack(1)</code></li>
</ul>
<h2 id="44linux-驱动的三大类型"><a class="markdownIt-Anchor" href="#44linux-驱动的三大类型"></a> 44.Linux 驱动的三大类型</h2>
<ul>
<li><strong>字符设备驱动</strong>：顺序访问，按字节流操作，如串口。</li>
<li><strong>块设备驱动</strong>：以数据块为单位，如硬盘。</li>
<li><strong>网络设备驱动</strong>：面向数据包，如网卡。</li>
</ul>
<h2 id="45linux-和-rtos-的区别"><a class="markdownIt-Anchor" href="#45linux-和-rtos-的区别"></a> 45.Linux 和 RTOS 的区别</h2>
<ul>
<li><strong>Linux</strong>：通用操作系统，功能强大，调度非实时。</li>
<li><strong>RTOS</strong>：实时操作系统，保证任务实时性，资源占用小。</li>
</ul>
<h2 id="46什么是回调函数"><a class="markdownIt-Anchor" href="#46什么是回调函数"></a> 46.什么是回调函数</h2>
<ul>
<li>一个<strong>函数作为参数传递</strong>给另一个函数，被在特定时机调用。</li>
<li>常用于 <strong>事件驱动</strong>、<strong>异步处理</strong>。</li>
</ul>
<h2 id="47-select-poll-epoll-的区别与用处"><a class="markdownIt-Anchor" href="#47-select-poll-epoll-的区别与用处"></a> 47. select / poll / epoll 的区别与用处</h2>
<ul>
<li><strong>select</strong>
<ul>
<li>用 <strong>位图</strong> 保存 fd，最大支持数有限（通常 1024）。</li>
<li>每次调用都要 <strong>重新设置 fd 集合</strong>。</li>
<li>内核返回后还需遍历所有 fd，效率低。</li>
<li>适合 <strong>少量连接</strong>、简单场景。</li>
</ul>
</li>
<li><strong>poll</strong>
<ul>
<li>用 <strong>数组（链表形式）</strong> 保存 fd，<strong>没有数量限制</strong>。</li>
<li>每次调用仍需遍历所有 fd，效率依旧不高。</li>
<li>比 select 灵活，但高并发时性能差。</li>
</ul>
</li>
<li><strong>epoll</strong>
<ul>
<li>内核用 <strong>红黑树管理 fd</strong>，就绪 fd 放在 <strong>就绪队列</strong>。</li>
<li>用户只需处理“就绪的 fd”，无需遍历全部。</li>
<li>支持 <strong>LT（水平触发）</strong> 和 <strong>ET（边缘触发）</strong> 两种模式。</li>
<li>在 <strong>大规模并发连接</strong>（如服务器）场景下性能最好。</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>
<p>fd（File Descriptor，文件描述符）： 就是“内核给打开的文件/资源的编号”，程序靠它操作资源。</p>
</li>
<li>
<p>位图（Bitmap）：用一组 <strong>二进制位（bit）</strong> 来表示某些状态或资源是否存在/可用。</p>
</li>
</ul>
</blockquote>
<h2 id="48面向对象的三大特征"><a class="markdownIt-Anchor" href="#48面向对象的三大特征"></a> 48.面向对象的三大特征</h2>
<ul>
<li>
<p><strong>封装</strong></p>
<ul>
<li><strong>概念</strong>：把数据和操作打包在类里，隐藏实现细节，对外只暴露必要接口。</li>
<li><strong>C++ 实现</strong>：<code>class</code> / <code>struct</code> + <strong>访问控制符</strong>（<code>public</code>、<code>protected</code>、<code>private</code>）。</li>
<li><strong>作用</strong>：提高模块化与安全性，防止随意修改内部数据。</li>
</ul>
</li>
<li>
<p><strong>继承</strong></p>
<ul>
<li><strong>概念</strong>：子类自动获得父类已有的成员与方法，可以复用或扩展。</li>
<li><strong>C++ 实现</strong>：<code>class Derived : public Base &#123; ... &#125;;</code></li>
<li><strong>作用</strong>：代码复用，形成层次结构，支持多级继承。</li>
</ul>
</li>
<li>
<p><strong>多态</strong></p>
<ul>
<li>
<p><strong>概念</strong>：同一接口在不同对象上表现出不同的行为。</p>
</li>
<li>
<p><strong>C++ 实现</strong>：</p>
<ul>
<li><strong>编译期多态</strong>：函数重载、运算符重载（通过名字/参数列表区分）。</li>
<li><strong>运行期多态</strong>：虚函数 + 基类指针/引用调用派生类实现（依赖 <code>virtual</code> 关键字 + 动态绑定）。</li>
</ul>
</li>
<li>
<p><strong>作用</strong>：提高灵活性，便于扩展。</p>
</li>
</ul>
</li>
</ul>
<h2 id="49什么是智能指针c-的智能指针有哪些作用又是什么"><a class="markdownIt-Anchor" href="#49什么是智能指针c-的智能指针有哪些作用又是什么"></a> 49.什么是智能指针，C++ 的智能指针有哪些，作用又是什么</h2>
<ul>
<li><strong>作用</strong>：自动管理内存，避免<code>new/delete</code> 手工管理带来的内存泄漏。</li>
<li><strong>C++ 智能指针</strong>：
<ul>
<li><code>std::auto_ptr</code>（C++11 废弃）。</li>
<li><code>std::unique_ptr</code>：独占所有权→ 同一时间<strong>只能有一个指针指向资源</strong>，不能拷贝，只能移动。</li>
<li><code>std::shared_ptr</code>：引用计数共享所有权 → <strong>多个指针可以同时指向资源</strong>，内部用 <strong>引用计数</strong> 管理，最后一个销毁时释放内存。</li>
<li><code>std::weak_ptr</code>：弱引用 → 不增加引用计数，用来观察 <code>shared_ptr</code> 管理的对象，解决循环引用问题。</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>这里的<strong>所有权 (ownership)</strong> 指 <strong>谁负责在对象生命周期结束时释放内存</strong>。</li>
</ul>
</blockquote>
<h2 id="50fork-和-vfork-的区别"><a class="markdownIt-Anchor" href="#50fork-和-vfork-的区别"></a> 50.fork 和 vfork 的区别</h2>
<ul>
<li><strong>fork</strong>：子进程复制父进程地址空间（写时拷贝），<strong>父子进程几乎独立</strong>。</li>
<li><strong>vfork</strong>：子进程与父进程<strong>共享地址空间</strong>，直到执行 <code>exec</code> 或 <code>exit</code>。效率更高，但风险更大。</li>
</ul>
<h2 id="51深拷贝和浅拷贝的区别"><a class="markdownIt-Anchor" href="#51深拷贝和浅拷贝的区别"></a> 51.深拷贝和浅拷贝的区别</h2>
<ul>
<li><strong>浅拷贝</strong>：复制指针，<strong>不复制实际资源</strong> → <strong>多个指针对象指向同一块内存</strong>。</li>
<li><strong>深拷贝</strong>：复制内容，<strong>独立资源</strong> → 避免内存释放冲突。</li>
</ul>
<h2 id="52当-for-循环遇到-fork-函数"><a class="markdownIt-Anchor" href="#52当-for-循环遇到-fork-函数"></a> 52.当 for 循环遇到 fork 函数</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    fork();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>每次 <code>fork</code> 都会创建新进程，最终进程数为 <code>2^3 = 8</code>。</li>
</ul>
<h2 id="53spi-的工作模式有哪些"><a class="markdownIt-Anchor" href="#53spi-的工作模式有哪些"></a> 53.SPI 的工作模式有哪些</h2>
<ul>
<li>
<p>由 <strong>CPOL（时钟极性）</strong> 和 <strong>CPHA（时钟相位）</strong> 决定，共 <strong>4 种模式</strong>：</p>
<p><strong>CPOL（Clock Polarity，时钟极性）</strong></p>
<ul>
<li>=0：时钟空闲时为 <strong>低电平</strong></li>
<li>=1：时钟空闲时为 <strong>高电平</strong></li>
</ul>
<p><strong>CPHA（Clock Phase，相位）</strong></p>
<ul>
<li>=0：<strong>第 1 个边沿采样</strong>（第一个有效边沿采样数据）</li>
<li>=1：<strong>第 2 个边沿采样</strong>（先在第一个边沿切换数据，第二个边沿采样）</li>
</ul>
</li>
<li>
<p>模式 0：CPOL=0, CPHA=0</p>
</li>
<li>
<p>模式 1：CPOL=0, CPHA=1</p>
</li>
<li>
<p>模式 2：CPOL=1, CPHA=0</p>
</li>
<li>
<p>模式 3：CPOL=1, CPHA=1</p>
</li>
</ul>
<h2 id="54用位运算计算余数"><a class="markdownIt-Anchor" href="#54用位运算计算余数"></a> 54.用位运算计算余数</h2>
<ul>
<li><strong>对 2 的幂取余</strong>：<code>x % (2^n) == x &amp; (2^n - 1)</code></li>
</ul>
<blockquote>
<p>例：<code>13 % 8 == 13 &amp; 7 == 5</code>。</p>
</blockquote>
<h2 id="55-什么是虚函数"><a class="markdownIt-Anchor" href="#55-什么是虚函数"></a> 55. 什么是虚函数</h2>
<ul>
<li><strong>定义</strong>：用 <code>virtual</code> 修饰的成员函数；用于<strong>运行时多态</strong>（动态绑定）。</li>
<li><strong>机制（实现惯例）</strong>：每个多态对象含一根 <strong>vptr</strong> 指针指向 <strong>vtable</strong>；通过 vtable 在运行时决定调用哪个函数实现。</li>
</ul>
<h2 id="56gpio-工作模式"><a class="markdownIt-Anchor" href="#56gpio-工作模式"></a> 56.GPIO 工作模式</h2>
<ul>
<li><strong>输入模式</strong>：上拉输入、下拉输入、浮空输入、模拟输入</li>
<li><strong>输出模式</strong>：推挽输出、开漏输出</li>
<li><strong>复用功能</strong>：外设复用（USART、SPI 等）</li>
</ul>
<h2 id="57osi-四层模型-七层模型"><a class="markdownIt-Anchor" href="#57osi-四层模型-七层模型"></a> 57.OSI 四层模型 / 七层模型</h2>
<ul>
<li><strong>四层模型</strong>：应用层、传输层、网络层、网络接口层。</li>
<li><strong>七层模型</strong>：
<ul>
<li>应用层（HTTP、FTP、SMTP）</li>
<li>表示层（加密、压缩）</li>
<li>会话层（建立/管理会话）</li>
<li>传输层（TCP、UDP）</li>
<li>网络层（IP、ICMP）</li>
<li>数据链路层（ARP、PPP、以太网）</li>
<li>物理层（比特传输）</li>
</ul>
</li>
</ul>
<h2 id="58tcp-粘包和拆包问题怎么解决"><a class="markdownIt-Anchor" href="#58tcp-粘包和拆包问题怎么解决"></a> 58.TCP 粘包和拆包问题，怎么解决</h2>
<ul>
<li><strong>原因</strong>：TCP 是字节流协议，不保证消息边界 → 多个包合并或一个包被拆分。</li>
<li><strong>解决方法</strong>：
<ul>
<li>固定长度消息</li>
<li>使用分隔符</li>
<li>在消息头加长度字段</li>
<li>应用层协议处理（如 HTTP、MQTT）</li>
</ul>
</li>
</ul>
<h2 id="59freertos-创建任务的方法和区别"><a class="markdownIt-Anchor" href="#59freertos-创建任务的方法和区别"></a> 59.FreeRTOS 创建任务的方法和区别</h2>
<ul>
<li><strong>xTaskCreate</strong>：普通创建任务。</li>
<li><strong>xTaskCreateStatic</strong>：静态创建，用户提供栈和 TCB。</li>
<li><strong>区别</strong>：静态方式更安全，避免动态内存分配。</li>
</ul>
<h2 id="60-tcp-三次握手连接建立"><a class="markdownIt-Anchor" href="#60-tcp-三次握手连接建立"></a> 60. TCP 三次握手（连接建立）</h2>
<ol>
<li><strong>客户端 → 服务端</strong>：发送 <strong>SYN=1, seq=x</strong>
<ul>
<li>表示请求建立连接，并告知初始序列号 <code>x</code>。</li>
<li>客户端进入 <strong>SYN_SENT</strong> 状态。</li>
</ul>
</li>
<li><strong>服务端 → 客户端</strong>：发送 <strong>SYN=1, ACK=1, seq=y, ack=x+1</strong>
<ul>
<li>确认收到了客户端的 SYN，同时自己也发起连接请求。</li>
<li>服务端进入 <strong>SYN_RCVD</strong> 状态。</li>
</ul>
</li>
<li><strong>客户端 → 服务端</strong>：发送 <strong>ACK=1, ack=y+1</strong>
<ul>
<li>确认收到了服务端的 SYN。</li>
<li>客户端进入 <strong>ESTABLISHED</strong> 状态。</li>
<li>服务端收到 ACK 后，也进入 <strong>ESTABLISHED</strong>。</li>
</ul>
</li>
</ol>
<blockquote>
<p>👉 <strong>为什么三次？</strong></p>
<ul>
<li>防止已失效的连接请求报文突然到达而引起错误（历史 SYN 报文问题）。</li>
<li>双方要确认 <strong>对方的收发能力</strong>。</li>
</ul>
</blockquote>
<hr />
<h2 id="61-tcp-四次挥手连接释放"><a class="markdownIt-Anchor" href="#61-tcp-四次挥手连接释放"></a> 61. TCP 四次挥手（连接释放）</h2>
<ol>
<li><strong>客户端 → 服务端</strong>：发送 <strong>FIN=1, seq=u</strong>
<ul>
<li>表示“客户端已无数据要发”，请求关闭连接。</li>
<li>客户端进入 <strong>FIN_WAIT_1</strong> 状态。</li>
</ul>
</li>
<li><strong>服务端 → 客户端</strong>：发送 <strong>ACK=1, ack=u+1</strong>
<ul>
<li>确认收到了 FIN，但可能还有数据要发。</li>
<li>服务端进入 <strong>CLOSE_WAIT</strong> 状态；客户端进入 <strong>FIN_WAIT_2</strong>。</li>
</ul>
</li>
<li><strong>服务端 → 客户端</strong>：发送 <strong>FIN=1, seq=v</strong>
<ul>
<li>当服务端也没有数据要发时，主动关闭。</li>
<li>服务端进入 <strong>LAST_ACK</strong> 状态。</li>
</ul>
</li>
<li><strong>客户端 → 服务端</strong>：发送 <strong>ACK=1, ack=v+1</strong>
<ul>
<li>确认收到服务端的 FIN。</li>
<li>客户端进入 <strong>TIME_WAIT</strong>，等待 2MSL 确保最后 ACK 不丢失。</li>
<li>服务端收到 ACK 后进入 <strong>CLOSED</strong>，释放连接。</li>
</ul>
</li>
</ol>
<blockquote>
<p>👉 <strong>为什么要四次？</strong></p>
<ul>
<li>TCP 是全双工的，关闭要分成两个方向。</li>
<li>一方发送 FIN 表示“我这边没数据了”，但另一方可能还有数据要发 → 所以 ACK 和 FIN 分开发。</li>
</ul>
</blockquote>
<h2 id="62freertos-的空闲任务以及它的作用"><a class="markdownIt-Anchor" href="#62freertos-的空闲任务以及它的作用"></a> 62.FreeRTOS 的空闲任务以及它的作用</h2>
<ul>
<li><strong>空闲任务 (Idle Task)</strong>：系统启动后自动创建。</li>
<li><strong>作用</strong>：
<ul>
<li>回收已删除任务的资源。</li>
<li>执行用户定义的钩子函数（如省电模式）。</li>
</ul>
</li>
</ul>
<h2 id="63freertos-中的-svc-systick-和-pendsv-的作用和区别"><a class="markdownIt-Anchor" href="#63freertos-中的-svc-systick-和-pendsv-的作用和区别"></a> 63.FreeRTOS 中的 SVC、SysTick 和 PendSV 的作用和区别</h2>
<ul>
<li><strong>SVC (Supervisor Call)</strong>：系统调用，进入内核模式。
<ul>
<li>系统启动时用 <strong>SVC_Handler</strong> 进入第一个任务（第一次上下文切换）。</li>
<li>相当于“进入内核”的入口。</li>
</ul>
</li>
<li><strong>SysTick</strong>：系统定时器中断，触发任务调度，给操作系统提供 <strong>时间基准 (tick)</strong>。
<ul>
<li>周期性触发 <code>SysTick_Handler</code>。</li>
<li>内核更新系统时钟（<code>xTickCount</code>）。</li>
</ul>
</li>
<li><strong>PendSV</strong>：<strong>最低优先级中断</strong>，用于<strong>任务上下文切换</strong>。
<ul>
<li>因优先级最低，确保不会打断其他更重要的中断。</li>
<li>保存当前任务寄存器（上下文），切换栈指针（PSP），恢复下一个任务的上下文。</li>
</ul>
</li>
</ul>
<h2 id="64freertos-为什么要用-pendsv"><a class="markdownIt-Anchor" href="#64freertos-为什么要用-pendsv"></a> 64.FreeRTOS 为什么要用 PendSV</h2>
<ul>
<li>PendSV 可设为最低优先级，确保任务切换不会打断其他中断处理。</li>
<li>这样 <strong>上下文切换延迟最小，效率最高</strong>。</li>
</ul>
<h2 id="65读写锁-自旋锁和互斥锁的区别"><a class="markdownIt-Anchor" href="#65读写锁-自旋锁和互斥锁的区别"></a> 65.读写锁、自旋锁和互斥锁的区别</h2>
<ul>
<li><strong>互斥锁 (mutex)</strong>：独占访问，适合长时间操作。</li>
<li><strong>自旋锁 (spinlock)</strong>：忙等，不释放 CPU，适合临界区很短的情况。</li>
<li><strong>读写锁 (rwlock)</strong>：读共享、写独占，读多写少时效率高。</li>
</ul>
<h2 id="66freertos-中的任务控制块是什么"><a class="markdownIt-Anchor" href="#66freertos-中的任务控制块是什么"></a> 66.FreeRTOS 中的任务控制块是什么</h2>
<ul>
<li><strong>任务控制块 (TCB, Task Control Block)</strong>：保存任务的所有信息。</li>
<li><strong>主要内容</strong>：
<ul>
<li>栈指针</li>
<li>任务优先级</li>
<li>任务状态</li>
<li>延时/阻塞时间</li>
<li>任务名</li>
</ul>
</li>
</ul>
<h2 id="67freertos-如何实现任务切换过程是什么"><a class="markdownIt-Anchor" href="#67freertos-如何实现任务切换过程是什么"></a> 67.FreeRTOS 如何实现任务切换，过程是什么</h2>
<p><strong>触发条件</strong></p>
<ul>
<li>周期性 <strong>SysTick</strong> 中断（时间片/延时到期）。</li>
<li>任务调用阻塞函数（如 <code>vTaskDelay</code>、<code>xQueueReceive</code>）。</li>
<li>高优先级任务进入就绪态。</li>
</ul>
<p><strong>切换机制</strong></p>
<ol>
<li><strong>触发调度请求</strong>：SysTick 或 <code>taskYIELD()</code> 设置 <strong>PendSV</strong> 异常挂起。</li>
<li><strong>保存上下文</strong>：<code>PendSV_Handler</code> 将当前任务的 CPU 寄存器压入其任务栈（PSP）。</li>
<li><strong>调度器决策</strong>：根据优先级选择下一个要运行的任务。</li>
<li><strong>恢复上下文</strong>：从新任务栈中弹出寄存器，恢复执行环境。</li>
<li><strong>返回任务</strong>：CPU 跳转到新任务的断点继续运行。</li>
</ol>
<h2 id="68msp-和-psp-两个指针是什么都在什么时候用"><a class="markdownIt-Anchor" href="#68msp-和-psp-两个指针是什么都在什么时候用"></a> 68.MSP 和 PSP 两个指针是什么，都在什么时候用</h2>
<ul>
<li><strong>MSP (Main Stack Pointer)</strong>：主堆栈指针，复位后默认使用，主要用于中断和异常。</li>
<li><strong>PSP (Process Stack Pointer)</strong>：进程堆栈指针，通常用于线程/任务。</li>
<li><strong>FreeRTOS</strong>：任务使用 PSP，内核/异常使用 MSP。</li>
</ul>
<h2 id="69stm32-上电后到-__main-的过程"><a class="markdownIt-Anchor" href="#69stm32-上电后到-__main-的过程"></a> 69.STM32 上电后到 <code>__main</code> 的过程</h2>
<ol>
<li><strong>硬件复位</strong></li>
</ol>
<ul>
<li>上电/复位后，Cortex-M 内核自动完成：
<ul>
<li>取向量表第 0 项 → <strong>Initial_SP</strong>，装入 MSP。</li>
<li>取向量表第 1 项 → <strong>Reset_Handler</strong> 地址，跳转执行。</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>Reset_Handler</strong>（启动文件 <code>startup_xx.s</code> 中定义）</li>
</ol>
<ul>
<li>设置堆栈指针（MSP）、初始化中断向量表基址。</li>
<li>调用 <strong><code>SystemInit()</code></strong>：
<ul>
<li>配置系统时钟（HSE/PLL 等）。</li>
<li>配置 Flash 访问延时、总线分频。</li>
<li>初始化外设时钟（FPU、Cache、MPU 等）。</li>
</ul>
</li>
</ul>
<blockquote>
<ul>
<li>有的厂商库里叫 <strong><code>HardwareInit()</code> / <code>SystemClock_Config()</code></strong>，作用类似。</li>
</ul>
</blockquote>
<ol start="3">
<li><strong>C 运行时环境初始化</strong></li>
</ol>
<ul>
<li><strong>数据段初始化</strong>：将已初始化全局变量从 Flash 拷贝到 RAM。</li>
<li><strong>BSS 段清零</strong>：未初始化的全局/静态变量置 0。</li>
<li>可能还会初始化堆区指针。</li>
</ul>
<ol start="4">
<li><strong>调用 <code>__main</code></strong>（C 库入口函数）</li>
</ol>
<ul>
<li>进一步完成 C/C++ 环境初始化：
<ul>
<li>运行全局/静态对象的构造函数（C++）。</li>
<li>设置标准库需要的运行环境。</li>
</ul>
</li>
<li>最终调用 <code>main()</code>。</li>
</ul>
<h2 id="70中断能有返回值和参数吗"><a class="markdownIt-Anchor" href="#70中断能有返回值和参数吗"></a> 70.中断能有返回值和参数吗？</h2>
<ul>
<li><strong>不能</strong>：中断服务函数由硬件调用，没有返回值和参数。</li>
<li><strong>传参方法</strong>：使用全局变量、队列、消息通知等方式。</li>
</ul>
<h2 id="71-vector-和-list-的使用场景与区别"><a class="markdownIt-Anchor" href="#71-vector-和-list-的使用场景与区别"></a> 71. vector 和 list 的使用场景与区别</h2>
<ul>
<li><strong>vector</strong>
<ul>
<li>底层实现：<strong>动态数组</strong>，元素<strong>连续</strong>存储。</li>
<li><strong>优势</strong>：支持 <strong>随机访问 O(1)</strong>，缓存友好，遍历效率高。</li>
<li><strong>劣势</strong>：中间插入/删除需要移动大量元素，效率低。</li>
<li><strong>适用场景</strong>：查询、顺序访问多，增删少。</li>
</ul>
</li>
<li><strong>list</strong>
<ul>
<li>底层实现：<strong>双向链表</strong>，元素<strong>分散</strong>存储。</li>
<li><strong>优势</strong>：<strong>插入/删除 O(1)</strong>（已知位置时），不会移动其他元素。</li>
<li><strong>劣势</strong>：不支持随机访问，只能顺序遍历；节点额外指针开销大，缓存不友好。</li>
<li><strong>适用场景</strong>：需要频繁在中间插入、删除。</li>
</ul>
</li>
</ul>
<h2 id="72静态链接和动态链接的区别"><a class="markdownIt-Anchor" href="#72静态链接和动态链接的区别"></a> 72.静态链接和动态链接的区别</h2>
<ul>
<li><strong>静态链接</strong>：<strong>库函数编译时直接打包进可执行文件</strong>。
<ul>
<li>优点：独立运行；</li>
<li>缺点：体积大，更新麻烦。</li>
</ul>
</li>
<li><strong>动态链接</strong>：<strong>运行时加载共享库</strong>。
<ul>
<li>优点：节省空间，易更新；</li>
<li>缺点：依赖库文件。</li>
</ul>
</li>
</ul>
<h2 id="73arm-中的寄存器都有什么用"><a class="markdownIt-Anchor" href="#73arm-中的寄存器都有什么用"></a> 73.ARM 中的寄存器，都有什么用</h2>
<p>以 Cortex-M 为例：</p>
<ul>
<li><strong>通用寄存器 R0–R12</strong>：保存临时数据、参数、返回值。</li>
<li><strong>SP (栈指针)</strong>：MSP/PSP，指向栈顶。</li>
<li><strong>LR (链接寄存器)</strong>：保存函数返回地址。</li>
<li><strong>PC (程序计数器)</strong>：指向下一条指令。</li>
</ul>

      </div>
    </div>
</div>

<div class="post-category">

    <div id="p-meta-i">
        
              
                <a class="hover-with-bg" href="/categories/C%E8%AF%AD%E8%A8%80/">C语言</a>
              
          
          
              
                <a class="hover-with-bg" href="/tags/%E8%AF%AD%E6%B3%95/"># 语法</a>
              
          
    </div>
</div>


<div class="post-footer">
  

</div>

</article>


        </div>
        
<footer class="text-center">
    
    
    
    
    
    <p>&copy;  2022 - 2025&nbsp;&nbsp;本书</p>
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme by <a href="https://github.com/oCoke/hexo-theme-miracle" target="_blank">Miracle</a></p>
    
    
</footer>

<div class="p-btn">
    
        <a class="toc-btn" id="toc-btn"><i id="i-menu"></i></a>
    
    
      <a class="toc-btn" id="share-btn"><i>
        <svg t="1670124379155" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2683" width="25" height="25"><path d="M395.946667 234.666667v64H256v469.333333h512V522.666667h64V768a64 64 0 0 1-64 64H256a64 64 0 0 1-64-64V298.666667a64 64 0 0 1 64-64h139.946667z m335.850666-87.914667l150.848 150.826667-158.378666 158.4-45.269334-45.248L748.394667 341.333333H672c-121.685333 0-220.714667 97.024-223.914667 217.941334L448 565.333333v85.333334h-64v-85.333334C384 406.272 512.938667 277.333333 672 277.333333h99.861333l-85.312-85.333333 45.248-45.248z" p-id="2684" fill="var(--first-text-color)"></path></svg>
      </i></a>
    
    <a href="javascript:window.scrollTo({top:0,behavior:'smooth'});" class="click-btn">
      <i id="i-up"></i>
    </a>
</div>

<!-- SCRIPTS -->






<script>
    document.getElementById("btn-dropdown").addEventListener('click', () => {
      toggleClass("#dropdown-menus","display-inline");
    });
    console.log('\n' + ' %c Powered by Hexo Theme Miracle ' + ' %c https://github.com/oCoke/hexo-theme-miracle ' + '\n' + '\n', 'color: #fff; background: #4F9BFA; padding:5px 0;', 'background: #FFF; padding:5px 0;');

    

    
  /* 小彩蛋: 饮茶先啦 */
  setTimeout(() => {
    var time = new Date();
    if (time.getHours() == 15) {
      let comment = document.createComment(' 三点几嚟！饮茶先啦！ ');
      document.body.insertBefore(comment, document.getElementsByTagName('header')[0]);
    }
  },1);
    
</script>


<script>
    var postImg = document.querySelectorAll("article[class=page] img");
    for (let imgi = 0; imgi < postImg.length; imgi++) {
        postImg[imgi].onclick = () => {
            let zoomImg = document.createElement("div");
            zoomImg.id = "zoomImg";
            zoomImg.innerHTML = `<div id="zoom-picture"></div>
    <div class="poptrox-overlay"
        style="position: fixed; left: 0px; top: 0px; z-index: 20000; width: 100%; height: 100%; text-align: center; cursor: zoom-out; opacity: 1;">
        <div style="display:inline-block;height:100%;vertical-align:middle;"></div>
        <div
            style="position:absolute;left:0;top:0;width:100%;height:100%;background:#000000;opacity:0;filter:alpha(opacity=0);">
        </div>
        <div class="poptrox-popup"
            style="display: inline-block; vertical-align: middle; position: relative; z-index: 1; cursor: zoom-out; min-width: 10px; min-height: 10px; width: auto; height: auto;">
            <div class="loader" style="display: none;"></div>
            <div class="pic" style="text-indent: 0px;"><img
                    src="${ postImg[imgi].srcset || postImg[imgi].src }" alt="Loading..."
                    style="vertical-align: bottom; max-width: 85vw; max-height: 85vh;"></div>
        </div>
    </div>`;
            document.body.appendChild(zoomImg);
                document.querySelector("#zoomImg").onclick = () => {
                    document.querySelector("#zoomImg").remove();
                }
        }
    }
    
</script>




    <script>
        query("#toc-btn")[0].onclick = () => {
            if (query(".post-toc")[0].innerHTML) {
                toggleClass(".post-toc", "display-inline");
            }
        }

        if (!query(".post-toc")[0].innerHTML) {
            addClass("#toc-btn","display-none");
        }
    </script>



    <script>
        query("#share-btn")[0].onclick = async () => {
            let url = `${location.protocol}//${location.hostname}${location.port ? ":"+location.port:location.port}${location.pathname}#read=${sessionStorage.getItem(location.pathname+"_read_y") || ""}`;
            try {
                await navigator.clipboard.writeText(url);
                prompt_core("分享链接已经复制至剪贴板", 4800, true);
            } catch(e) {
                prompt_core("分享链接复制失败，请手动复制<br/>"+url, 4800, false);
            }
        }
    </script>







    <script>
        const getScrollPosition = (el = window) => ({
            x: el.pageXOffset !== undefined ? el.pageXOffset : el.scrollLeft,
            y: el.pageYOffset !== undefined ? el.pageYOffset : el.scrollTop
        });
        // 此处的 750 是「页面元素的最大宽度」
        var wx = document.getElementsByClassName("article-m")[0].clientWidth;
        var wy = document.getElementsByClassName("article-m")[0].clientHeight;
        function windowScroll() {
            // 反复修改 确保页面尺寸不改变
            wx = document.getElementsByClassName("article-m")[0].clientWidth;
            wy = document.getElementsByClassName("article-m")[0].clientHeight;
            let y = Math.round(getScrollPosition().y);
            // console.log(y);
            // 组合字符串，同时记录页面坐标，页面宽度和高度
            let p = `${y}:${wx}:${wy}`;
            // 写入到 sessionStorage 中
            sessionStorage.setItem(location.pathname + "_read_y", p);
        }
        // URL 中是否包含传递的坐标信息
        setTimeout(() => {
            if (location.hash.split("#read=").length > 1) {
                prompt_core("已有阅读进度，正在跳转", 4800, true);
                // 分离字符串
                let read_y = location.hash.split("#read=")[1];
                read_y = read_y.split(":");
                // 组合乘积，顺滑移动至坐标
                window.scrollTo({top: Math.round(Number(read_y[0]) * Number(read_y[1] * Number(read_y[2] / wx / wy))), behavior: "smooth"});
            } else {
                // 从 sessionStorage 中获取
                let read_y = sessionStorage.getItem(location.pathname + "_read_y") || "0:0:0";
                read_y = read_y.split(":");
                if (read_y[0] != "0") prompt_core("已有阅读进度，正在跳转", 4800, true);
                window.scrollTo({top: Math.round(Number(read_y[0]) * Number(read_y[1] * Number(read_y[2] / wx / wy))), behavior: "smooth"});
            }
        }, 500);
        window.onscroll = windowScroll;
    </script>





        </div>
        <div id="css-loading">
            <h3 class="text-center">加载中...</h3>
        </div>
        
    </body>
</html>

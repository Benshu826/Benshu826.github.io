[{"title":"Bootloader学习笔记","date":"2025-05-09T04:31:16.000Z","url":"/2025/05/09/Bootloader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["STM32","/tags/STM32/"]],"categories":[["嵌入式","/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"]],"content":" Bootloader"},{"title":"调试BUG与一些说明","date":"2025-05-08T12:51:32.000Z","url":"/2025/05/08/%E8%B0%83%E8%AF%95BUG%E4%B8%8E%E4%B8%80%E4%BA%9B%E8%AF%B4%E6%98%8E/","tags":[["调试","/tags/%E8%B0%83%E8%AF%95/"]],"categories":[["嵌入式","/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"]],"content":"这里记录了调试过程中遇到的一些调试问题，往往一困就是几天，人麻了。 调试BUG STM32芯片被锁 有一段时间没用STM32芯片，发现ST-LINK读不到，毫无头绪。 解决办法：使用软件STM32 ST-LINK Utility，点击Connect + 按住STM32上芯片复位键才能连接，连接后将程序给清除掉，成功解决。 串口通信出现乱码 编码格式、波特率、主频都可能是问题原因； 如果输入英文和数字都出现问题，那大概率晶振问题，看一下是不是焊错了。 ESP32的新版I2C驱动不了摄像头 这个问题来自于旧I2C不支持新版摄像头驱动，一直报错，ESP IDF 5.4降低到ESP IDF 5.2即可。 更新过驱动，也实现了摄像头，但是配合其他外设也需要修改对应的旧版I2C（液晶屏触摸等），暂不操作。 一些说明 #pragma once，表示本头文件只可以包含一次，相当于 #ifndef #define #endif 为什么编码器要用short来表示16位 STM32平衡车项目中处理编码器的计数使用short； 计算机存的是补码，short字节范围：-32768~ 32767，负数会变成32768 - n 正数的原码 = 反码 = 补码 负数的反码是原码除了符号位其他位取反，补码是反码加1"},{"title":"基于ESP32S3的智能终端系统","date":"2025-02-22T04:10:16.000Z","url":"/2025/02/22/%E5%9F%BA%E4%BA%8EESP32%E7%9A%84%E6%99%BA%E8%83%BD%E7%BB%88%E7%AB%AF%E7%B3%BB%E7%BB%9F/","tags":[["项目","/tags/%E9%A1%B9%E7%9B%AE/"],["ESP32","/tags/ESP32/"],["LVGL","/tags/LVGL/"],["物联网","/tags/%E7%89%A9%E8%81%94%E7%BD%91/"]],"categories":[["项目","/categories/%E9%A1%B9%E7%9B%AE/"]],"content":" 实物"},{"title":"ESP32S3学习笔记","date":"2025-01-12T01:50:36.000Z","url":"/2025/01/12/ESP32S3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["ESP","/tags/ESP/"],["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]],"categories":[["嵌入式","/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"]],"content":"主要学习立创ESP32S3 N16R8的基本配置以及其各部件组成 组成结构 类别 型号 参数 模组 ESP32-S3-WROOM-1-N16R8 搭载 Xtensa® 32 位 LX7 双核处理器，主频高达 240 MHz，内置SRAM 512kB，外置PSRAM 8MB，外置FLASH 16MB，2.4 GHz Wi-Fi (802.11 b/g/n) 40MHz带宽，Bluetooth 5 (LE) 和 Bluetooth Mesh，集成AI向量指令，加速神经网络计算和信号处理 显示屏 ST7789 2.0寸、IPS全视角、分辨率320*240、SPI接口 触摸屏 FT6336 电容触摸、I2C接口 姿态传感器 QMI8658 三轴加速度+三轴陀螺仪、I2C接口 音频DAC ES8311 单通道、I2C接口 音频ADC ES7210 四通道(开发板用三个通道)、I2C接口 音频功放 NS4150B 单声道D类音频放大器 麦克风 ZTS6216 配套双路麦克风、模拟输出 喇叭 DB1811AB50 1811音腔喇叭、1W USB HUB CH334F USB2.0 HUB USB转串口 CH340K 波特率最大2Mbps 电源芯片 SY8088AAC 提供双路、每路1A GH1.25接口 两路外拓传感器接口，可以给外部传感器供电5V和3.3V，可以作为GPIO、CAN、I2C、UART、PWM等接口 TF卡接口 采用1-SD模式与ESP32连接 Type-C接口 用于供电、程序下载、程序调试，以及USB数据通信 按键 一个复位按键、一个用户自定义按键 基础外设 按键Key 样例 姿态传感器（QMI8658） I2C控制，地址QMI8658_SENSOR_ADDR= 0x6A 内部集成 3 轴加速度传感器和 3 轴陀螺仪传感器，支持 SPI 和 I2C 通信 I2C的频率为100000 BSP_I2C_NUM为0 说明 PIN I2C_SCL GPIO_NUM_1 I2C_SDA GPIO_NUM_2 计算倾斜角度 配置qmi8658 求取姿态数值 IO拓展（PAC9557） 外设拓展口，由I2C控制，地址PCA9557_SENSOR_ADDR = 0x19 音频输入（ES7210） AD0接高电平，AD1接低电平，I2C地址为0x41 ES7210 连接 MIC 负责音频输入，ES8311 只负责音频输出 ES7210 可以连接 4 个 MIC，开发板上连接了 3 个 MIC，MIC1 和 MIC2 接收人说话的声音， MIC3 连接了 ES8311 的输出，用于回声消除。 S3芯片会做回声消除，音响在播放声音的时候，可以说话打断它。 这个原理就是 ES8311 输出的信号，不仅给了喇叭，还给了 ES7210 的 MIC3 输入，ESP32 在接收到 MIC1 MIC2 和 MIC3 的声音后，可以分离出 MIC3，从而进行识别。 本部分例程 初始化I2S总线 初始化ES7120芯片 加载SD卡 录制声音 I2S的IO和寄存器配置 标准I2S和TDM_I2S模式 I2S模式 TDM_I2S模式 ES7210工作在I2S模式时，只能采集2个通道，而工作在TDM_I2S模式时，可以采集4个通道 音频输出（ES8311） 主函数包括： i2s_driver_init() 函数初始化 i2s 接口 es8311_codec_init() 函数初始化 i2c 接口并初始化 es8311 芯片 pca9557_init() 函数初始化 IO 扩展芯片 pca9557 pa_en() 函数用于控制音频功放的打开和关闭，IO1引脚 i2s_music() 函数是创建的任务函数，用于播放音乐 液晶显示（ST7789+FT6557） 使用SPI驱动，存储到SPIRAM中 液晶屏显示的开关有两个，一个是 esp_lcd_panel_disp_on_off()，一个是 bsp_display_backlight_on() 区别： esp_lcd_panel_disp_on_off() 用来控制的是液晶屏的驱动芯片 ST7789 中的寄存器，这个寄存器控制液晶屏显示与否。 bsp_display_backlight_on() 用来控制液晶屏 LED 背光，通过调节 PWM 占空比调节亮度，使用的是 LEDC 外设产生的 PWM 信号。 esp_lcd_panel_swap_xy() 函数控制 xy 坐标翻转，第 2 个参数，true 表示翻转，false 表示不翻转。 esp_lcd_panel_mirror() 函数控制 xy 方向是否镜像。第 2 个参数控制 x 方向，第 3 个参数控制 y 方向，true 表示镜像，false 表示不镜像。 实验 IO42 引脚控制液晶屏的背光，低电平亮，如果 IO42 引脚输出 PWM 信号，就可以通过调节占空比，均匀的控制液晶屏的背光亮度 亮度调节函数 摄像头（GC0308） 一般 500W 像素以下的摄像头模块，使用 DVP 接口，以上的使用 MIPI 接口。MIPI 接口速度要高于 DVP 接口。 GC0308 摄像头最大分辨率 640 * 480，30W 像素，工作在 24MHz 频率下，输出 240 *320 分辨率时，可达 30 帧。 实验 PWDN 引脚控制摄像头进入待机模式和工作模式，高电平进入待机模式，低电平进入工作模式 .ledc_channel 和 .ledc_timer中，LEDC 外设用来给某个引脚产生 PWM 信号，这里可以用来产生时钟信号给摄像头的 XCLK 引脚。但是 S3 芯片用不着，因为 S3 芯片的 CAM 外设会产生 XCLK 信号。关于这一点，看 ESP32-S3 的技术参考手册可以了解到。 创建了两个任务，一个任务是摄像头获取画面的任务，一个是液晶屏显示画面的任务。其中，还创建了一个队列信号，摄像头获取到画面，发送队列信号通知 LCD 显示。ESP32S3 是双核处理器，这两个任务，一个定义在 CPU0 上运行，一个定义在 CPU1 上运行，这样可以提高运行速度。xTaskCreatePinnedToCore()函数的最后一个参数，用来定义在哪个 CPU 上运行。 esp_camera_fb_get()函数用来获取一帧摄像头图像，并把获取到的一帧信息返回 LVGL LVGL（Light and Versatile Graphics Library）是一个开源的图形用户界面库，旨在为嵌入式系统提供轻量级、可移植、灵活且易于使用的图形用户界面解决方案 图片和文字 设置图片 借助Image2LCD软件，按照如下图配置 将输出的数组存入.h中，加上static，在主函数调用。 设置文字 待写。。。。。。 配置 基础配置 Flash = 16MB 要存储MP3文件，需要设置FAT文件系统，Default block size = 4096 使用SPI，需要设置SPIRAM，应用外存，Octal（8线SPI） Mode PSRAM，80MHz clock speed 调用摄像头，设置CPU频率为240MHz，还有如下 使用LVGL，需要设置反转颜色，Color settings下的Swap the 2 bytes of…打勾 设置其他字体，Font usage可以开启 Enable Monserrat 24等 yml文件 参考 【下载中心】实战派 | 立创开发板技术文档中心 【ESP32-S3的开发】| 1.初识 ESP32-S3_esp32s3引脚图详细解释-CSDN博客 components · GSM-Weather-project/gsm-weather-esp32s3-esp-idf5.0 - 码云 - 开源中国"},{"title":"FreeRTOS学习笔记","date":"2024-12-20T06:41:12.000Z","url":"/2024/12/20/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["STM32","/tags/STM32/"]],"categories":[["嵌入式","/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"]],"content":"主要学习韦东山FreeRTOS的操作。 FreeRTOS概述与体验 FreeRTOS主要内容 FreeRTOS/Source下的文件 作用 task.c 任务操作 list.c 列表 queue.c 提供队列操作、信号量操作 timer.c 软件定时功能 event_groups.c 通过事件组功能 数据类型 TickType_t： FreeRTOS配置了一个周期性的时钟中断：Tick Interrupt 每发生一次中断，中断次数累加，这被称为tick count tick count这个变量的类型就是TickType_t TickType_t可以是16位的，也可以是32位的 FreeRTOSConfig.h中定义configUSE_16_BIT_TICKS时，TickType_t就是uint16_t 否则TickType_t就是uint32_t BaseType_t： 这是该架构最高效的数据类型 32位架构中，它就是uint32_t 16位架构中，它就是uint16_t 8位架构中，它就是uint8_t BaseType_t通常用作简单的返回值的类型，还有逻辑值，比如pdTRUE/pdFALSE 变量名 变量名前缀 含义 c char s int16_t, short l int32_t, long x BaseType_t，结构体等 u unsigned p 指针 uc uint8_t，unsigned char pc char指针 函数名 函数名前缀 含义 vTaskPrioritySet 返回值类型：void，在task.c中定义 xQueueReceive 返回值类型：BaseType_t，在queue.c中定义 pvTimerGetTimerID 返回值类型：pointer to void，在timer.c中定义 宏名 宏的前缀 在哪个文件定义 port (比如portMAX_DELAY) portable.h或portmacro.h task (比如taskENTER_CRITICAL()) task.h pd (比如pdTRUE) projdefs.h config (比如configUSE_PREEMPTION) FreeRTOSConfig.h err (比如errQUEUE_FULL) projdefs.h 一般的宏定义 宏 值 pdTRUE 1 pdFALSE 0 pdPASS 1 pdFAIL 0 内存管理 堆：heap，由程序员自己malloc一块空间，用完后free标记为&quot;空闲&quot; 栈：stack，函数调用时局部变量保存在栈中，当前程序环境也是保存在栈中。 五种内存管理方法 文件 优点 缺点 heap_1.c 分配简单，时间确定，没有碎片 只分配，不回收 heap_2.c 动态分配，最佳匹配 有碎片、时间不懂 heap_3.c 调用标准库函数 速度慢、时间不定 heap_4.c 相邻的空闲碎片可合并 时间不定 heap_5.c 在heap_4.c基础上支持分隔的内存块 时间不定 FreeRTOS在创建任务时，需要2个内核对象：task control block(TCB)、stack。 heap_1 只实现了pvPortMalloc，并没有实现vPortFree。 如果程序不需要删除内核对象，可以使用它 heap_2 相较于heap_1 Heap_2使用最佳匹配算法(best fit)来分配内存 它支持vPortFree Q：这里的最佳匹配是怎么操作的？ 举例，一个5 10 15内存的空间，此时需要存入一个6大小的数据，那么就存放在10里面，变成5 4 15；后续又需要存放一个4大小的数据，就变成5 0 15。 heap_3 使用标准C库里的malloc、free函数 Q： heap_3线程安全吗? C库里的malloc、free函数并非线程安全的，Heap_3中先暂停FreeRTOS的调度器，再去调用这些函数，使用这种方法实现了线程安全。 heap_4 Heap_4使用首次适应算法(first fit)来分配内存。它还会把相邻的空闲内存合并为一个更大的空闲内存，这有助于较少内存的碎片问题。 Q：这里的首次匹配是怎么操作的？ 举例，一个10 5 3内存的空间，此时需要存入一个6大小的数据，那么就存放在10里面，变成4 5 3；后续又需要存放一个3大小的数据，就变成1 5 3。 heap_5 相比于Heap_4，Heap_5并不局限于管理一个大数组：它可以管理多块、分隔开的内存。 heap相关的函数 pvPortMalloc/vPortFree 作用：分配内存、释放内存。 如果分配内存不成功，则返回值为NULL。 xPortGetFreeHeapSize 作用：当前还有多少空闲内存，heap_3中无法使用。 xPortGetMinimumEverFreeHeapSize 作用：空闲内存容量的最小值。 注意：只有heap_4、heap_5支持此函数 任务管理 任务状态：就绪态、阻塞态、挂起态 任务创建 同时创建两个程序，同优先级下，先执行最后创建的。 多个任务可以使用同一个函数，怎么体现它们的差别？ 栈不同 创建任务时可以传入不同的参数 任务删除 Q：怎么删除任务？ 自杀：vTaskDelete(NULL) 被杀：别的任务执行vTaskDelete(pvTaskCode)，pvTaskCode是自己的句柄 杀人：执行vTaskDelete(pvTaskCode)，pvTaskCode是别的任务的句柄 任务优先级与Tick 高优先级的任务先运行，可选择0 ~ (configMAX_PRIORITIES – 1) FreeRTOS会确保最高优先级的、可运行的任务立马执行 对于相同优先级的可执行任务，轮流执行 对于相同优先级的，通过Tick（滴答）中断实现，但它并不精确。 可以使用uxTaskPriorityGet来获得任务的优先级： 使用vTaskPrioritySet 来设置任务的优先级： 任务状态 Delay函数 vTaskDelay：至少等待指定个数的Tick Interrupt才能变为就绪状态 vTaskDelayUntil：等待到指定的绝对时刻，才能变为就绪态。 空闲任务及其钩子函数 空闲任务(Idle任务)的作用：释放被删除的任务的内存 在使用vTaskStartScheduler() 函数来创建、启动调度器时，这个函数内部会创建空闲任务： 空闲任务优先级为0：它不能阻碍用户任务运行 空闲任务要么处于就绪态，要么处于运行态，永远不会阻塞 如果使用vTaskDelete() 来删除任务，那么你就要确保空闲任务有机会执行，否则就无法释放被删除任务的内存。 可以添加一个空闲任务的钩子函数(Idle Task Hook Functions)，空闲任务的循环每执行一次，就会调用一次钩子函数。 钩子函数作用 执行一些低优先级的、后台的、需要连续执行的函数 测量系统的空闲时间：空闲任务能被执行就意味着所有的高优先级任务都停止了，所以测量空闲任务占据的时间，就可以算出处理器占用率。 让系统进入省电模式：空闲任务能被执行就意味着没有重要的事情要做，当然可以进入省电模式了。 钩子函数限制 不能导致空闲任务进入阻塞状态、暂停状态 如果你会使用vTaskDelete() 来删除任务，那么钩子函数要非常高效地执行。如果空闲任务移植卡在钩子函数里的话，它就无法释放内存。 如何使用钩子函数 FreeRTOS\\Source\\tasks.c中设置configUSE_IDLE_HOOK = 1，实现vApplicationIdleHook函数。 调度算法 配置项 A B C D E configUSE_PREEMPTION 1 1 1 1 0 configUSE_TIME_SLICING 1 1 0 0 x configIDLE_SHOULD_YIELD 1 0 1 0 x 说明 常用 很少用 很少用 很少用 几乎不用 A：可抢占+时间片轮转+空闲任务让步 B：可抢占+时间片轮转+空闲任务不让步 C：可抢占+非时间片轮转+空闲任务让步 D：可抢占+非时间片轮转+空闲任务不让步 E：合作调度 同步互斥与通信 能实现同步、互斥的内核方法有：任务通知(task notification)、队列(queue)、事件组(event group)、信号量(semaphoe)、互斥量(mutex) 队列： 里面可以放任意数据，可以放多个数据 任务、ISR都可以放入数据；任务、ISR都可以从中读出数据 事件组： 一个事件用一bit表示，1表示事件发生了，0表示事件没发生 可以用来表示事件、事件的组合发生了，不能传递数据 有广播效果：事件或事件的组合发生了，等待它的多个任务都会被唤醒 信号量： 核心是&quot;计数值&quot; 任务、ISR释放信号量时让计数值加1 任务、ISR获得信号量时，让计数值减1 任务通知： 核心是任务的TCB里的数值 会被覆盖 发通知给谁？必须指定接收任务 只能由接收任务本身获取该通知 互斥量： 数值只有0或1 谁获得互斥量，就必须由谁释放同一个互斥量 队列 特性 队列可以包含若干个数据：队列中有若干项，这被称为&quot;长度&quot;(length) 创建队列时就要指定长度、数据大小（大小固定） 数据的操作采用先进先出的方法(FIFO，First In First Out)：写数据时放到尾部，读数据时从头部读 也可以强制写队列头部：覆盖头部数据 队列传输数据两种方法： 拷贝：把数据、把变量的值复制进队列 引用：把数据、把变量的地址复制进队列 有多个任务在等待同一个队列的数据。当队列中有数据时，哪个任务会进入就绪态？ 优先级最高的任务 如果大家的优先级相同，那等待时间最久的任务会进入就绪态 队列函数 创建队列 动态分配内存：xQueueCreate，队列的内存在函数内部动态分配 参数 说明 uxQueueLength 队列长度，最多能存放多少个数据(item) uxItemSize 每个数据(item)的大小：以字节为单位 返回值 非0：成功，返回句柄，以后使用句柄来操作队列 NULL：失败，因为内存不足 静态分配内存：xQueueCreateStatic，队列的内存要事先分配好 参数 说明 uxQueueLength 队列长度，最多能存放多少个数据(item) uxItemSize 每个数据(item)的大小：以字节为单位 pucQueueStorageBuffer 如果uxItemSize非0，pucQueueStorageBuffer必须指向一个uint8_t数组， 此数组大小至少为&quot;uxQueueLength * uxItemSize&quot; pxQueueBuffer 必须执行一个StaticQueue_t结构体，用来保存队列的数据结构 返回值 非0：成功，返回句柄，以后使用句柄来操作队列 NULL：失败，因为pxQueueBuffer为NULL 复位 使用过程中可以调用xQueueReset()把队列恢复为初始状态 删除 删除队列的函数为vQueueDelete()，只能删除使用动态方法创建的队列，它会释放内存 写队列 参数 说明 xQueue 队列句柄，要写哪个队列 pvItemToQueue 数据指针，这个数据的值会被复制进队列， 复制多大的数据？在创建队列时已经指定了数据大小 xTicksToWait 如果队列满则无法写入新数据，可以让任务进入阻塞状态， xTicksToWait表示阻塞的最大时间(Tick Count)。 如果被设为0，无法写入数据时函数会立刻返回； 如果被设为portMAX_DELAY，则会一直阻塞直到有空间可写 返回值 pdPASS：数据成功写入了队列 errQUEUE_FULL：写入失败，因为队列满了。 读队列 参数 说明 xQueue 队列句柄，要读哪个队列 pvBuffer bufer指针，队列的数据会被复制到这个buffer 复制多大的数据？在创建队列时已经指定了数据大小 xTicksToWait 果队列空则无法读出数据，可以让任务进入阻塞状态， xTicksToWait表示阻塞的最大时间(Tick Count)。 如果被设为0，无法读出数据时函数会立刻返回； 如果被设为portMAX_DELAY，则会一直阻塞直到有数据可写 返回值 pdPASS：从队列读出数据入 errQUEUE_EMPTY：读取失败，因为队列空了。 查询 可以查询队列中有多少个数据、有多少空余空间 覆盖/偷看 当队列长度为1时，可以使用xQueueOverwrite()或xQueueOverwriteFromISR()来覆盖数据。 如果想让队列中的数据供多方读取，也就是说读取时不要移除数据，那么可以使用&quot;窥视&quot;，也就是xQueuePeek()或xQueuePeekFromISR()。 信息量 特性 信号：起通知作用 量：还可以用来表示资源的数量 当&quot;量&quot;只有0、1两个取值时，它就是&quot;二进制信号量&quot;(Binary Semaphores) 当&quot;量&quot;没有限制时，它就是&quot;计数型信号量&quot;(Counting Semaphores) 支持的动作：&quot;give&quot;给出资源，计数值加1；&quot;take&quot;获得资源，计数值减1 函数 创建 创建二进制信号量： 创建计数型信号量： 删除 动态创建的信号量，不再需要它们时，可以删除它们以回收内存。 give/take 互斥值 特性 FreeRTOS的互斥锁，并没有在代码上实现谁上锁，就只能由谁开锁，只是约定。 互斥量初始值为1 任务A想访问临界资源，先获得并占有互斥量，然后开始访问 任务B也想访问临界资源，也要先获得互斥量：被别人占有了，于是阻塞 任务A使用完毕，释放互斥量；任务B被唤醒、得到并占有互斥量，然后开始访问临界资源 任务B使用完毕，释放互斥量 函数 要想使用互斥量，需要在配置文件FreeRTOSConfig.h中定义： 创建 其他函数 互斥量不能在ISR中使用，ISR需要快速运行，不能阻塞太久。 优先级反转 假设任务A、B都想使用串口，A优先级比B低： 任务A获得了串口的互斥量 任务B也想使用串口，它将会阻塞、等待A释放互斥量 高优先级的任务，被低优先级的任务延迟，这被称为&quot;优先级反转&quot;(priority inversion) 互斥量可以通过&quot;优先级继承&quot;，临时提高有锁且低优先级的程序，可以很大程度**解决&quot;优先级反转&quot;**的问题 递归锁 递归锁实现了：谁上锁就由谁解锁 死锁 假设有2个互斥量M1、M2，2个任务A、B： A获得了互斥量M1 B获得了互斥量M2 A还要获得互斥量M2才能运行，结果A阻塞 B还要获得互斥量M1才能运行，结果B阻塞 A、B都阻塞，再无法释放它们持有的互斥量 死锁发生！ 解决这样问题可以使用递归锁 任务A获得递归锁M后，它还可以多次去获得这个锁 &quot;take&quot;了N次，要&quot;give&quot;N次，这个锁才会被释放 函数 事件组 概念 事件组的每一位表示一个事件 每一位事件的含义由程序员决定，比如：Bit0表示用来串口是否就绪，Bit1表示按键是否被按下 这些位，值为1表示事件发生了，值为0表示事件没发生 一个或多个任务、ISR都可以去写这些位；一个或多个任务、ISR都可以去读这些位 可以等待某一位、某些位中的任意一个，也可以等待多位 事件组用一个整数来表示，高8位留给内核使用，只能用其他的位来表示事件 如果configUSE_16_BIT_TICKS是1，那么这个整数就是16位的，低8位用来表示事件 如果configUSE_16_BIT_TICKS是0，那么这个整数就是32位的，低24位用来表示事件 configUSE_16_BIT_TICKS是用来表示Tick Count的，怎么会影响事件组？这只是基于效率来考虑 如果configUSE_16_BIT_TICKS是1，就表示该处理器使用16位更高效，所以事件组也使用16位 如果configUSE_16_BIT_TICKS是0，就表示该处理器使用32位更高效，所以事件组也使用32位 函数 创建 删除 设置事件 在任务中使用xEventGroupSetBits() 在ISR中使用xEventGroupSetBitsFromISR() xEventGroupSetBitsFromISR函数不是直接去设置事件组，而是给一个FreeRTOS后台任务(daemon task)发送队列数据，由这个任务来设置事件组。 等待事件 使用xEventGroupWaitBits来等待事件，可以等待某一位、某些位中的任意一个，也可以等待多位；等到期望的事件后，还可以清除某些位。 参数 说明 xEventGroup 等待哪个事件组？ uxBitsToWaitFor 等待哪些位？哪些位要被测试？ xWaitForAllBits 怎么测试？是&quot;AND&quot;还是&quot;OR&quot;？ pdTRUE: 等待的位，全部为1; pdFALSE: 等待的位，某一个为1即可 xClearOnExit 函数提出前是否要清除事件？ pdTRUE: 清除uxBitsToWaitFor指定的位 pdFALSE: 不清除 xTicksToWait 如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用pdMS_TO_TICKS()把ms转换为Tick Count 返回值 返回的是事件值， 如果期待的事件发生了，返回的是&quot;非阻塞条件成立&quot;时的事件值； 如果是超时退出，返回的是超时时刻的事件值。 同步点 使用xEventGroupSync()函数可以同步多个任务： 参数 说明 xEventGroup 哪个事件组 uxBitsToSet 要设置哪些事件，已经完成了哪些事件？ 比如0x05(二进制为0101)会导致事件组的bit0,bit2被设置为1 uxBitsToWaitFor 等待那个位、哪些位？ 比如0x15(二级制10101)，表示要等待bit0,bit2,bit4都为1 xTicksToWait 如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用pdMS_TO_TICKS()把ms转换为Tick Count 返回值 返回的是事件值， 如果期待的事件发生了，返回的是&quot;非阻塞条件成立&quot;时的事件值； 如果是超时退出，返回的是超时时刻的事件值。 任务通知 特性 优势 效率更高：使用任务通知来发送事件、数据给某个任务时，效率更高。比队列、信号量、事件组都有大的优势。 更节省内存：使用其他方法时都要先创建对应的结构体，使用任务通知时无需额外创建结构体。 限制 不能发送数据给ISR： ISR并没有任务结构体，所以无法使用任务通知的功能给ISR发送数据。但是ISR可以使用任务通知的功能，发数据给任务。 数据只能给该任务独享： 使用队列、信号量、事件组时，数据保存在这些结构体中，其他任务、ISR都可以访问这些数据。使用任务通知时，数据存放入目标任务中，只有它可以访问这些数据。 在日常工作中，这个限制影响不大。因为很多场合是从多个数据源把数据发给某个任务，而不是把一个数据源的数据发给多个任务。 无法缓冲数据 ：使用队列时，假设队列深度为N，那么它可以保持N个数据。 使用任务通知时，任务结构体中只有一个任务通知值，只能保持一个数据。 无法广播给多个任务 ：使用事件组可以同时给多个任务发送事件。 使用任务通知，只能发个一个任务。 如果发送受阻，发送方无法进入阻塞状态等待： 假设队列已经满了，使用xQueueSendToBack()给队列发送数据时，任务可以进入阻塞状态等待发送完成。 使用任务通知时，即使对方无法接收数据，发送方也无法阻塞等待，只能即刻返回错误。 通知状态和通知值 每个人物都有一个结构体：TCB，里面存在2个成员： 一个是uint8_t类型，用来表示通知状态 一个是uint32_t类型，用来表示通知值 通知状态有3种取值： taskNOT_WAITING_NOTIFICATION：任务没有在等待通知 taskWAITING_NOTIFICATION：任务在等待通知 taskNOTIFICATION_RECEIVED：任务接收到了通知，也被称为pending(有数据了，待处理) 任务通知的使用 使用任务通知，可以实现轻量级的队列(长度为1)、邮箱(覆盖的队列)、计数型信号量、二进制信号量、事件组。 函数 eNotifyAction参数说明： eNotifyAction取值 说明 eNoAction 仅仅是更新通知状态为&quot;pending&quot;，未使用ulValue。 这个选项相当于轻量级的、更高效的二进制信号量。 eSetBits 通知值 = 原来的通知值 | ulValue，按位或。 相当于轻量级的、更高效的事件组。 eIncrement 通知值 = 原来的通知值 + 1，未使用ulValue。 相当于轻量级的、更高效的二进制信号量、计数型信号量。 相当于xTaskNotifyGive()函数。 eSetValueWithoutOverwrite 不覆盖。 如果通知状态为&quot;pending&quot;(表示有数据未读)， 则此次调用xTaskNotify不做任何事，返回pdFAIL。 如果通知状态不是&quot;pending&quot;(表示没有新数据)， 则：通知值 = ulValue。 eSetValueWithOverwrite 覆盖。 无论如何，不管通知状态是否为&quot;pendng&quot;， 通知值 = ulValue。 软件定时器 特性 跟闹钟类似，只响一次/每隔多少时间就自动操作。 两种状态 运行(Running、Active)：运行态的定时器，当指定时间到达之后，它的回调函数会被调用 冬眠(Dormant)：冬眠态的定时器还可以通过句柄来访问它，但是它不再运行，它的回调函数不会被调用 软件定时器的上下文 守护任务 FreeRTOS中有一个Tick中断，软件定时器基于Tick来运行，但不在Tick中断中执行定时器函数，而是在RTOS Damemon Task中执行，即守护任务。 守护任务的优先级：configTIMER_TASK_PRIORITY 定时器命令队列的长度：configTIMER_QUEUE_LENGTH 回调函数 如下是定时器的回调函数原型： 定时器的回调函数是在守护任务中被调用的，守护任务不是专为某个定时器服务的，它还要处理其他定时器。 因此回调任务不能影响其他人： 回调函数要尽快实行，不能进入阻塞状态 不要调用会导致阻塞的API函数，比如vTaskDelay() 可以调用xQueueReceive()之类的函数，但是超时时间要设为0：即刻返回，不可阻塞 函数 创建 回调函数的类型是： 删除 启动/停止 启动定时器就是设置它的状态为运行态(Running、Active)。 停止定时器就是设置它的状态为冬眠(Dormant)，让它不能运行。 创建定时器时，设置了它的周期(period)。xTimerStart()函数是用来启动定时器。假设调用xTimerStart()的时刻是tX，定时器的周期是n，那么在tX+n时刻定时器的回调函数被调用。 如果定时器已经被启动，但是它的函数尚未被执行，再次执行xTimerStart()函数相当于执行xTimerReset()，重新设定它的启动时间。 复位 从定时器的状态转换图可以知道，使用xTimerReset()函数可以让定时器的状态从冬眠态转换为运行态，相当于使用xTimerStart()函数。 如果定时器已经处于运行态，使用xTimerReset()函数就相当于重新确定超时时间。 修改周期 从定时器的状态转换图可以知道，使用xTimerChangePeriod()函数，处理能修改它的周期外，还可以让定时器的状态从冬眠态转换为运行态。 修改定时器的周期时，会使用新的周期重新计算它的超时时间。 定时器ID 可以用来标记定时器，表示自己是什么定时器 可以用来保存参数，给回调函数使用 它的初始值在创建定时器时由xTimerCreate()这类函数传入。 更新ID：使用vTimerSetTimerID()函数 查询ID：查询pvTimerGetTimerID()函数 一般使用配置 要使用定时器，需要做些准备工作： 中断管理 特性 中断流程，ISR要尽量快 保存现场：Task1被打断，需要先保存Task1的运行环境，比如各类寄存器的值 分辨中断、调用处理函数(这个函数就被称为ISR，interrupt service routine) 恢复现场：继续运行Task1，或者运行其他优先级更高的任务 ISR的优先级高于任务：即使是优先级最低的中断，它的优先级也高于任务。任务只有在没有中断的情况下，才能执行。 Q：为什么要引入两套API函数？ 很多API函数会导致任务计入阻塞状态： ISR调用API函数时，ISR不是&quot;任务&quot;，ISR不能进入阻塞状态 所以，在任务中、在ISR中，这些函数的功能是有差别的 两套API函数列表 类型 在任务中 在ISR中 队列(queue) xQueueSendToBack xQueueSendToBackFromISR xQueueSendToFront xQueueSendToFrontFromISR xQueueReceive xQueueReceiveFromISR xQueueOverwrite xQueueOverwriteFromISR xQueuePeek xQueuePeekFromISR 信号量(semaphore) xSemaphoreGive xSemaphoreGiveFromISR xSemaphoreTake xSemaphoreTakeFromISR 事件组(event group) xEventGroupSetBits xEventGroupSetBitsFromISR xEventGroupGetBits xEventGroupGetBitsFromISR 任务通知(task notification) xTaskNotifyGive vTaskNotifyGiveFromISR xTaskNotify xTaskNotifyFromISR 软件定时器(software timer) xTimerStart xTimerStartFromISR xTimerStop xTimerStopFromISR xTimerReset xTimerResetFromISR xTimerChangePeriod xTimerChangePeriodFromISR 怎么切换任务 FreeRTOS的ISR函数中，使用两个宏进行任务切换： 中断与任务间的通信 队列、信号量、互斥量、事件组、任务通知等等方法，都可使用。 要注意的是，在ISR中使用的函数要有&quot;FromISR&quot;后缀。 资源管理 要独占式地访问临界资源，有3种方法： 公平竞争：比如使用互斥量等 谁要跟我抢，我就灭掉谁： 中断要跟我抢？我屏蔽中断 其他任务要跟我抢？我禁止调度器，不运行任务切换 屏蔽中断 任务中使用：taskENTER_CRITICA()/taskEXIT_CRITICAL() ISR中使用：taskENTER_CRITICAL_FROM_ISR()/taskEXIT_CRITICAL_FROM_ISR() 任务中屏蔽中断 在taskENTER_CRITICA()和taskEXIT_CRITICAL()之间： 低优先级的中断被屏蔽了：优先级低于等于configMAX_SYSCALL_INTERRUPT_PRIORITY 高优先级的中断可以产生：优先级高于configMAX_SYSCALL_INTERRUPT_PRIORITY 但是，这些中断ISR里，不允许使用FreeRTOS的API函数 任务调度依赖于中断、依赖于API函数，所以：这两段代码之间，不会有任务调度产生 在ISR中屏蔽中断 在taskENTER_CRITICA_FROM_ISR()和taskEXIT_CRITICAL_FROM_ISR()之间： 低优先级的中断被屏蔽了：优先级低于、等于configMAX_SYSCALL_INTERRUPT_PRIORITY 高优先级的中断可以产生：优先级高于configMAX_SYSCALL_INTERRUPT_PRIORITY 但是，这些中断ISR里，不允许使用FreeRTOS的API函数 任务调度依赖于中断、依赖于API函数，所以：这两段代码之间，不会有任务调度产生 暂停调度器 如果有别的任务来跟你竞争临界资源，可以把中断关掉：这当然可以禁止别的任务运行，但是这代价太大了。它会影响到中断的处理。 示例操作，下面可以递归使用。 调试方法 调试 打印 断言：configASSERT Trace Hook函数(回调函数) 打印 断言 Trace trace宏 描述 traceTASK_INCREMENT_TICK(xTickCount) 当tick计数自增之前此宏函数被调用。参数xTickCount当前的Tick值，它还没有增加。 traceTASK_SWITCHED_OUT() vTaskSwitchContext中，把当前任务切换出去之前调用此宏函数。 traceTASK_SWITCHED_IN() vTaskSwitchContext中，新的任务已经被切换进来了，就调用此函数。 traceBLOCKING_ON_QUEUE_RECEIVE(pxQueue) 当正在执行的当前任务因为试图去读取一个空的队列、信号或者互斥量而进入阻塞状态时，此函数会被立即调用。参数pxQueue保存的是试图读取的目标队列、信号或者互斥量的句柄，传递给此宏函数。 traceBLOCKING_ON_QUEUE_SEND(pxQueue) 当正在执行的当前任务因为试图往一个已经写满的队列或者信号或者互斥量而进入了阻塞状态时，此函数会被立即调用。参数pxQueue保存的是试图写入的目标队列、信号或者互斥量的句柄，传递给此宏函数。 traceQUEUE_SEND(pxQueue) 当一个队列或者信号发送成功时，此宏函数会在内核函数xQueueSend(),xQueueSendToFront(),xQueueSendToBack(),以及所有的信号give函数中被调用，参数pxQueue是要发送的目标队列或信号的句柄，传递给此宏函数。 traceQUEUE_SEND_FAILED(pxQueue) 当一个队列或者信号发送失败时，此宏函数会在内核函数xQueueSend(),xQueueSendToFront(),xQueueSendToBack(),以及所有的信号give函数中被调用，参数pxQueue是要发送的目标队列或信号的句柄，传递给此宏函数。 traceQUEUE_RECEIVE(pxQueue) 当读取一个队列或者接收信号成功时，此宏函数会在内核函数xQueueReceive()以及所有的信号take函数中被调用，参数pxQueue是要接收的目标队列或信号的句柄，传递给此宏函数。 traceQUEUE_RECEIVE_FAILED(pxQueue) 当读取一个队列或者接收信号失败时，此宏函数会在内核函数xQueueReceive()以及所有的信号take函数中被调用，参数pxQueue是要接收的目标队列或信号的句柄，传递给此宏函数。 traceQUEUE_SEND_FROM_ISR(pxQueue) 当在中断中发送一个队列成功时，此函数会在xQueueSendFromISR()中被调用。参数pxQueue是要发送的目标队列的句柄。 traceQUEUE_SEND_FROM_ISR_FAILED(pxQueue) 当在中断中发送一个队列失败时，此函数会在xQueueSendFromISR()中被调用。参数pxQueue是要发送的目标队列的句柄。 traceQUEUE_RECEIVE_FROM_ISR(pxQueue) 当在中断中读取一个队列成功时，此函数会在xQueueReceiveFromISR()中被调用。参数pxQueue是要发送的目标队列的句柄。 traceQUEUE_RECEIVE_FROM_ISR_FAILED(pxQueue) 当在中断中读取一个队列失败时，此函数会在xQueueReceiveFromISR()中被调用。参数pxQueue是要发送的目标队列的句柄。 traceTASK_DELAY_UNTIL() 当一个任务因为调用了vTaskDelayUntil()进入了阻塞状态的前一刻此宏函数会在vTaskDelayUntil()中被立即调用。 traceTASK_DELAY() 当一个任务因为调用了vTaskDelay()进入了阻塞状态的前一刻此宏函数会在vTaskDelay中被立即调用。 Malloc Hook函数 编程时，一般的逻辑错误都容易解决。难以处理的是内存越界、栈溢出等。 内存越界经常发生在堆的使用过程总：堆，就是使用malloc得到的内存。 并没有很好的方法检测内存越界，但是可以提供一些回调函数： 栈溢出Hook函数 在切换任务(vTaskSwitchContext)时调用taskCHECK_FOR_STACK_OVERFLOW来检测栈是否溢出，如果溢出会调用： 怎么判断栈溢出？ 方法1： 当前任务被切换出去之前，它的整个运行现场都被保存在栈里，这时很可能就是它对栈的使用到达了峰值。 这方法很高效，但是并不精确 比如：任务在运行过程中调用了函数A大量地使用了栈，调用完函数A后才被调度。 方法2： 创建任务时，它的栈被填入固定的值，比如：0xa5 检测栈里最后16字节的数据，如果不是0xa5的话表示栈即将、或者已经被用完了 没有方法1快速，但是也足够快 能捕获几乎所有的栈溢出 为什么是几乎所有？可能有些函数使用栈时，非常凑巧地把栈设置为0xa5：几乎不可能 优化 栈使用情况 在创建任务时分配了栈，可以填入固定的数值比如0xa5，以后可以使用以下函数查看&quot;栈的高水位&quot;，也就是还有多少空余的栈空间： 原理：从栈底往栈顶逐个字节地判断，它们的值持续是0xa5就表示它是空闲的。 使用运行时间统计 涉及的宏定义头 函数说明 uxTaskGetSystemState：获得任务的统计信息 参数 描述 pxTaskStatusArray 指向一个TaskStatus_t结构体数组，用来保存任务的统计信息。 有多少个任务？可以用uxTaskGetNumberOfTasks()来获得。 uxArraySize 数组大小、数组项个数，必须大于或等于uxTaskGetNumberOfTasks() pulTotalRunTime 用来保存当前总的运行时间(更快的定时器)，可以传入NULL 返回值 传入的pxTaskStatusArray数组，被设置了几个数组项。 注意：如果传入的uxArraySize小于uxTaskGetNumberOfTasks()，返回值就是0 vTaskList ：获得任务的统计信息，形式为可读的字符串。注意，pcWriteBuffer必须足够大。 vTaskGetRunTimeStats：获得任务的运行信息，形式为可读的字符串。注意，pcWriteBuffer必须足够大。 至此，完结！ 参考 第一章 FreeRTOS概述与体验 | 百问网 百问网《FreeRTOS入门与工程实践-基于STM32F103》教程-基于DShanMCU-103(STM32F103) | 百问网"},{"title":"基于STM32F103的智能平衡车","date":"2024-10-22T03:30:30.000Z","url":"/2024/10/22/%E5%9F%BA%E4%BA%8ESTM32%E7%9A%84%E6%99%BA%E8%83%BD%E5%B9%B3%E8%A1%A1%E8%BD%A6/","tags":[["STM32","/tags/STM32/"],["项目","/tags/%E9%A1%B9%E7%9B%AE/"],["PID","/tags/PID/"]],"categories":[["项目","/categories/%E9%A1%B9%E7%9B%AE/"]],"content":"主要实现基于STM32F103C8T6的HAL库编程PID平衡车项目。 实物 STM32 CubeMX配置 使用外部高速时钟8MHz，通过PLL倍频到72MHz。 RCC----&gt;HSE、LSE = Crystal/Ceramic Resonator（晶振）----&gt;HCLK = 72MHz 点亮LED 名称 IO HAL配置 LED PC13 GPIO_OUTPUT SYS----&gt;Debug = Serial Wire(下载器就是用的SW方式) Keil中：HAL_GPIO_Write(GPIOC, GPIO_PIN_13, GPIO_PIN_SET); OLED 屏的大小为0.96寸，像素点为128*64。 4PIN分别为GND、VCC(3.3V/5V)、SCL(IIC的时钟信号)、SDA(IIC的数据总线)。 名称 IO HAL配置 SDA PB9 I2C1_SCL,OD模式 SCL PB8 I2C1_SDA,OD模式 IIC 硬件IIC：上拉输入，开漏输出。(直接用STM32的真实外设) 软件IIC：上拉输入，推挽/开漏输出。（GPIO实现时序） IIC支持一主多从，同步，半双工，每个从机都有其设备地址。 起始信号：SCL高电平，SDA从高电平跳到低电平 停止信号：SCL高电平，SDA从低电平跳到高电平 ACK信号：SCL高电平，SDA为低（ACK），SDA为高（NACK） 取模软件（PCtoLCD） 设置：“宋体”， 16 * 16，阴码，列行式，逆向，再修改前缀。 MPU6050 MPU6050传感器可以同时检测出三轴加速度、三轴角速度以及温度数据，内部集成DMP（Digital Motion Processor数字运动处理器）模块，可以实现滤波、融合处理。 绕IMU的Z轴旋转：航向角yaw，转动y角度 绕IMU的Y轴旋转：航向角pitch，转动p角度 绕IMU的X轴旋转：航向角row，转动r角度 通过IIC通信 名称 IO HAL配置 SDA PB3 GPIO_OUTPUT SCL PB4 GPIO_OUTPUT INT PB5 GPIO_EXIT5 TIP:不用开漏的原因是MPU6050内部有上拉电阻。 超声波 HC-SR04 超声波测距模块可提供2cm-400cm的非接触式距离感测功能，精度可达到3mm，模块包括超声波发射器、接收器和控制电路。 工作原理 名称 IO HAL配置 TRIG（输入触发，测距） PA3 GPIO_OUTPUT ECHO（传回信号、计算时间差） PA2 GPIO_EXTI2(外部中断2)，TIM3计数 TIP：为什么上升沿和下降沿都中断（上升时开始计时，下降时结束计时）。 Internal_Clock=HCLKPSC+1 Internal\\_Clock=\\frac{HCLK}{PSC + 1} Internal_Clock=PSC+1HCLK​ NVIC----&gt;EXTI line2 interrupt = ENABLE TIM3----&gt;PSC = 71，1MHz = 1us 使用的自动重载器ARR是16位，因此65535us=0.065535s，再乘上340m/s / 2远远超过4m，可用。 电机驱动 TB6612电机 IN1 IN2 直流电机的状态 0 0 制动 0 1 正转 1 0 反转 1 1 制动 PWM 全称Pulse Width Modulation(脉宽调制)；实质是在一个方波中，高电平的占比。 名称 IO HAL配置 PWMA PA11 TIM1_CH4，Pulse = 7200 AIN2 PB12 GPIO_OUTPUT AIN1 PB13 GPIO_OUTPUT BIN1 PB14 GPIO_OUTPUT BIN2 PB15 GPIO_OUTPUT PWMB PA8 TIM1_CH1，Pulse = 7200 PWM的频率f=HCLK(PSC+1)(ARR+1)占空比Duty=PulseARR+1f=10KHz，HCLK=72MHz，则PSC=1,ARR=7199 \\\\ PWM的频率f = \\frac{HCLK}{(PSC + 1)(ARR + 1)}\\\\ \\\\ 占空比Duty=\\frac{Pulse}{ARR + 1}\\\\ \\\\ f=10KHz，HCLK=72MHz，则PSC=1,ARR=7199 \\\\ \\\\ PWM的频率f=(PSC+1)(ARR+1)HCLK​占空比Duty=ARR+1Pulse​f=10KHz，HCLK=72MHz，则PSC=1,ARR=7199 实现函数 编码器 速度通过脉冲波的方式测量，旋转一圈11个脉冲；两个霍尔传感器A相、B相，可以判断旋转方向。 名称 IO HAL配置 编码器1 PA0、PA1 TIM2—Encoder Mode TI1 and TI2 编码器2 PB6、PB7 TIM4—Encoder Mode TI1 and TI2 Encoder Mode TI1只计算A相上升沿 Encoder Mode TI2只计算B相上升沿 Encoder Mode TI1 and TI2上升沿就计算 TIP：编码器不会出现负数，16位----&gt;-32768~32767，需要用short型，正数为n，负数为32767 - n。 蓝牙 使用JDY-31蓝牙模块（从机），通过蓝牙转串口通信。 名称 IO HAL配置 RXD PB10 USART3_TX TXD PB11 USART3_RX USART3设置MODE = Asynchronous，波特率位9600Bits/s，8位，无校验位，停止位1位 USART3 global interrupt = ENABLE PID 原理 本项目使用串级PID，速度环PI+直立环PD。 θ为当前小车的倾角θ′为倾角微分，即角速度e(k)是速度环中目标速度与当前速度的偏差∑e(k)为偏差的积分项。假如速度环输出为θ1，作为目标角度输入直立环，直立环的输出a直接作用于电机，有如下关系式。直立环输出a=kp∗(θ−θ1)+kd∗θ′速度环输出θ1=kp1∗e(k)+ki1∗∑e(k)因此a=kp∗θ+kd∗θ′−kp∗[kp1∗e(k)+ki1∗∑e(k)] \\theta为当前小车的倾角 \\\\ \\theta^{&#x27;}为倾角微分，即角速度 \\\\ e(k)是速度环中目标速度与当前速度的偏差 \\\\ \\sum{e(k)}为偏差的积分项。\\\\ 假如速度环输出为\\theta_1，作为目标角度输入直立环，\\\\ 直立环的输出a直接作用于电机，有如下关系式。\\\\ 直立环输出 a= kp * (\\theta - \\theta_1) + kd *\\theta^{&#x27;} \\\\ 速度环输出\\theta_1 = kp_1 * e(k) + ki_1 * \\sum{e(k)}\\\\ 因此a= kp * \\theta + kd *\\theta^{&#x27;} - kp * [kp_1 * e(k) + ki_1 * \\sum{e(k)}] \\\\ θ为当前小车的倾角θ′为倾角微分，即角速度e(k)是速度环中目标速度与当前速度的偏差∑e(k)为偏差的积分项。假如速度环输出为θ1​，作为目标角度输入直立环，直立环的输出a直接作用于电机，有如下关系式。直立环输出a=kp∗(θ−θ1​)+kd∗θ′速度环输出θ1​=kp1​∗e(k)+ki1​∗∑e(k)因此a=kp∗θ+kd∗θ′−kp∗[kp1​∗e(k)+ki1​∗∑e(k)] 调整P、I、D的效果 调整比例P看什么时候跌倒，主要依靠倾斜角度。 调整微分D看什么时候振荡，若KD过大，则会振荡地严重。其效果就是阻尼，越大越慢。 调整积分I看什么情况下平衡地快，其主要用于消除稳态误差，提高控制精度。 调整PID 1、确定机械中值，通过它来中和计算出的theta，这个需要自己手动测量。 2、调参P、I、D 直立环PD （输入期望角度、真实角度和角速度） 直立环直接调用公式。 首要要看下希望在什么角度让平衡车返回，以此保持平衡，计算出KP的范围（7200 / 30）；通过将KP置0后，得到此时的gyro_x，计算出KD（7200/2000） 确定极性：向前倾斜时，轮子也向前，则为正确极性。 速度环PI （输入期望速度、左编码器、右编码器） 1、计算偏差值：误差值 = （左+右）- 期望速度 2、低通滤波：误差A = (1-a)×偏差值 + a×上一次的偏差值，再更新上一次的偏差值 3、积分：Encoder_S += 误差A （STM32是离散的数字信号，求积分就是求和） 4、限幅Encoder_S 5、速度环套用公式 KP通过公式换算，KI一般为KP/200； 确定极性：向前倾斜时，轮子速度加快，则为正确极性，反之速度升不上去，则为错误极性。 转向环PD （用于转向操作，输入角速度、角度值） 蓝牙控制 通过蓝牙APP发送0x01（上）、0x05（左）、0x03（右）、0x07（下）等数据分别控制方向。 跌倒保护 通过MPU6050的roll值，若其值超过设定的界限，则将PWM设为0。 物体跟随 仅实现直线跟随，方案是借助超声波传回的距离，设置在10-20mm时可以跟随，若超过，则小车保持平衡不动。 其他 TIP1:TIM1-TIM4用完了，如何10ms调用一次呢？答：MPU6050中的INT引脚，修改其采样率为100HZ即可 TIP2:MPU6050会进行自检，若陀螺仪不在水平状态最初状态不为平衡，则不通过，导致其计算结果一直为0，注释掉 PID各种算法 1、位置式PID（本方式实际应用） 优点：静态误差小，溢出的影响小。 缺点：计算量很大，累积误差相对大，在系统出现错误的情况下，容易使系统失控，积分饱和。 使用：一般需要结合输出限幅和积分限幅使用。 2、增量式PID 优点：溢出的影响小，在系统出现错误的情况下,影响相对较小（因为只与过去的三次误差有关）,运算量也相对较小。 缺点：有静态误差（因为没有累积误差）。 3、积分分离式PID 积分分离式PID主要是针对位置式PID的积分，引入判断误差大小条件，是否使用积分项。 4、变速积分PID 积分分离式PID 积分的的权重是1或者0，而变积分PID积分的权重会动态变化。取决于偏差，偏差越大，积分越慢。 5、不完全微分PID 微分通过低通滤波。 6、微分先行 微分的作用是预测未来，能够预知变化，做出调整。其实就是先操作微分。 7、死区 输出了量，但是不执行任何动作，也就是输出的量不起作用。 8、梯形积分 积分有余差，消除不了，为了减少余差，提高运算的精度，便有了梯形积分PID。 查漏补缺 某次面试，HR问我在操作IIC时，MPU6050的地址是多少，给我一下整懵了，平常操作只想着用封装库，反而忘了最基础的东西，结束后就立马去速速学习。 I2C设备的写地址 = I2C设备地址 &lt;&lt; 1 + 0 I2C设备的读地址 = (I2C设备地址 &lt;&lt; 1) + 1 如果AD0脚(9脚)接地,设备地址为0x68 如果接V3.3,则设备地址为0x69 使用0x68套用式子 MPU6050写地址（0110 1000&lt;&lt;1 ） =1101 0000，即0xD0 MPU6050读地址（0110 1000&lt;&lt;1+1） =1101 0001，即0xD1"},{"title":"STM32学习笔记","date":"2024-06-12T06:50:36.000Z","url":"/2024/06/12/STM32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["STM32","/tags/STM32/"]],"categories":[["嵌入式","/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"]],"content":"主要学习了STM32C8T6的基本配置以及其各部件组成。 Q：哈希体系和冯洛伊曼体系区别：前者是指令集和数据存储在不同存储器，后者是存储在同一个存储器 计算机五大组成部分：控制器、运算器、存储器、输入、输出 STM32是小端存储，高地址的数据在低字节上 堆的地址向上，栈的地址向下 32位处理器，一个指针4字节；64位处理器，一个指针8字节 STM32F103C8T6基本配置 内容 STM32最小系统版组成：MCU、时钟电路、复位电路、外部接口电路、电源电路，启动电路。 内核：Cortex-M3，32位处理器内核，最大寻址位2^32=4GB字节； Flash：64K字节； SRAM：20K字节； 2个ADC、4个定时器、2个IIC、2个SPI、3个USART、1个CAN Q：Cotex-M3寄存器组的用法 R0~R12为通用寄存器；R13是主堆栈指针（MSP）和进程堆栈（PSP）；R14是连接寄存器（LR），R15是程序计数器（PC） R0—R3用于传参； R4—R11用于保存局部变量； R12内部暂时调用寄存器； R13栈，别名：SP； R14用于保存函数返回地址，别名：LR； R15用于跳转到下一个执行的命令，别名：PC； Q：STM32F1与F4的区别？ 内核 ：F1是M3，F4是M4 主频：F1最大主频是72MHz，F4最大主频是168MHz 浮点：F1无浮点计算，F4有 功能：F4外设比F1功能更强大 STM32的五个时钟源 内容 HSI是高速内部时钟，RC振荡器，频率8MHz，精度不高 HSE是高速外部时钟，可接石英/陶瓷谐振器，频率4~16MHz LSI是低速内部时钟，RC振荡器，频率40KHz，通过低功耗时钟 LSE是低速外部时钟，石英晶体，频率32.768KHz PLL是锁相环倍频输出，时钟源可以为HSI / 2、HSE、HSE / 2，可倍频2~16倍，最大72MHz Q：设置系统时钟的基本流程？ 打开外部高速时钟，设置Flash等待操作 设置APB1、APB2、AHB分频系数 设置CFGR寄存器确认PLL的时钟来源和倍频系数 使能PLL并将系统时钟切换到PLL STM32启动过程 内容 通过Boot引脚设定，寻找起始地址 初始化栈指针 __initial_sp 指向复位程序 Reset_Handler 设置异常中断 HardFault_Handler 设置系统时钟 SystemInit 调用C的程序 __main GPIO 内容 四种输入：上拉输入、下拉输入、浮空输入、模拟输入 四种输出：通用推挽、复用推挽、通用开漏、复用开漏 APB1总线控制DA、USB、I2C、SPI、CAN、串口2345、普通TIM APB2总线控制AD、串口1、IO、高级TIM2 Q：开漏与推挽的区别？ 推挽可以正常输出高低电平，开漏只能输出低电平，高电平呈现高阻态，需接上拉电阻。 蜂鸣器 内容 有源蜂鸣器：内部自带振荡电路，将正负极接上直流电压即可发声，频率固定。 无源蜂鸣器：内部不带振荡电路，需要控制器提供振荡脉冲发生，频率不固定。 中断 内容 EXIT(Extern Interrupt)：外部中断 NVIC(Nested Vector Interrupt Control)：嵌套向量中断控制器 本质：程序运行时，EXIT监听指定GPIO电平，一旦发生改变，CPU会暂停当前任务并保存现场，向NVIC发出中断请求，去处理中断程序；当中断程序处理完成后，恢复现场，继续执行。 Q：STM32支持多少个外部中断？ 19个外部中断，但只有7个中断服务函数。 Q：中断和异常？ 中断通常由外部硬件设备产生，如IO中断，时钟中断等；异常通常由CPU内部产生，如数组越界，除零操作等。 TIMER 内容 16位计数器、预分频器、自动重装寄存器的时基单元，在72MHz时钟可以实现最大59.65s的定时。 基础定时器：只支持计数 通用/高级定时器：向上计数、向下计数、中央对齐 定时器计数频率：CK_CNT=CLCKPSC+1 定时器计数频率：CK\\_CNT = \\frac{CLCK}{PSC + 1} 定时器计数频率：CK_CNT=PSC+1CLCK​ Q：如何设置一个20ms定时器？ 使用HCLK = 72MHz，预分频系数PSC = 7199，可得CK_CNT = 1KHz = 1ms，只需要计数20次即可。 Q：如何开启定时器？ 开启RCC时钟 选择时基单元的时钟源 配置预分频系数和自动重装载值 配置输出中断控制和NVIC，打开通道 使能定时器 ADC 内容 Analog - Digital Converter：模拟 - 数字转换器 12位逐次逼近型ADC，1us转换时间 输入电压：0 ~ 3.3V，转换范围：0 ~ 4095 AD转换的步骤：采样、保持、量化、编码 Q：STM32 ADC的总转换时间如何计算 T = 采样时间 + 12.5个ADC周期（12个周期量化） Flash 内容 Flash特性：写数据只能将1写成0，不能将0写成1（擦除是0-&gt;1），因此要写新数据，需要先擦除。 每块 每扇页 每页 16扇页 16页 256 Byte 常见的Flash型号（了解即可） 型号 W25Q80 W25Q64 W25Q32 块 16页 32 64 扇区 256 512 1024 页 4096 8192 16384 总字节数 1M Byte 2M Byte 4M Byte 页&lt;扇区&lt;块&lt;芯片 常用的Flash擦写规则 最小擦除：扇区 可选择擦除：块、扇区、全片 最大写入单位：页（不能跨页写入） 最小写入单位：1 Byte 未写入时FLASH全为1，即0xFF 只能1-&gt;0写入，不能0-&gt;1写入，如果写过了，则需要再擦除 Q：NOR Flash和NAND Flash区别？ NOR Flash随机读取，NAND Flash块读取；NOR读得比NAND快，但写和擦除操作慢，容量小，价格贵。 存储器之间对照 SRAM：静态随机存储，不需要定时刷新充电，存储速度快，容量小，掉电失效 DRAM：动态随机存储，需要定时刷新充电，价格比SRAM便宜，但访问速度慢，耗电量大 E2PROM：带电可擦除可编辑只读存储器，断电后仍能保存信息，块擦除 FLASH（ROM）：闪存，存取速度慢，容量大，掉电不失效，扇区擦除 DMA 内容 Direct Memory Access：直接存储器存取 用途：可以提供外设或存储器和存储器之间高速数据传输，无需CPU干预，节省CPU资源 TIP：使用DMA往往需要获取当前剩余数据量，根据设置的接收buffer大小减去当前剩余数据量，得到当前接收数据大小 STM32F103C8T6 DMA资源： DMA1 Q：DMA的传输模式有哪些？ DMA_Mode_Circle 循环模式（GPS、蓝牙） DMA_Mode_Normal 正常缓存模式 通信协议总览 名称 双工 时钟 电平 设备 引脚 UART 全双工 异步 单端 点对点 TX、RX I2C 半双工 同步 单端 多设备 SCL、SDA SPI 全双工 同步 单端 多设备 SCLK、MOSI、MISO、CS CAN 半双工 异步 差分 多设备 CAN_H、CAN_L USB 半双工 异步 差分 点对点 DP、DM UART 内容 串口通信，异步 低位先行：若发送信息0X0F，则传输数据位是1111 0000，最终接收信息0X0F 过程：波特率对齐（比特率=波特率 * log2（N)，N是二进制位数）；起始一个低电平信号表示开始发送数据，接着是8个数据位，然后是校验位（奇/偶/NONE），最后是高电平表示停止位（0.5/1/1.5/2） Q：串口通信如何配置？ 串口时钟使能，GPIO时钟使能 串口复位 TX的GPIO设置为复用推挽，RX的GPIO设置为浮空输入 串口参数初始化（波特率，数据位，校验位，收发模式） 开启中断并初始化NVIC 使能串口 编写串口函数 Q：描述下RS232和RS485的区别？ TTL（全双工）：0V表示0，+3.3V~+5V表示1 RS232（全双工）：+3V ~ +15V表示0，-3V ~ -15V表示1，（TTL通过RS232芯片） RS485（半双工）：两线压差-2V ~ -6V表示0，+2V ~ +6V表示1（TTL通过RS485芯片） I2C 内容 Inter IC BUS（同步、半双工），支持一主多从和多主多从（MSB高位先行） 两根通信线：SCL（Serial Clock）、SDA（Serial Data），上拉电阻一般4.7K~10K STM32支持7/10位地址模式 Q：I2C总线在传输过程中有哪些类型信号？ 开始信号：SCL高电平，SDA由高到低，开始发送数据 结束信号：SCL高电平，SDA由低到高，结束发送数据 应答信号：SCL高电平，发送8Bit数据，接收端向发送端发低电平，表示成功接收（在接收前需要释放SDA） TIP：SDA电平切换只出现在SCL低电平阶段，不要搞混 Q：I2C的软硬件模式怎么配置？ 硬件模式：复用开漏输出，不接上下拉；内部有固定I2C结构；有通信速率设置 软件模式：复用开漏输出，上拉电阻；通过GPIO模拟I2C信号；没有通信速率配置，需要自己写一个delay。 Q：I2C的仲裁机制？ “线与”操作（&amp;&amp;），即低电平优先，谁先发送低电平，谁就对总线占有控制权。 Q：I2C的从机设备地址ID、写地址、读地址？ 特定地址写 当前地址读 SPI 内容 Serial Peripheral Interface：串行外设接口（MSB先行） 四根通信线：SCLK（Serial Clock）、MOSI（Master Output Slave Input）、MISO（Master Input Slave Output）、CS 输入为上拉或浮空输入，输出配置为推挽输出。 起止条件：CS高电平切换到低电平 终止条件：CS低电平切换到高电平 发送信息：CS一直为低电平 Q：四种工作模式 时钟极性CPOL（上升沿/下降沿）；时钟相位CPHA（第一个边沿/第二个边沿） CPOL = 0 ------&gt;上升沿 CPOL = 1 ------&gt; 下降沿 CPHA = 0 ------&gt;第一个边沿 CPHA = 1 ------&gt; 第二个边沿 Q：如何确定使用哪个模式 看从机空闲状态是低电平还是高电平，来确认CPOL；再从从机芯片时序图里确认何时采取数据。 下图解释：在没有进入Cycle时，通过SPICLK是高低电平来判断CPOL；CPHA通过正中间的那个边沿判断。 看门狗 内容 看门狗监控程序运行状态，当程序因为设计漏洞、硬件故障导致出现卡死等问题时，看门狗可以及时复位程序；本质是定时器，在指定范围内，程序没有执行喂狗（重置计数器），看门狗硬件会自动产生复位信号。 独立看门狗（IWDG）：独立工作，对时间精度要求低。 窗口看门狗（WWDG）：能产生系统复位信号和提前唤醒中断。 CAN 内容 CAN总线（Controller Area Network Bus）控制器局域网总线。 一个节点包括3个部分：微处理MCU、CAN控制器、CAN收发器。（CAN_H、CAN_L为双绞线） 开环网络两端必须有2.2KΩ的终端电阻；闭环网络两端必须有120Ω的终端电阻（抗干扰作用）； （信号到终端被电阻吸收，避免反射回干扰下一次信号，所以一般都是放两端） CAN BUS（右边那一块）上的总线电平称为隐形电平和显性电平。 IOS11898标准 名称 性质 逻辑 CAN_H CAN_L 两条线上的电压差 Recessive 隐性 逻辑1 2.5V 2.5V 0 Dominant 显性 逻辑0 3.5V 1.5V 2V 多个节点一起开始发送，会涉及到总线仲裁。 CAN帧的种类 序号 名称 帧用途 1 数据帧 用于发送单元向接收单元传送数据的帧。 2 遥控帧 用于接收单元向具有相同 ID 的发送单元请求数据的帧。 3 错误帧 用于当检测出错误时向其它单元通知错误的帧。 （硬件自动完成） 4 过载帧 当一个节点正忙于处理接收的信息,可以通知其它节点暂缓发送新报文。（硬件自动完成） 5 帧间隔 用于将数据帧及远程帧与前面的帧分离开来的帧（硬件自动完成） 每个节点都可以自己发送帧（帧是CAN协议规定发送或接收的单位） 序号 名称 描述 1 帧起始 表示帧的开始，产生一个bit的显性电平 2 仲裁段 表示帧的优先级， 由标识符（ID）和传送帧类型(RTR)组成 3 控制段 表示数据的字节数，由6个bit构成 4 数据段 数据的具体内容，可发送0～8 个字节的数据 5 CRC段 用于校验传输是否正确 6 ACK段 表示确认是否正常接收（0为应答） 7 帧结束 表示此帧结束 仲裁段：可以根据配置好的设置，自动判断要不要接收报文，该方案也叫作过滤，判断依据是每个报文的ID。 标准格式的标识符长度为11位，拓展格式是29位 RTR位，它来表明是数据帧（0）还是远程帧（1） IDE表明此帧是标准帧（0）还是拓展帧（1）。 控制段：控制段表示数据段的字节数。 保留位（r0、r1），必须全部以显性电平发送，但接收方可以接收显性、隐性的各种组合。 数据长度码（Data Link Control），数据字节必须为0-8字节，但接收方对数据字节数=9~15的情况并不视为错误。 数据段：0-8个字节数据，CAN控制器有对应的寄存器。 位填充机制：当检测到五个连续相同的位信号，实际发送会自动插入一个补码，位填充区域为SOF到CRC结束之间 仲裁方案 在总线空闲时，最先开始发送的节点获得发送权，一旦开始发送，不会被其他节点抢占。 多个节点同时开始发送时，各发送节点从仲裁段的第一位开始进行仲裁。连续输出显性电平最多的节点可继续发送。(从左到右，Dominant ：显性优先) 具有相同ID的数据帧和远程帧在总线上竞争时，仲裁段的最后一位（RTR）为显性位的数据帧具有优先权可继续发送。 标准格式ID与具有相同ID的远程帧或者扩展格式的数据帧在总线上竞争时，标准格式的RTR 位为显性位的具有优先权可继续发送。 CAN过滤器配置 过滤模式：列表模式和掩码模式 列表模式：列出ID名称，判断ID是否一致来判断是否接受或者丢弃，受到列表容量大小限制。 掩码模式：确定ID特定位的值来判断是否接受或丢弃，不受列表容量大小限制。 配置过滤器，有三个重要的寄存器：CAN_FSIR、CAN_FxR1、CAN_FxR2 CAN总线错误分类 CubeMX配置 1、配置波特率 位数据段：同步段----传播段（补偿CAN网络的物理延迟）----相位缓冲段1----相位缓冲段2（补偿相位误差） 可能会有早到的，也可能会有晚到的，通过上面的四段可以进行拉长缩小来操作。 CAN波特率=TQ∗(TBS1+TBS2+SJY)=APB总线频率∗(TBS1+TBS2+SJY)分频系数 CAN波特率=TQ*(TBS1 + TBS2 + SJY) \\\\ \\\\ = \\frac{APB总线频率 * (TBS1 + TBS2 + SJY)}{分频系数} CAN波特率=TQ∗(TBS1+TBS2+SJY)=分频系数APB总线频率∗(TBS1+TBS2+SJY)​ 2、打开CAN的接受中断，两个接收邮箱、三个发送邮箱。"},{"title":"如何做一个这样的网站","date":"2024-01-15T04:30:30.000Z","url":"/2024/01/15/%E5%A6%82%E4%BD%95%E5%81%9A%E4%B8%80%E4%B8%AA%E8%BF%99%E6%A0%B7%E7%9A%84%E7%BD%91%E7%AB%99/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["hexo","/tags/hexo/"]],"categories":[["网页","/categories/%E7%BD%91%E9%A1%B5/"]],"content":" 这个人太懒了，根本就妹写正文呀！还是来看看可爱猫猫吧！ 学习参考 搭建1：hexo史上最全搭建教程-CSDN博客 搭建2：使用Hexo在GitHub Pages上搭建部署免费的个人博客网站（下：Hexo部署）——最详细全面解读教程（没有之一） - 简书 hexo主题：Themes | Hexo 处理公式问题：Hexo折腾系列（六）数学公式渲染优化 - 江风引雨の小po站 图床工具参考1：Home - SM.MS | Dashboard 图床工具参考2：【Typora】github-与PicGO搭建图床-CSDN博客 添加音乐：3-hexo 添加音乐插件 | 叶落阁 表格未居中问题暂未解决，CSS美化？ 关于上传hexo d出现err: Error: Spawn failed报错问题 打开博客目录内的_config.yml配置文件，将自己的github的https仓库地址修改为自己github的SSH地址"},{"title":"Markdown基础用法","date":"2023-04-12T03:40:30.000Z","url":"/2023/04/12/Markdown%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]],"categories":[["Markdown","/categories/Markdown/"]],"content":" Markdown基础用法 官网网址： 可以下载排字模板和编辑主题。 使用Typora，通过Ctrl+/即可进入Markdown源代码编辑模式。 标题 #+空格+标题名称-----------一级标题 ##+空格+标题名称---------二级标题 ###+空格+标题名称--------三级标题 ####+空格+标题名称------四级标题 #####+空格+标题名称------五级标题 ######+空格+标题名称-----六级标题 最大支持六级标题 字体 对于标准的markdown文本是不支持居中对齐的。不过markdown同时兼容HTML，可以通过HTML语法格式书写来让文本居中对齐。 引用 ‘&gt;’+加空格+文字 分割线 1.三个*然后回车 2.三个-（减号）回车 插入图片 ①本地的图片：英文的！+[图片名称]+（路径） ②网络图：英文的！+[图片名称]+（网络图片地址） 比如： 链接 [点击跳转到+名称]（网站、文件等地址） 比如：我的博客 列表 ①有序列表；序号（1，①）+英文的句号（.）+输入得内容，然后回车自动补出下一个序号 ②无序列表；减号（-）+空格+输入内容 回车自动补出下一个 表格 右击创建表格 代码 Tab键上面的点（·）三个 + 代码类型（java c++ c#等）然后回车 数学公式 ∑i=0ni2=(n2+n)(2n+1)6 \\sum_{i=0}^n i^2 = \\frac{(n^2+n)(2n+1)}{6} i=0∑n​i2=6(n2+n)(2n+1)​ LaTeX公式格式 Markdown快捷键 撤销：Ctrl/Command + Z 重做：Ctrl/Command + Y 加粗：Ctrl/Command + B 斜体：Ctrl/Command + I 标题：Ctrl/Command + Shift + H 无序列表：Ctrl/Command + Shift + U 有序列表：Ctrl/Command + Shift + O 检查列表：Ctrl/Command + Shift + C 插入代码：Ctrl/Command + Shift + K 插入链接：Ctrl/Command + Shift + L 插入图片：Ctrl/Command + Shift + G 查找：Ctrl/Command + F mand + Shift + L 插入图片：Ctrl/Command + Shift + G 查找：Ctrl/Command + F 替换：Ctrl/Command + G"},{"title":"使用新域名后不加载主题","date":"2022-05-15T03:30:30.000Z","url":"/2022/05/15/%E4%BD%BF%E7%94%A8%E6%96%B0%E5%9F%9F%E5%90%8D%E5%90%8E%E4%B8%8D%E5%8A%A0%E8%BD%BD%E4%B8%BB%E9%A2%98/","tags":[["学习","/tags/%E5%AD%A6%E4%B9%A0/"],["hexo","/tags/hexo/"]],"categories":[["网页","/categories/%E7%BD%91%E9%A1%B5/"]],"content":" 心路历程 看了一圈CSDN，基本上都是抄抄改改，只有几个还有点负责心，但依然没有解决我的问题，差点就放弃了，不过好在通过试错给试出来了。 解决方法 使用了新域名后，发现网页的CSS和JS都没用了，但本地静态可以正常运行。这个时候需要修改个人博客底下的_config.yml文件，先找到这个地方： 将url改为githubname.github.io，不要出现下一层仓库名。 说明：CSDN上别人的解决方法不适用，是因为我们这个没有单独给出root，切记切记。"},{"title":"蓝桥杯第十二届心得","date":"2022-04-28T10:51:32.000Z","url":"/2022/04/28/%E8%93%9D%E6%A1%A5%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%B1%8A%E5%8D%95%E7%89%87%E6%9C%BA%E5%BF%83%E5%BE%97/","tags":[["比赛","/tags/%E6%AF%94%E8%B5%9B/"]],"categories":[["嵌入式","/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"]],"content":" 感悟 今年的蓝桥杯单片机难吗，不是很难，但注重细心。一分付出，一分收获。今年我有幸参加了第十二届的比赛，但因为自己操作不当，优化代码的过程中删了定时器，没在主函数删了调用函数，导致已经完成的大厦轰然倒塌。自己也很难受，但没办法，希望看到文章的你们不要犯这种低级问题。 Emmmm…，不过后来拿了省一，挺意外的。 新手上路 基础部分的内容，推荐大家去看小蜜蜂老师的视频，讲的很好，网址: . 学习思路 以下是我的学习思路 首先：先学会LED、蜂鸣器、继电器、按键、数码管、数码管位选、串口等基本操作。 其次：ds1302，ds18b20，eeprom(24C02)，PCF8591等。 然后：PWM呼吸灯，DA(因为我刚开始一直没找到)、超声波。 最关键的是一定要做省赛题！实操很重要！ 赛题链接： . 提取码：1234 一些需要注意的点！！ LED 首先要说的是LED灯，比如第10届省赛题目中，如果单独点亮LED，会出现原先没有定义的灯跟着一起亮，我的解决方法如下 延迟delay 本来不想单独拿出来讲的，实在是初学者这里出问题的太多了。 按键消抖 有时候题目会让你只加1，但你按了按键会出现加的好多，这里推荐一种解决方法 矩阵按键 我参考的B站一位UP主，写的很好，这里用的是reg52 DS13B20 关于ds13b20读取温度，onewire里面的延迟都要增大10-12倍。特别注意的就是，蜜蜂老师那的temp是16位的，LSB、MSB是8位的，还有就是老师那的delay(700)是unsigned int的而不是unsigned char，要特别注意一下。两位小数的读法我建议大家去找找相关内容看看，以免考到。 IIC IIC这一块除了DA输出，其他没啥可说的，DA输出参考代码如下(只需要这样然后主函数调用就行，接着你去拿万用表测J3的D/A与GND两个位置就可以得到差不多的数值)： 还有一个点就是应答和非应答。 PWM 有些小伙伴可能学了很久都没搞懂PWM是怎么搞的，我举个例子。 首先我们要的是小灯缓慢亮0.5s，缓慢灭0.5s，先定义一个100us的定时器，先经过count走了10次后，time++了，五次后也就是count加了50次(换算也就是50ms)，然后led灯会变一次pwm_duty，也就是小灯的亮度，总共要变10次，也就是0.5s，达到效果。 IO和MM模式 省赛我还没看到要求用MM模式的，大多数都是要求IO模式，最好都学一下，MM模式比IO模式多用一个absacc.h的头文件。 结尾 希望看到这篇文章的你，不会和我刚考完一样，感觉自己的付出和回报不成正比，自己的心态很受打击。当我知道没删那个的时候，我当时人直接懵了，手机也摔地上碎屏了，自己付出了很多，和老师与陪自己一起走过来经常交流的赛友们学到了很多，但最后因为一个很小的问题导致这样，自己真的完全接受不了。不过人生总有得有失吧，唉，大家国赛加油！ 最后记得根据题目意思交压缩包，而不是只交了一份hex文件！！！ 最后，青山不改，碧水长流"}]
[{"title":"常见八股问题","date":"2025-08-31T12:51:32.000Z","url":"/2025/08/31/%E5%B8%B8%E8%A7%81%E5%85%AB%E8%82%A1%E9%97%AE%E9%A2%98/","tags":[["语法","/tags/%E8%AF%AD%E6%B3%95/"]],"categories":[["C语言","/categories/C%E8%AF%AD%E8%A8%80/"],["STM32","/categories/C%E8%AF%AD%E8%A8%80/STM32/"],["FreeRTOS","/categories/C%E8%AF%AD%E8%A8%80/STM32/FreeRTOS/"],["Linux","/categories/C%E8%AF%AD%E8%A8%80/STM32/FreeRTOS/Linux/"],["计算机网络","/categories/C%E8%AF%AD%E8%A8%80/STM32/FreeRTOS/Linux/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"],["操作系统","/categories/C%E8%AF%AD%E8%A8%80/STM32/FreeRTOS/Linux/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"]],"content":" C/C++ 运算符优先级 自上而下，优先级降低 括号 ()、数组 []、结构体成员 .、指针成员 -&gt;。 单目：++、--、!、~、取地址 &amp;、解引用 *、类型转换 (type)。 算术：乘除 % &gt; 加减 &gt; 移位。 比较：先大小，再相等。 位运算：&amp; &gt; ^ &gt; |。 逻辑运算：&amp;&amp; &gt; ||。 条件/赋值：?: &gt; =。 最后：逗号 ,。 原码、反码、补码转换 正数：原码 = 反码 = 补码。 负数：补码 = 反码 + 1。 Q：计算机计算为什么使用补码？ A：加减运算可以统一为加法，硬件实现简单。 Volatile 作用：告诉编译器变量的值 随时可能发生变化，不要对其进行优化。（预处理操作） 典型场景： 多线程/中断共享变量（值可能被中断/其他线程修改）。 硬件寄存器（如单片机的 IO、外设状态寄存器）。 内存映射设备（读写必须严格执行，不能省略）。 volatile 不能保证 原子性，需要配合 锁/关中断 保护临界区 指针的大小 32 位平台：指针大小通常 4 字节。 64 位平台：指针大小通常 8 字节。 不管 int*、char*、double*，指针大小都一样。 1Byte = 8 Bit 指针只能相减，不能相加（通常会越界） C/C++ 基本数据类型大小 32 位 类型 大小 (字节) 说明 char 1 最小存储单元 short 2 至少 16 位 int 4 通常 32 位 long 4 和 int 一样大 long long 8 至少 64 位 float 4 IEEE 754 单精度 double 8 IEEE 754 双精度 long double 12 或 16 依平台而定（常见 12B 或 16B 对齐到 16） 指针 4 存放地址，32 位宽度 64位 类型 大小 (字节) 说明 char 1 依旧是 1 字节 short 2 至少 16 位 int 4 32 位 long 8 注意：比 32 位多一倍 long long 8 至少 64 位 float 4 单精度 double 8 双精度 long double 16 常见实现是 16B（对齐到 16） 指针 8 存放地址，64 位宽度 数组名num和&amp;num的区别 一维数组 num+1 是偏移到下个元素 &amp;num+1是偏移整个数组 二维数组 num+1 是偏移一个一维数组 &amp;num+1是整个数组 int num[6]; num，类型int*，即首元素的指针 &amp;num，类型int (*)[6]，即整个数组地址 *num，等价于a[0] —&gt; *(a+i) = a[i] Q1：int a[6] = {1, 2, 3, 4, 5, 6};printf(“%d\\n”, *(int *)(&amp;a + 1) - 1)的输出 A：(&amp;a + 1)是a + 6， 这里的*(int *)没什么意义,*((int *)(&amp;a + 1) - 1)是a + 5，即6。 Q2：char *buff[] = {“char”, “int”, “double”}; printf(“%c\\n”, *(buff+1)[1])的输出 A：(buff+1)是&quot;int&quot;，[]的优先级大于*，所以*(buff+1)[1]=*(buff+1+1)=*(buff+2)，取&quot;double&quot;的首元素&quot;d&quot;。 Q3：如何不使用sizeof求数据类型字节的大小 #define mysizeof(value) (char*)(&amp;value+1) - (char*)(&amp;value) 什么时候用 . ，什么时候用-&gt; .（点运算符） 作用于 对象/结构体变量 本身。 -&gt;（箭头运算符） 作用于 指向结构体/对象的指针，相当于 (*p).member。 变量 → . 指针 → -&gt; 指针数组和数组指针 指针数组： int *arr[10]; 数组里的每个元素都是一个指针，arr是数组名，arr[i]是一个指针。 数组指针： int (*p)[10]; 一个指针，指向整个数组 指针函数和函数指针 指针函数：int* func(); 函数的返回值是指针。 函数指针： 指向函数的指针变量 常量指针和指针常量 常量指针：const int *a; / int const *a; 底层Const，指针所指内容是常量，不能通过指针修改（但指针可以指向别处） 指针常量：int *const a; 顶层Const，指针本身是常量，初始化后不能再指向别的地址。 野指针和悬空指针 野指针：未初始化或指向不可知区域的指针。 悬空指针：指向的内存已释放/失效，但没有置NULL，仍被使用。 避免方法：指针初始化为 NULL；释放后及时置为 NULL。 Free释放内存后，指针还能用吗 不能直接使用：free 只释放内存，不会清空指针，继续访问会造成 悬空指针 但如果非要使用，也是可以的，不过数据可能是垃圾值 引用是什么，有了指针为什么还需要引用 引用：变量的别名，和原变量共享同一块内存。 初始化后不能更换绑定，不会重新分配内存。 安全：引用必须初始化，不能为 NULL。 简洁：用法像普通变量，不需 *、-&gt;。 清晰：函数传参时避免拷贝。 数组和链表的区别 数组：连续内存，存储的是同一类型数据，支持随机访问，插入/删除效率低。 链表：离散内存，插入/删除效率高，查找效率低。 使用场景：查询多 → 数组；插入删除多 → 链表。 “#include &quot;&quot; 和 #include &lt;&gt; 区别 #include &quot;&quot;：先从当前目录查找，再去系统目录查找。 #include &lt;&gt;：只从系统目录查找。 #ifndef #define #endif的作用 防止头文件被重复包含（“头文件保护”），用来避免重复定义、编译错误。 #program once 和它功能一样 strlen和sizeof的区别 strlen(s)：计算 字符串内容长度（遇到 \\0 停止，不含 \\0），需在运行时遍历。 sizeof(x)：计算 对象/类型所占内存字节数，在编译期确定（数组包含 \\0，会计算\\0的空间）。 区别：strlen 得到“内容长度”，sizeof 得到“占用空间”。 计算x[]数组中元素个数：sizeof(x) / sizeof(x[0]) gets和scanf函数的区别 输入内容 gets(char *s)：读取一行输入，直到遇到换行符（\\n），换行符会被丢弃。 scanf(&quot;%s&quot;, s)：读取一个字符串，遇到空格、Tab 或换行符就结束。 安全性 gets：不安全，不检查缓冲区大小，容易造成缓冲区溢出（C11 标准已废弃）。 scanf(&quot;%s&quot;, ...)：同样可能溢出，但可以通过指定最大宽度控制： C语言内存分配的方式 静态存储区：全局变量、静态变量，程序运行期间始终存在。 栈（Stack）：局部变量、函数参数，由编译器自动分配/释放。 堆（Heap）：动态内存（malloc/free、calloc、realloc），由程序员手动管理 struct 和 class 的区别 在 C++ 中： 访问权限 struct：默认成员是 public。 class：默认成员是 private。 继承方式 struct：默认是 public 继承。 class：默认是 private 继承。 除此之外，两者在功能上基本相同。 Q：C和C++里的struct有什么区别呢？ 访问权限 C：没有访问控制关键字（全部公开）。 C++：默认 public，可以使用 public / private / protected。 定义函数 C：不能包含成员函数。 C++：可以包含 成员函数、构造函数、析构函数、运算符重载。 继承 C：不支持继承。 C++：支持继承（默认是 public 继承）。 定义变量 C：定义变量必须写 struct 关键字（除非用 typedef）。 C++：不需要写 struct，和 class 一样用法。 结构体和联合体的区别 结构体 (struct)：成员 独立存储，总大小 ≥ 成员之和，内存对齐最大类型。 联合体 (union)：所有成员 共用同一块内存，大小 = 最大成员大小，整体大小也需按 最大成员的对齐要求 对齐。 Q1：下面这个的输出是多少？ A：结果是12 Byte，char类型对齐int类型的大小 Q2：如何用联合体来判断大小端？ 宏函数注意点 宏函数通过 #define 定义，预处理阶段替换，无类型检查。 缺点：可能重复计算参数，调试困难。 改进：参数和表达式用括号保护，推荐使用 内联函数 替代。 全局变量和局部变量的区别 全局变量：定义在函数外，作用域是整个文件或程序，存储在静态区。 局部变量：定义在函数/代码块内，存储在栈，作用域仅在定义范围内。 #define、typedef、const 的区别 #define：预处理指令，无类型检查。 typedef：给类型取别名，有类型检查。 const：定义常量，编译器检查类型，分配内存。 建议：常量用 const，类型别名用 typedef/using，少用 #define 特别说明： #define myptr int* p //a 是 int * a, b 是 int b myptr a,b; typedef int* myptr; //a 是 int * a, b 是 int b* myptr a,b; static 的作用 static修饰的参数若不赋值，则默认初始化为0。 在 C 中 局部静态变量：存放在静态存储区，函数退出后仍然存在，下次调用保留上次的值（有记忆的，只会被初始化一次）。 全局静态变量：存放在静态存储区，作用域仅限当前文件，避免与其他文件的全局变量冲突。 静态函数：作用域仅限当前文件，避免外部访问。 在 C++ 中 静态成员变量：属于类本身，所有对象共享同一份，不随对象的创建和销毁而改变。 静态成员函数：不依赖对象调用，只能访问类的静态成员，不能访问 this 指针。 register的作用 作用：提示编译器把变量尽量存放在 CPU 寄存器 中，并且是整数。 特点： 属于 存储类说明符。 只是“建议”，编译器可忽略。 register 变量可能没有内存地址，因此 不能对其使用取地址运算符 &amp;。 memcpy 和 strcpy 的区别，哪个安全 memcpy：按字节拷贝，适合任意类型数据（需指定长度）。 strcpy：拷贝字符串，遇到 \\0 停止，需保证目标空间足够大。 安全性：memcpy 更通用更安全；strcpy 可能造成溢出，推荐用 strncpy。 堆和栈的区别 栈（Stack）：系统自动分配/释放，空间小，效率高，向低地址扩张。 堆（Heap）：自己手动申请/释放，空间大，效率低，向高地址扩张。 常见问题：堆使用不当可能导致 内存泄漏。 malloc实现原理 内存申请方式： 小块内存（&lt; 128K）：通过 brk() 扩展堆顶指针。 大块内存（≥ 128K）：通过 mmap() 直接向内核申请独立内存区域。 内存池管理： malloc 会向系统申请一大块内存作为 堆区，再划分为多个小块。 用户申请时，从堆区挑选合适的空闲块返回，而不是每次都调用系统接口。 空闲块组织： 使用 隐式链表 管理空闲块。 每个空闲块会记录自身大小和指向下一块的指针。 分配时可能会 分割 空闲块；释放时可能会 合并 相邻块，减少碎片。 malloc 采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将 堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链 表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址 malloc 和 new 的区别 malloc（C语言库函数）：需要手动计算内存大小，返回 void*，需手动 free。不会调用构造函数。 new（C++ 运算符）：类型安全，分配内存并调用构造函数，失败抛出异常，需用 delete 释放，返回具体类型指针。 malloc、calloc、realloc 内存申请函数 malloc(size) 分配指定字节大小的内存，内容不初始化（可能是垃圾值）。 calloc(n, size) 分配 n * size 字节，并全部置零。 realloc(ptr, size) 调整已分配内存大小：扩容或缩小，可能搬移到新地址。 被free回收的内存是立即返还给操作系统吗 不会，而是交给C的堆分配器。 内存分配器机制（以 ptmalloc 为例） 内部维护多个 空闲链表（bins）。 使用 双向链表管理空闲块。 支持 相邻空闲块合并，减少碎片。 小块用 sbrk() 分配，大块可能用 mmap()。 void*类型指针的作用 void* 是 C/C++ 中的通用指针类型，可指向任意数据类型的内存地址。其核心价值在于实现泛型编程，例如： 内存管理函数（如 malloc、calloc）返回 void*，让调用者决定如何解释和使用分配的内存。 通用函数接口（如 qsort、memcpy）使用 void* 参数来处理未知类型的数据。 使用 void* 时，必须先转换为具体指针类型才能解引用或访问数据。这种设计提供了灵活性，但也牺牲了类型安全。 内存泄漏是什么 程序通过 malloc/new 申请了内存，但在使用完后没有通过 free/delete 释放，导致这部分内存无法再被使用或回收。 影响：长期运行会占满内存，导致程序变慢甚至崩溃。 Q：如何避免？ 申请和释放配对使用 (malloc/free, new/delete)。 避免重复释放或遗忘释放。 推荐使用 智能指针（C++）管理内存。 深拷贝和浅拷贝的区别 浅拷贝：复制指针，不复制实际资源 → 多个指针对象指向同一块内存。 深拷贝：复制内容，独立资源 → 避免内存释放冲突。 程序分为几个段 典型的 C/C++ 程序在内存中分为： 代码段（text）：存放只读存储区和文本区。 数据段（data）：存放已初始化的全局变量、静态变量。 BSS 段：存放未初始化的全局变量、静态变量。 堆（heap）：动态分配的内存。 共享内存段：存储动态链接库以及调用mmap函数的文件映射 栈（stack）：局部变量、函数的参数，函数的返回值。 一个 .c 文件怎么转换为可执行程序 预处理：宏展开、头文件展开，生成 .i 文件。 将所有的#define删除，并且展开所有的宏定义 处理所有的条件预编译指令，如#if、#ifdef 处理#include预编译指令 过滤注释 添加行号和文件名标识 编译：把预处理结果转为汇编代码 .s。 目标代码生成：生成汇编代码 目标代码优化 汇编：汇编器将 .s 转为机器码 .o。 汇编代码转变成机器可以执行的指令 链接：把多个目标文件和库链接成可执行文件。 不同的源文件产生的目标文件进行链接 过程：.c —&gt; .i —&gt; .s —&gt; .o 静态链接和动态链接的区别 静态链接：库函数编译时直接打包进可执行文件。 优点：独立运行； 缺点：体积大，更新麻烦。 动态链接：运行时加载共享库。 优点：节省空间，易更新； 缺点：依赖库文件。 strcpy、sprintf和memcpy的区别 strcpy：仅用于字符串，必须有 \\0 结尾；有缓冲区溢出分险，建议用strncpy。 sprintf：用于格式化文本（带数字、拼接等），输出到字符串；不检查越界，建议用snprintf。 memcpy：拷贝任意内存，包括结构体、数组等，适用于“非字符串”。 ++a 和 a++ 的区别 ++a：先自加，不开辟空间，效率更高。 a++：需要开辟空间。 # 和 ## 的作用 #（字符串化） 把宏参数转成 字符串。 ##（连接符/粘合剂） 把宏参数和其他标识符拼接在一起。 不适用额外空间，交换两个数 局部变量能不能和全局变量重名 可以重名，局部变量会屏蔽同名的全局变量，在作用域内优先使用局部变量。 C 语言位域（Bit-field）（了解） 定义：在 struct 中，用指定位数存放成员，节省空间。 用途：常用于 硬件寄存器映射、标志位集合。 注意：位域排布依赖编译器/平台，移植性差。 示例： 用位运算计算余数（了解） 只了解到可以对2的幂进行取余操作 对 2 的幂取余：x % (2^n) == x &amp; (2^n - 1) 例：13 % 8 == 13 &amp; 7 == 5。 取消内存对齐的方法（了解） GCC：__attribute__((packed)) MSVC：#pragma pack(1) 什么是回调函数 一个函数作为参数传递给另一个函数，被在特定时机调用。 常用于 事件驱动、异步处理。 比如Bootloader执行完MSR_SP后，就需要加载回调函数load()。 如何判断一个整数是有符号还是无符号 面向对象和面向过程的区别 面向过程 (Procedure-Oriented) 强调 过程/函数，把问题拆解成步骤。 数据与函数分离。 面向对象 (Object-Oriented) 强调 对象，数据和操作绑定在一起。 支持 封装、继承、多态。 面向对象的三大特征 封装 概念：把数据和操作打包在类里，隐藏实现细节，对外只暴露必要接口。 C++ 实现：class / struct + 访问控制符（public、protected、private）。 作用：提高模块化与安全性，防止随意修改内部数据。 继承 概念：子类自动获得父类已有的成员与方法，可以复用或扩展。 C++ 实现：class Derived : public Base &#123; ... &#125;; 作用：代码复用，形成层次结构，支持多级继承。 多态 概念：同一接口在不同对象上表现出不同的行为。 C++ 实现： 编译期多态：函数重载、运算符重载（通过名字/参数列表区分）。 运行期多态：虚函数 + 基类指针/引用调用派生类实现（依赖 virtual 关键字 + 动态绑定）。 作用：提高灵活性，便于扩展。 C++ 类的访问权限 public：对所有代码可见。 protected：仅类本身和派生类可见。 private：仅类本身可见。 重载、重写、覆盖 重载（Overload） 概念：同一个作用域内，函数名相同，但 参数列表不同（个数或类型不同）。 发生位置：同一个类中（或全局函数）。 关键点：编译期根据实参匹配 → 静态多态。 重写（Override） 概念：派生类中 重新定义 基类的 虚函数，函数名必须相同。 发生位置：继承体系中。 关键点：运行时通过虚表决定调用 → 动态多态。 隐藏（Hide/Overwrite） 概念：派生类定义了一个与基类同名但非虚函数或 参数列表不同的函数，会隐藏基类的同名函数。 结果：基类版本被“遮蔽”，不是严格的多态。 重载：同域，同名，不同参数 → 编译期多态。 重写：继承，虚函数，相同签名 → 运行时多态。 覆盖：继承，同名但非虚函数或不同签名 → 基类函数被隐藏。 什么是智能指针，C++ 的智能指针有哪些，作用是什么 作用：自动管理内存，避免new/delete 手工管理带来的内存泄漏。 C++ 智能指针： std::auto_ptr（C++11 废弃）。 std::unique_ptr：独占所有权→ 同一时间只能有一个指针指向资源，不能拷贝，只能移动。 std::shared_ptr：引用计数共享所有权 → 多个指针可以同时指向资源，内部用 引用计数 管理，最后一个销毁时释放内存。 std::weak_ptr：弱引用 → 不增加引用计数，用来观察 shared_ptr 管理的对象，解决循环引用问题。 这里的所有权 (ownership) 指 谁负责在对象生命周期结束时释放内存。 Q：为什么auto_ptr会被废弃？ auto_ptr 拷贝/赋值时，会把所有权转移（源指针变空）。 容易导致意外失效，比如容器里的元素被拷贝后全部失效。 C++有几种new 类型 语法示例 说明 普通 new（plain new） int* p = new int(5); 分配内存并调用构造函数 placement new new(ptr) Type(args); 在已有内存上构造对象 nothrow new int* p = new(std::nothrow) int; 分配失败返回 nullptr，不抛异常 C++有几种强制转换 转换类型 语法示例 用途简述 static_cast static_cast&lt;int&gt;(3.14) 普通转换（类型安全）如基本类型、父子类指针转换 dynamic_cast dynamic_cast&lt;Derived*&gt;(basePtr) 向下转型（需 RTTI）父类 → 子类，失败时返回 nullptr const_cast const_cast&lt;char*&gt;(cstr) 加/去 const reinterpret_cast reinterpret_cast&lt;int*&gt;(p) 按位重解释（低级暴力）能转但风险高！ 隐式转换，如何消除它 编译器自动帮你做的类型转换，不需要你写 cast 或构造函数，常在赋值、传参、运算中发生。 使用 explicit 关键字 使用 delete 禁用不想要的转换 使用强转类型转换（明确表达） cout和printf的区别（了解） cout和printf都是输出对应数据，而cout有缓冲输出，使用flush立即强迫缓冲输出。 什么是虚函数 定义：用 virtual 修饰的成员函数；用于运行时多态（动态绑定）。 机制（实现惯例）：每个多态对象含一根 虚指针指向 虚函数表；通过 虚函数表 在运行时决定调用哪个函数实现。 虚函数是类定义的，但调用属于对象 虚函数位于文本段(.text)，虚函数表位于数据段(.data) 什么是纯虚函数 定义：在基类中声明但没有实现的虚函数，语法： 特点： 含有纯虚函数的类是 抽象类，不能实例化。 常用于定义 接口/规范。 Q：纯虚函数和虚函数的区别？ A：纯虚函数只是相当于一个接口名。 C++中如何阻止一个类被实例化 构造函数设为 private/protected 纯虚析构函数（抽象类） 什么函数不能声明为虚函数 构造函数：对象还没完全构造，不能通过虚表实现多态。 静态成员函数：不依赖对象（没有 this 指针），无法放入虚表。 内联函数（inline）：可以是虚函数，但一旦被声明为虚函数，就失去强制内联的意义。 友元函数：不属于类成员，不能放入虚表。 模板函数：普通模板函数不能直接虚化。 为什么C++默认的析构函数不是虚函数 普通类通常 不会被继承，非虚析构更高效。 只有涉及 多态使用（基类指针/引用指向派生类对象） 时，才需要虚析构。 为什么析构函数必须是虚函数 如果通过 基类指针删除派生类对象，没有虚析构会只调用基类析构，导致派生类资源未释放 → 内存泄漏/未定义行为。 设为虚函数，能保证删除时按正确的继承层次依次调用析构函数。 静态函数和虚函数的区别 静态函数（static） 属于类本身，不依赖对象。 不能访问非静态成员（没有 this 指针）。 调用方式：ClassName::func()。 绑定方式：编译期绑定（静态绑定）。 虚函数（virtual） 属于对象，支持 运行时多态。 通过虚函数表（vtable）在运行时决定调用哪个版本。 必须通过对象或对象指针/引用调用。 绑定方式：运行时绑定（动态绑定）。 构造函数有几种，分别什么作用 默认构造函数 无参数或参数有默认值。 作用：创建对象时提供默认初始化。 有参构造函数 带参数。 作用：用指定值初始化对象。 拷贝构造函数 形如 Class(const Class&amp; obj)。 作用：用已有对象初始化新对象（值传递/返回对象时会调用）。 移动构造函数（C++11） 形如 Class(Class&amp;&amp; obj)。 作用：接管临时对象的资源，避免拷贝开销。 拓展： 委托构造函数（C++11） 一个构造函数调用同类的另一个构造函数。 作用：减少代码重复。 显式构造函数（explicit） 用 explicit 修饰。 作用：防止隐式类型转换。 构造函数和析构函数执行顺序 构造函数 基类构造函数 成员类对象构造函数 派生类构造函数 析构函数 派生类析构函数 成员类对象析构函数 基类析构函数 构造函数、拷贝构造函数和赋值运算符的区别 构造函数：对象不存在，创建一个新对象时调用 拷贝构造函数：对象不存在，用别的已经存在的对象来初始化 赋值运算符：对象存在，用别的对象给它赋值。 只定义析构函数，会自动生成哪些构造函数 默认构造函数 拷贝构造函数 拷贝赋值运算符 一个类默认会生成哪些函数 无参构造函数（默认构造函数） 拷贝构造函数 拷贝赋值运算符 (operator=) 析构函数（非虚，除非基类里有虚函数） 在 C++11 及以后，可能还会自动生成： 移动构造函数 移动赋值运算符 什么是虚拟继承 上述中B和C虚拟继承A，D又继承B和C，这种方式是菱形继承/钻石继承，无论基类被继承多少次，只会存在一个实体。 指针和引用的区别 指针存地址，引用是变量别名。 指针可为空，引用必须初始化且不可为空。 指针可多级，引用只有一级。 指针能改变指向；引用绑定后不可改变指向。 什么时候指针，什么时候引用 用指针的场景 参数可以为空。 需要在函数中改变指向。 需要返回函数内部申请的内存。 与 C 接口交互（C 风格就是指针）。 用引用的场景 必须有对象，不允许空。 对空间敏感（如递归、大对象），引用避免拷贝，开销小。 类如何实现只能静态分配和只能动态分配 只能静态分配：把new、delete重载为private属性 只能动态分配：把构造、析构函数设为protected属性，再用子类动态创建 什么是静态绑定和动态绑定 静态绑定：编译时决定，非虚函数，效率高，无需特殊关键字说明。 动态绑定：运行时决定，虚函数 + 指针/引用，支持多态（virtual、override）。 结构体变量比较是否相等 C语言 不支持 == 比较结构体变量。 必须手动逐个字段比较，或用 memcmp（不推荐，可能有填充位）。 C98 / C11 / C14 / C17 默认不支持结构体比较。 需要手动重载 operator==。 C++20及以上 支持结构体自动生成比较操作（需要使用 = default）。 内联函数（inline） 作用：建议编译器在调用处直接展开函数体，减少函数调用开销（避免压栈/跳转）。 特点： 编译阶段，有类型检查。 只是建议，编译器可选择忽略。 适合短小、频繁调用的函数。 递归函数、过大函数通常不会被内联。 内联函数必须在调用前可见。 优势： 提高性能（减少调用开销）。 保持函数形式（比宏函数更安全，有类型检查）。 局限： 会增加代码体积（代码膨胀）。 不能用于虚函数的多态调用（运行时决定的调用无法内联）。 extern “C” 的作用 用于 C++ 中：告诉编译器按 C 语言方式 编译函数。 作用：避免 C++ 的 函数名修饰 (name mangling)，便于与 C 代码或库兼容。 C++中NULL和nullptr区别 NULL来自C语言，nullptr则是C++11新增关键字。 NULL 是 (void*)0，有类型歧义，不推荐。 nullptr 是专门的空指针类型，类型安全， Q：C语言可以没有NULL吗？ NULL 不是必须的，只是 (void*)0 的别名。 C语言可以不用 NULL，但实际开发强烈建议用 NULL 表示空指针，提升可读性和规范性。 this指针 this 是一个指向当前对象首地址的指针。 this只能在成员函数使用，不能在全局函数、静态函数中使用。 存储位置因编译器不同会不同。 Q1：this指针是什么时候创建？ A1：在每次调用非静态成员函数时，编译器会隐式传入当前对象的地址作为 this 参数。所以**this 不是在构造对象时创建的，而是在成员函数执行时临时传入的**。 Q2：this存放在哪？ A2：this是一个局部变量，通常存放在寄存器/栈中。 左值和右值的区别 左值 (lvalue)：表示一块可寻址的内存，可以出现在赋值符号左边。 例：变量名 a，数组元素 arr[2]，解引用 *p。 右值 (rvalue)：表示 临时值、常量、表达式结果，生命周期短，不能单独取地址。 例：常量 10，表达式 a+b。 C++ 扩展（右值细分） 左值 纯右值 (prvalue)：字面量、临时对象。 将亡值 (xvalue)：可被“偷资源”的临时对象（支持移动语义）。 左值：有名字、有地址、能长期存在。 右值：没名字、临时用完就丢。 常见易混例子 i++ → 右值（返回旧值的临时量，不能赋值）。 ++i → 左值（返回自增后的变量本身，可继续赋值）。 arr[0] → 左值（数组元素，可寻址）。 a+b → 右值（表达式结果，临时） C/C++的关键字（了解） C语言 相较于C语言，C++新增 vector的底层实现 结构：动态数组，内存连续，可随机访问。 扩容：容量不足时按倍数增长，重新分配并搬移元素。 迭代器失效：扩容后所有迭代器失效；非扩容时，插入/删除点之后的迭代器失效。 vector 和 list 的使用场景与区别 vector 底层实现：动态数组，元素连续存储。 优势：支持 随机访问 O(1)，缓存友好，遍历效率高。 劣势：中间插入/删除需要移动大量元素，效率低。 适用场景：查询、顺序访问多，增删少。 list 底层实现：双向链表，元素分散存储。 优势：插入/删除 O(1)（已知位置时），不会移动其他元素。 劣势：不支持随机访问，只能顺序遍历；节点额外指针开销大，缓存不友好。 适用场景：需要频繁在中间插入、删除。 Q：如果有10w个数据，那么查找一个元素，list和vector哪个效率更高？ A：查找要根据实际情况选用，而不是纯理论。 如果位于中间，则vector 如果位于开头或结尾，则list （如果不知道处于什么位置，那就用vector吧） Vector下的Resize和Reserve的区别 resize(n)：改变大小，若变大则会构造新元素（对内置类型填充为 0，对类调用默认构造），可能导致 迭代器失效。 reserve(n)：只调整容量，不改变元素数量；不会插入新元素，所以不会填充 0，只是预留空间；若实际扩容则 迭代器失效。 Vector的内存占用空间只增不减，即使erase/clear也是不变。 Vector.size()是capacity，还是已存储的元素个数 已存储的元素个数 size 是“已经放了几个”，capacity 是“最多能塞几个”。 如何理解迭代器，容器的迭代器是由什么组成的 定义：迭代器是“指针的泛化”，用来访问容器中的元素。 作用：统一访问方式，让不同容器都能用同样的算法操作。 底层通常是 指针 或 类对象，封装了： 当前元素的位置（指针/索引）。 运算操作（++, --, *, -&gt; 等）。 类型定义（value_type, reference, pointer 等）。 STL中迭代器有什么用，有指针了为何还要迭代器 作用：在不同容器上提供统一的访问方式，配合算法使用。 为什么不直接用指针： 不是所有容器都用连续内存（如 list、map）。 迭代器可像指针一样操作，但能适配各种容器。 STL中有哪些容器，这些容器的迭代器是如何删除元素 常见容器 顺序容器：vector、deque、list 关联容器：set、map、multiset、multimap 无序容器：unordered_set、unordered_map、unordered_multiset、unordered_multimap 删除元素与迭代器 vector / deque：erase(it)，返回下一个迭代器；删除点及其后的迭代器全部失效。 list：erase(it)，只使 it 失效，其他迭代器不变。 map / set / 无序容器：erase(it)，只使当前迭代器失效，其他迭代器保持有效。 STL容器结构 序列式容器 vector：动态数组（连续内存块，通常维护起始、尾后和容量末尾三个指针） deque：分块数组 + 中控器（一个指针数组管理多个固定大小的连续内存块） list：双向循环链表（每个节点包含指向前后节点的指针和数据） forward_list：单向链表（每个节点仅包含指向下一个节点的指针和数据） array：静态数组（固定大小的连续内存，编译时确定） 关联式容器（有序） set / map / multiset / multimap：红黑树 关联式容器（无序） unordered_set / unordered_map / unordered_multiset / unordered_multimap：哈希表 容器适配器 stack：默认基于 deque 封装（也可指定 vector或 list） queue：默认基于 deque 封装（也可指定 list） priority_queue：默认基于 vector 封装（堆算法，默认为大顶堆） STL中的map和set有什么区别，怎么实现的 存储内容 map：存储 key-value 键值对，key 唯一。 set：只存储 key，元素唯一。 访问方式 map[key] 可直接通过下标访问或修改 value。 set 只能通过迭代器遍历查找。 底层实现 两者通常都用 红黑树（平衡二叉搜索树） 实现，元素有序。 map 的节点存 (key, value)，set 的节点只存 key。 插入、删除、查找复杂度均为 O(log n)。 Q：为什么map和set使用红黑树 它们要求自动排序，而红黑树能够实现这一功能，并且时间复杂度较低。 STL中的map和unordered_map区别 map 底层实现：红黑树（平衡二叉搜索树）。 存储内容：节点存放 (key, value)。 存放规则：按 key 有序 排列。 复杂度：查找/插入/删除 O(log n)。 遍历：迭代器中序遍历即有序。 unordered_map 底层实现：哈希表（bucket + 链表/拉链法 或 开放地址法）。 存储内容：元素 (key, value) 存放在某个桶中。 存放规则：按 哈希值分桶，无序。 复杂度：平均 O(1)，最坏 O(n)。 遍历：迭代器顺序取决于哈希分布，不能保证有序。 STL的map插入方式 用insert函数插入pair 用insert函数插入value_type 用insert函数插入make_pair() 用数组方式插入数据 Q：map中的[]与find的区别？ A：operator[]用于访问或插入元素，若键不存在则会自动创建新键值对（值默认初始化）并返回其引用；find仅用于查找元素，返回迭代器，若键不存在则返回 end()迭代器，不会修改map。若需检查键是否存在且避免意外插入，应优先使用find 什么是初始化列表，哪些情况下只能初始化列表，而不能赋值 初始化列表 (Initializer List) 概念：在构造函数冒号后，用 &#123;&#125; 或 () 直接对成员进行初始化。 区别： 初始化列表 → 在对象创建时直接初始化成员。 构造函数体赋值 → 先默认初始化，再在函数体里赋值。 必须用初始化列表的情况 const 成员 引用成员 &amp; 无默认构造函数的成员对象 基类构造函数调用 没有参数的函数能不能被重载 可以重载，但前提是 参数列表不同。 如果都是 无参数，则无法区分，编译报错。 数据结构 常见的排序算法 冒泡排序： 相邻元素两两比较，大的往后移，循环多次把最大值“冒”到最后。 插入排序： 前面保持有序序列，取下一个元素，按大小插入到合适位置。 选择排序： 每一轮从未排序区选择最小（或最大）的，与当前位置元素交换。 快速排序： 取一个基准值，把小于的放左边，大于的放右边，然后递归分区排序。 归并排序： 不断二分数组，递归到底后再逐层合并两个有序序列（需辅助数组）。 基数排序： 按数位（个位、十位、百位…）依次排序，常用稳定排序作为子过程。 希尔排序： 基于插入排序，先按较大间隔分组排序，再逐渐缩小间隔至 1。 堆排序： 利用大顶堆/小顶堆，每次取堆顶元素放到末尾，再调整堆结构。 计数排序： 统计每个元素出现次数，通过计数下标映射回输出（需额外数组）。 桶排序： 按数值范围映射到不同桶内，每个桶独立排序，最后合并所有桶。 二叉树通过中序遍历和后序遍历，判断前序遍历 前序遍历：中左右；中序遍历：左中右；后序遍历：左右中。 例子 中序：D B E A F C 后序：D E B F C A 推导过程 后序末尾 = A → 整棵树根。 在中序里，A 左边是 D B E，右边是 F C。 左子树 = D B E 在对应后序子序列 D E B，末尾 B 是根。 在中序 D B E 中，B 左边是 D，右边是 E。 → 左子树前序 = B D E。 右子树 = F C 在对应后序子序列 F C，末尾 C 是根。 在中序 F C 中，C 左边是 F，右边为空。 → 右子树前序 = C F。 拼接前序 根 A + 左子树 B D E + 右子树 C F → 前序 = A B D E C F。 后序定根，中序分左右，递归拼前序。 什么是搜索二叉树 左子树所有节点的值 小于 根节点值； 右子树所有节点的值 大于 根节点值； 中序遍历结果是 递增序列。 什么是平衡二叉树 一种二叉搜索树，任意节点的左右子树高度差不超过 1。 作用：保持查找、插入、删除的时间复杂度 O(log n)。 典型实现：AVL 树、红黑树。 二叉树通过中序遍历和后序遍历，判断前序遍历 前序遍历：中左右；中序遍历：左中右；后序遍历：左右中。 例子 中序：D B E A F C 后序：D E B F C A 推导过程 后序末尾 = A → 整棵树根。 在中序里，A 左边是 D B E，右边是 F C。 左子树 = D B E 在对应后序子序列 D E B，末尾 B 是根。 在中序 D B E 中，B 左边是 D，右边是 E。 → 左子树前序 = B D E。 右子树 = F C 在对应后序子序列 F C，末尾 C 是根。 在中序 F C 中，C 左边是 F，右边为空。 → 右子树前序 = C F。 拼接前序 根 A + 左子树 B D E + 右子树 C F → 前序 = A B D E C F。 后序定根，中序分左右，递归拼前序。 计算机网络 OSI 四层模型 / 七层模型 四层模型： 应用层：提供应用服务（HTTP、FTP、SMTP、DNS）。 传输层：端到端通信，保证可靠/快速（TCP、UDP）。 网络层：选择路径、寻址转发（IP、ICMP）。 网络接口层：封装/解封装成帧并传输（以太网、PPP、物理层比特流）。 七层模型： 应用层：面向用户的软件（HTTP、FTP、SMTP）。 表示层：数据表示、加密/解密、压缩/解压缩。 会话层：会话建立、管理和终止。 传输层：端到端通信，流量控制、差错控制（TCP、UDP）。 网络层：逻辑寻址和路由选择（IP、ICMP）。 数据链路层：成帧、差错检测、MAC 地址（ARP、PPP、以太网）。 物理层：比特流传输（网线、网卡标准）。 HTTP是什么 定义：超文本传输协议（HyperText Transfer Protocol），基于 TCP/IP 的应用层协议，用于浏览器和服务器之间传输数据。 HTTP 的发展史 HTTP/1.0：短连接，请求一次建立一次 TCP 连接。 HTTP/1.1：默认长连接，支持流水线。 HTTPS：HTTP + SSL/TLS，加密传输。 HTTP/2.0：多路复用、头部压缩、二进制帧，用流的形式发送。 HTTP/3.0：基于 QUIC 协议（UDP），减少握手延迟。 HTTP请求和响应报文包含哪些字段 请求报文 请求行 请求头 请求体 响应报文 状态行 响应头 响应体 HTTP请求流程 DNS解析域名IP 根据IP，建立TCP连接 发送HTTP请求 服务器响应请求，得到HTML代码 关闭TCP连接 浏览器解析HTML代码，并请求相关资源（js、css、图片） 浏览器渲染页面呈现 GET和POST的区别 GET是获取数据，POST是修改数据 GET是幂等，POST不是幂等 GET后服务器响应200 ok；POST后服务器先响应100 Continue，再响应200 ok 因此POST会产生两个TCP数据包 GET提交的数据有上限，POST没有上限 HTTP和HTTPS的区别 HTTPS协议是由SSL+HTTP协议构建的可加密传输的网络协议； HTTPS需要申请CA证书； HTTPS使用443端口，HTTP使用80端口。 对称加密和非对称加密 对称加密 加密和解密使用同一个密钥。 速度快，适合加密大量数据。 核心问题：如何安全地共享密钥。 非对称加密 使用一对密钥：公钥和私钥。 公钥加密的数据，只能用对应的私钥解密。 私钥签名的数据，可以用对应的公钥验证来源。 速度慢，主要用于密钥交换和数字签名。 HTTPS请求流程 先通过 DNS 解析获取服务器的 IP 地址； 接着 TCP 三次握手建立网络连接； 客户端向服务端发起一个 HTTPS 请求（含有Client Random、SSL/TLS套件版本）； 服务器会将其数字证书（包含公钥）发送给客户端（含有Server Random）； 客户端会验证该证书的合法性，包括检查其是否由可信机构颁发、是否在有效期内以及域名是否匹配等。验证通过后，客户端会生成一个用于后续对称加密的 Pre-Master Secret（预主密钥）； 客户端用服务器证书中的公钥进行加密后发送给服务器； 服务器使用自己的私钥解密，获取该预主密钥； 随后，客户端和服务器会利用握手过程中交换的 Client Random（客户端随机数）、Server Random（服务端随机数）和刚刚协商出的 Pre-Master Secret，各自独立计算生成相同的会话密钥（Master Secret）； 此后的所有通信数据都将使用这个会话密钥进行对称加密和解密，确保数据传输的机密性和完整性。 常见HTTP状态码 HTTP状态码是服务器对请求处理结果的标识。 1xx（信息性状态码）：表示请求已被接收，需要继续处理。 100 Continue（客户端可继续发送请求） 2xx（成功状态码）：表示请求已成功被服务器接收、理解并处理。 200 OK（请求成功） 201 Created 表示新资源被创建 204 No Content 表示成功但无内容返回 3xx（重定向状态码）：表示需要进一步操作以完成请求。 301 Moved Permanently 是永久重定向 302 Found 是临时重定向 304 Not Modified 告知客户端可使用缓存资源 4xx（客户端错误状态码）：表示请求可能出错。 400 Bad Request 指请求有语法错误 401 Unauthorized 表示需要身份验证 403 Forbidden 是服务器拒绝请求 404 Not Found 表示资源不存在 5xx（服务器错误状态码）：表示服务器处理请求时出错。 500 Internal Server Error 是服务器内部错误 503 Service Unavailable 表示服务暂时不可用 什么是DNS Domain Name System，域名系统；是域名和IP地址相互映射的数据库。 DNS域名解析通过UDP协议，输入域名后流程： 检查浏览器缓存是否包含这个域名映射的IP地址；若没有，执行2； 检查操作系统缓存；若没有，执行3； 检查本地域名服务器解析（LDNS）；若没有，执行4； 检查根域名服务器(.com)，一步一步往下传，最终返回对应的IP地址。 DNS 负载均衡 DNS 负载均衡是一种通过 DNS 解析过程 来分配网络流量的策略。其核心是 一个域名对应多个 IP 地址。当用户访问这个域名时，DNS 服务器会根据预设的策略，从这些 IP 地址中选择一个返回给用户，从而将访问流量分散到不同的服务器上。 TCP 和 UDP 的区别 TCP：面向连接，可靠传输，基于字节流的，速度慢。 UDP：面向报文，无连接，不可靠传输，速度快。 MTU和MSS分别是什么 Maximum Transmission Unit，最大传输单元，即IP头+TCP头+DATA。 Maximum Segment Size，最大段长，即DATA。 TCP 粘包和拆包问题，怎么解决 原因：TCP 是字节流协议，不保证消息边界 → 多个包合并或一个包被拆分。 解决方法： 固定长度消息 使用分隔符 在消息头加长度字段 应用层协议处理（如 HTTP、MQTT） TCP 通信如何保证通信的可靠性 确认应答机制（ACK） 校验和 有序性保证（序列号保证数据按顺序到达） 超时重传 滑动窗口（流量控制）：当接收方来不及处理发送方数据，可以通过滑动窗口，提示发送方降低发送速率 拥塞控制（慢启动、拥塞避免、拥塞发生、快速重传/恢复） 如何区分流量控制和拥塞控制 流量控制属于通信双方协商，拥塞控制涉及通信链路全局 流量控制需要通信双方各维护一个发送窗和接收窗；发送窗由接受方响应的TCP窗口大小确定，接收窗由自身决定 拥塞控制的窗口大小变化由试探性发送一定数据量数据探查网络状态后自适应调整 实际发送窗口 = min{流量发送窗口，拥塞窗口} TCP 三次握手（连接建立） 客户端 → 服务端：发送 SYN=1, seq=x 表示请求建立连接，并告知初始序列号 x。 客户端进入 SYN_SENT 状态**（半连接）**。 服务端 → 客户端：发送 SYN=1, ACK=1, seq=y, ack=x+1 确认收到了客户端的 SYN，同时自己也发起连接请求。 服务端进入 SYN_RCVD 状态。 客户端 → 服务端：发送 ACK=1, ack=y+1 确认收到了服务端的 SYN。 客户端进入 ESTABLISHED 状态。 服务端收到 ACK 后，也进入 ESTABLISHED（全连接）。 👉 为什么三次？ 防止已失效的连接请求报文突然到达而引起错误（历史 SYN 报文问题）。 双方要确认 对方的收发能力。 🍊 什么是半连接队列和全连接队列？ 服务器第一次接收到客户端的SYN，会处于SYN_RECV状态，此时是半连接队列。 服务器第二次接收到客户端的SYN+ACK，会处于SYN_ACK状态，此时是全连接队列。 ⚙️ 三次握手可以携带数据吗？ 第一次和第二次握手不允许携带；第三次可以携带。 TCP 四次挥手（连接释放） 客户端 → 服务端：发送 FIN=1, seq=u 表示“客户端已无数据要发”，请求关闭连接。 客户端进入 FIN_WAIT_1 状态。 服务端 → 客户端：发送 ACK=1, ack=u+1 确认收到了 FIN，但可能还有数据要发。 服务端进入 CLOSE_WAIT 状态；客户端进入 FIN_WAIT_2。 服务端 → 客户端：发送 FIN=1, seq=v 当服务端也没有数据要发时，主动关闭。 服务端进入 LAST_ACK 状态。 客户端 → 服务端：发送 ACK=1, ack=v+1 确认收到服务端的 FIN。 客户端进入 TIME_WAIT，等待 2MSL 确保最后 ACK 不丢失。 服务端收到 ACK 后进入 CLOSED，释放连接。 👉 为什么要四次？ TCP 是全双工的，关闭要分成两个方向。 一方发送 FIN 表示“我这边没数据了”，但另一方可能还有数据要发 → 所以 ACK 和 FIN 分开发。 为什么客户端最后还要等待2MSL MSL（Maximum Segment Lifetime）：报文在网络中的最长存活时间。 等待 2MSL 的原因： 保证 ACK 能到达 客户端最后发给服务端的 ACK 可能丢失。 等待 2MSL 可确保服务端若未收到 ACK，重发 FIN，客户端还能再次回应。 清除旧报文 2MSL 时间足够让网络中的所有旧 TCP 报文消失，避免影响后续新的连接。 什么是 Cookie Cookie 是服务器发送到用户浏览器并保存在本地的一小块文本数据。浏览器会存储它，并在后续向同一服务器发起的请求中自动携带。 会话状态管理（如保持登录） 个性化设置（如语言偏好） 浏览器行为追踪。 什么是 Session Session 是一种在服务器端保存用户状态信息的机制。服务器会为每个用户会话创建一个唯一的标识（Session ID），通常通过 Cookie 传递给客户端。后续请求中，客户端凭此 ID 即可让服务器识别出用户并访问其对应的会话数据，从而在无状态的 HTTP 协议上实现有状态的交互。 socket网络编程中用到哪些函数 服务端（Server） socket() → 创建套接字。 bind() → 绑定 IP 和端口。 listen() → 监听端口，等待连接。 accept() → 接收客户端连接，返回新的套接字。 recv() / send() 或 read() / write() → 收发数据。 close() → 关闭连接。 客户端（Client） socket() → 创建套接字。 connect() → 连接服务端。 recv() / send() 或 read() / write() → 收发数据。 close() → 关闭连接。 DHCP 协议（Dynamic Host Configuration Protocol）（了解） 作用：自动为主机分配网络参数（IP 地址、子网掩码、网关、DNS 等），避免手工配置。 工作方式：基于 UDP，通常通过广播通信。 应用层：DHCP 协议本身（运行在客户端和服务器之间，分配网络参数）。 传输层：使用 UDP（客户端端口 68，服务器端口 67）。 网络层：依赖 IP（广播 255.255.255.255 或子网广播地址）。 链路层：在第一次请求时，客户端可能还没有 IP，会用 MAC 地址标识自己。 ARP和RARP ARP：IP地址转物理地址 RARP：物理地址转IP地址 Ping命令基于什么协议（了解） Ping是基于网络层的ICMP协议实现。通过向对方发送一个ICMP回送请求报文。 IP 地址、子网掩码、网关和 DNS 作用 IP 地址：设备在网络中的唯一标识。 子网掩码：划分网络号和主机号。 网络号 = IP 地址 &amp; 子网掩码 主机号 = IP 地址 &amp; (子网掩码取反) 网关：跨网络通信的出口。 DNS：域名解析，将域名转换为 IP 地址。 IPv4 和 IPv6 的区别（了解） 地址长度 IPv4：32 位地址，约 43 亿个地址。 IPv6：128 位地址，几乎无限，解决地址枯竭问题。 地址表示 IPv4：点分十进制（192.168.0.1）。 IPv6：冒号十六进制（2001:db8::1）。 首部结构 IPv4：首部字段复杂，最多 60 字节。 IPv6：首部简化，固定 40 字节，处理更高效。 地址配置 IPv4：可手动、DHCP。 IPv6：支持自动配置（无状态地址自动配置，SLAAC）。 安全性 IPv4：依赖应用层/扩展（如 IPSec 可选）。 IPv6：IPSec 是强制支持的。 广播方式 IPv4：支持广播。 IPv6：取消广播，改用 组播/任播。 常用的网络拓扑类型（了解） 星型：所有节点通过中心设备连接，可靠但中心单点故障。 总线型：共享一条总线，成本低但冲突多。 环型：形成闭环，适合定时传输。 树型：层次化管理。 网状型：高可靠性，多路径冗余。 操作系统 进程、线程和协程的区别 进程（Process） 操作系统进行 资源分配 的基本单位。 进程间相互独立，通信需要 IPC（Inter-Process Communication）。 切换开销大。 线程（Thread） CPU 资源调度的最小单位。 共享内存资源（代码段、堆），但有独立的栈和寄存器。 切换开销比进程小，但仍需内核参与。 协程（Coroutine） 用户态的 轻量级线程，由程序自身调度。 主动让出 CPU（非抢占式），切换只保存寄存器/栈指针，开销极小。 适合大量并发 IO 场景（如异步网络请求）。 进程间通信方式 管道（Pipe） 分 无名管道（只能在有血缘关系的进程间通信）和 有名管道（FIFO，可在无血缘进程间通信）。 半双工：同一时间只能单向传输。 消息队列（Message Queue） 内核维护的 消息链表。 适合多对多通信，但消息体积受内核限制。 共享内存（Shared Memory） 多个进程共享同一块物理内存。 速度最快，因为数据不需要在内核与用户空间拷贝。 通常需要配合 信号量 做同步。 信号量（Semaphore） 一个 计数器，用于控制对共享资源的访问。 常用于 进程/线程间的互斥与同步，本身不传递数据。 信号（Signal） 一种 异步通知机制，用于告诉进程发生了某事件（如 Ctrl+C 触发 SIGINT）。 常用于进程控制、异常处理。 套接字（Socket） 可用于 同一台机器 或 不同机器 之间的通信。 支持 双向通信，是网络编程的核心。 进程间通信的选择 管道（Pipe） 简单、快速，适合 父子进程间少量数据传递。 消息队列（Message Queue） 适合 多进程间有序/分类消息传递，但大数据效率较低。 共享内存（Shared Memory） 最快，适合 大量数据、高性能通信；需配合信号量保证同步。 信号量（Semaphore） 计数器，控制同步与互斥，通常与共享内存结合使用。 信号（Signal） 事件通知/异常处理，不适合传递大数据，如Ctrl+C。 套接字（Socket） 可跨主机通信，适合分布式系统和网络通信。 简单父子通信 → 管道 多进程消息传递 → 消息队列 大量数据共享 → 共享内存 + 信号量 事件通知 → 信号 跨主机/网络 → 套接字 进程间的状态 创建（new）：进程创建中。 就绪（ready）：等待 CPU 调度。 运行（running）：占用 CPU 正在执行。 阻塞（waiting）：等待 I/O 或事件。 终止（terminated）：执行完成或被终止。 线程间通信方式 临界区（Critical Section） 保护共享资源的那段代码片段，一次只允许一个线程进入。 互斥量（Mutex） 互斥锁机制，线程必须先获取锁才能访问资源。 适合 独占访问。 信号量（Semaphore） 计数器，允许多个线程同时访问一定数量的资源。 适合 并发限流。 条件变量（Condition Variable） 线程可等待某条件满足后再执行，常与互斥锁配合。 适合 线程间同步/通知。 读写锁（RWLock） 同时允许多个读，但写时独占。 适合 读多写少 的场景。 事件（Event，对象/信号量变体） 一个线程发出信号，唤醒等待的线程。 常用于 线程间通知/状态同步。 互斥量/临界区 → 独占资源 信号量 → 限制并发数量 条件变量/事件 → 通知与同步 读写锁 → 读多写少优化 多进程和多线程的适用场景区别 多进程：稳定性好，进程隔离，不限制开销和效率的场景。适合多核 CPU、大规模并发服务。 多线程：共享内存，切换开销小，效率高。适合计算密集型、轻量级并发。 什么是线程池 线程池：预先创建一定数量的线程，重复利用来执行任务。 优点：减少频繁创建/销毁线程的开销，提高并发性能。 典型应用：服务器请求处理。 什么是线程安全 一个函数/代码段在多线程环境下被多个线程同时调用时，能保证结果正确。 实现方法：加锁、原子操作、TLS（线程局部存储）。 僵尸进程、孤儿进程和守护进程 僵尸进程：子进程结束但父进程未回收（未调用 wait）。 孤儿进程：父进程退出，子进程被 init/systemd 接管。 守护进程：在后台运行、无终端控制的进程。 僵尸进程有什么危害，如何解决 占用进程号（PID），大量僵尸进程会耗尽系统可用 PID，导致新进程无法创建。 占用少量内核资源（PCB）。 解决方法 父进程调用 wait() / waitpid() → 正常回收子进程。 父进程结束 → 子进程由 init（PID 1）接管并回收。 发送信号杀父进程 → 触发系统回收子进程。 什么是内核线程和用户线程 内核线程（Kernel Thread） 由 操作系统内核 创建和管理。 线程调度、切换都在内核态完成。 开销较大，但能充分利用多核 CPU。 用户线程（User Thread） 完全由 用户态库 实现，内核无感知。 线程切换开销小（不陷入内核）。 缺点：若一个线程阻塞，整个进程都会阻塞（N:1 模型）。 进程调度算法有哪些 先来先服务（FCFS） 按到达顺序调度，公平但可能等待时间长。 短作业优先（SJF） 选择运行时间最短的进程，平均等待时间最小；对长作业不利。 最短剩余时间优先（SRTF） SJF 的抢占式版本，剩余时间短的优先。 优先级调度 按优先级选择进程，高优先级可能导致低优先级饥饿。 时间片轮转（RR） 每个进程按时间片轮流执行，适合分时系统。 多级队列调度 不同类型进程放在不同队列，队列间有优先级。 多级反馈队列调度（MLFQ） 进程可在队列间动态调整，综合考虑响应与效率。 并发和并行 并发（Concurrency）- 单CPU 逻辑上同时发生：在同一时间段内交替执行多个任务。 依赖 操作系统调度，强调 任务切换。 并行（Parallelism）- 多CPU 物理上同时发生：在同一时刻由多个处理器同时执行。 需要 多核/多处理器 支持，强调 真正同时运行。 单核机械上写多线程程序，是否考虑加锁（了解） 要考虑加锁，原因： 可抢占与切换：单核也会在任意时刻发生线程切换，共享可变数据会产生 竞态。 内存可见性：没有同步就没有 happens-before 关系；编译器/CPU 重排序、缓存导致线程间 看不见彼此更新。 原子性：读取-修改-写入这类复合操作在无锁下会被打断，出现数据损坏。 内存交换和覆盖有什么区别 内存交换技术主要在不同进程间进行，而内存覆盖是在同一个进程中。 为什么使用虚拟内存 隔离：进程互不干扰，更安全。 扩展：地址空间大于物理内存，扩大空间。 简化：程序只管虚拟地址，底层分配由系统处理。 保护：防止非法访问。 共享：可让多个进程共享一块物理内存。 逻辑地址转化为物理地址的基本流程 CPU执行指令时生成逻辑地址（虚拟地址），该地址由页号和页内偏移量组成。 内存管理单元（MMU）负责截获此逻辑地址。 MMU首先查询快表（TLB），若找到缓存的页表项（即TLB命中）则直接获取物理页框号；若未命中，则需查询内存中的页表以获取对应的物理页框号，并更新TLB。 获取物理页框号后，将其与逻辑地址中的页内偏移量组合形成物理地址，计算公式为：物理地址 = 物理页框号 × 页面大小 + 页内偏移量。最终，使用该物理地址访问实际内存单元。 假设： 页面大小为 1024 字节。 页表如下（记录了逻辑页号与物理块号的映射关系）： 逻辑页号 (p) 物理块号 (f) 0 2 1 5 2 8 现在需要将逻辑地址 2500 转换为物理地址。 转换过程如下： 计算页号和页内偏移 页号 (p) = 逻辑地址 / 页面大小 = 2500 / 1024 ≈ 2.44 → ​​取整数部分，得到页号 2​​ 页内偏移 (d) = 逻辑地址 % 页面大小 = 2500 % 1024 = ​​452​​ (这里的 % 是取余运算) 查页表，获取物理块号 根据计算得到的​​逻辑页号 p = 2​​，查找页表，找到其对应的​​物理块号 f = 8​​。 组合物理地址 物理地址 = (物理块号 × 页面大小) + 页内偏移 = (8 × 1024) + 452 = 8192 + 452 = ​​8644​​ 所以，逻辑地址 2500 对应的物理地址是 ​​8644​​。 动态分区分配算法 首次适应算法（First Fit, FF） 从低地址开始顺序查找空闲分区链（表），找到第一个能满足大小的空闲分区即进行分配。 临近适应算法（Next Fit, NF） 从上次分配的位置之后开始顺序查找，找到第一个能满足要求的空闲分区。 最佳适应算法（Best Fit, BF） 空闲分区按容量从小到大排序，分配时找到能满足要求的最小空闲分区，以减少浪费。 最坏适应算法（Worst Fit, WF） 空闲分区按容量从大到小排序，分配时总是选择最大的空闲分区进行分割。 磁盘调度算法 先来先服务 (FCFS) 严格按照请求到达的先后顺序进行调度。 最短寻道时间优先 (SSTF) 优先选择距当前磁头所在磁道距离最近的磁道进行访问，以使每次的寻找时间最短。 扫描算法 (SCAN) 在磁头当前移动方向上选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象（也称电梯算法）。 循环扫描算法 (CSCAN) 在SCAN算法基础上规定磁头单向移动来提供服务，回返时直接快速移动至起始端而不服务任何请求。 页面置换算法 最佳置换算法（OPT, Optimal） 淘汰在未来最长时间内不会被访问的页面。这是理论上的最优算法，但无法实际实现（需要预知未来的页面访问序列），主要用于评估其他算法的性能。 先进先出置换算法（FIFO, First-In First-Out） 淘汰最早进入内存的页面。实现简单，但可能会产生Belady异常（即分配更多物理块时缺页率反而升高）。 最近最久未使用置换算法（LRU, Least Recently Used） 淘汰最长时间没有被访问的页面。性能接近OPT算法，能有效利用程序运行的局部性原理，但实现开销较大（需记录或维护页面访问时间或顺序）。 时钟置换算法（CLOCK） 一种LRU的近似算法。通过一个循环队列和使用位（Use Bit） 来模拟页面访问历史。检查页面时，若使用位为1则置0并留下；若为0则淘汰。是实际系统中常用的折中方案。 改进型时钟置换算法（Enhanced CLOCK） 在简单时钟算法基础上，额外考虑修改位（Modify Bit）。优先淘汰既未使用又未修改的页面，以减少将修改过的页面写回磁盘的I/O开销。 fork、exec、wait函数 fork() 创建一个子进程。 子进程拷贝父进程的 页表（写时拷贝，COW），看似共享同一份内存。 exec() 在子进程中调用，用新的程序（如 elf 文件）替换当前进程的代码和数据。 从此子进程运行新的程序，不再执行原来的代码。（分离父进程和子进程） wait() 父进程调用 wait/waitpid 后会 阻塞，直到子进程结束或状态改变。 用于回收子进程资源，避免僵尸进程。 父进程通过fork函数创建一个子进程，此时这个子进程拷贝了父进程的页表，两个进程都读同一个内存，exec函数可以加载一个elf文件去替换父进程，从此子进程就可以运行不同的程序，父进程wait函数之后会阻塞，直到子进程状态发生改变 fork 和 vfork 的区别 fork：子进程复制父进程地址空间（写时拷贝），父子进程几乎独立。 vfork：子进程与父进程共享地址空间，直到执行 exec 或 exit。效率更高，但风险更大。 当 for 循环遇到 fork 函数（了解） 每次 fork 都会创建新进程，最终进程数为 2^3 = 8。 读写锁、自旋锁和互斥锁的区别 互斥锁 (mutex)：一个任务独占，阻塞等待。 自旋锁 (spinlock)：忙等，不释放 CPU，适合临界区很短的情况。 读写锁 (rwlock)：允许多个读者，但写者独占，读多写少时效率高。 什么是原子操作？ 不可分割的操作，执行过程不会被中断。 特点：要么完全执行，要么完全不执行。 典型例子：加减计数、位操作。 实现方式：关中断、总线锁、CPU 提供的原子指令。 原子性问题，可见性问题，有序性问题 原子性问题 操作不可分割，中途不能被打断。 可见性问题 一个线程对共享变量的修改，其他线程不能立即看到。 有序性问题 程序执行顺序与代码顺序不一致。 局部性原理是什么 主要包括时间局部性和空间局部性。 时间局部性：如果执行了某个指令，那么不久后这条指令很有可能再被执行。 空间局部性：如果访问了某个内存，那么不久后这个内存或其附近的内存很有可能再被访问。 什么是死锁 定义：多个进程/线程在执行过程中，因争夺资源而相互等待，导致无法继续推进。 产生条件（死锁四要素）： 互斥：资源一次只能被一个进程占用。 请求保持：进程已持有资源，同时又提出新的资源请求。 不可剥夺：资源只能由占有它的进程主动释放。 循环等待：多个进程形成环形等待链。 预防方法 资源一次性分配：避免请求保持。 可剥夺资源：当请求未满足时，主动释放已有资源。 资源有序分配：给资源编号，进程按顺序申请，按逆序释放，避免环路等待。 Linux 什么是系统调用 用户态进程向内核请求服务的接口。 通过软中断或陷阱指令进入内核。 Linux 驱动的三大类型 字符设备驱动：顺序访问，按字节流操作，如串口。 块设备驱动：以数据块为单位，如硬盘。 网络设备驱动：面向数据包，如网卡。 为什么分用户态和内核态 核心目的是保护操作系统内核的安全与稳定。 用户态为普通应用程序提供受限的执行环境，使其无法直接访问硬件和关键系统数据。 内核态则赋予操作系统核心最高权限，以管理硬件、内存等所有关键资源。 这种隔离确保了即使应用程序出错或恶意，也不会导致整个系统崩溃。应用程序需通过系统调用这一“大门”来请求内核提供服务，从而实现了受控且安全的资源访问。 什么是交叉编译 在 一个平台 上编译生成 另一个平台 可运行的程序。 常见于嵌入式开发（如在 PC 上编译 ARM 设备的程序）。 Linux 和 RTOS 的区别 Linux：通用操作系统，功能强大，调度非实时。 RTOS：实时操作系统，保证任务实时性，资源占用小。 Linux 内核由哪些构成？ 进程管理 内存管理 虚拟文件系统 网络接口 中断进程间通信 Linux 系统组成部分 内核（Kernel）：管理硬件资源（CPU、内存、设备、进程调度等）。 Shell：命令解释器，用户与内核交互的接口。 文件系统（File System）：统一管理数据存储与访问。 应用程序（Applications）：运行在用户空间的软件。 什么是根文件系统 Linux 系统启动后挂载的第一个文件系统 /。 包含：驱动、库文件、系统命令、配置文件. 什么是临界区 多个线程/进程访问共享资源的代码区域。 要求：在同一时刻只允许一个执行，通常用锁保护。 什么是设备树 定义：一种 树状的数据结构，用文本/二进制文件（.dts / .dtb）描述硬件资源（CPU、内存、外设、中断等）。 作用： 把硬件信息从内核代码中抽离 → 内核与硬件解耦。 让同一个内核可以适配不同硬件平台，只需更换设备树文件，而无需重新编译内核 什么是IO复用 I/O复用（I/O Multiplexing）是一种单线程或单进程同时监听多个I/O事件的机制。 它允许程序将多个文件描述符（如套接字）注册到内核，并由内核监控这些描述符的状态。当其中任意一个描述符准备好进行读写或出现异常时，内核会通知应用程序进行处理。 其核心价值在于用单线程管理大量连接，避免了为每个I/O操作创建独立线程或进程的巨大资源开销和上下文切换成本，从而显著提升高并发场景下的性能和资源利用率。常见的实现有 select、poll 和 epoll。 select / poll / epoll 的区别与用处 select 用 位图 保存 fd，最大支持数有限（通常 1024）。 每次调用都要 重新设置 fd 集合。 内核返回后还需遍历所有 fd，效率低。 适合 少量连接、简单场景。 poll 用 数组（链表形式） 保存 fd，没有数量限制。 每次调用仍需遍历所有 fd，效率依旧不高。 比 select 灵活，但高并发时性能差。 epoll 内核用 红黑树管理 fd，就绪 fd 放在 就绪队列。 用户只需处理“就绪的 fd”，无需遍历全部。 支持 LT（水平触发） 和 ET（边缘触发） 两种模式。 在 大规模并发连接（如服务器）场景下性能最好。 fd（File Descriptor，文件描述符）： 就是“内核给打开的文件/资源的编号”，程序靠它操作资源。 位图（Bitmap）：用一组 二进制位（bit） 来表示某些状态或资源是否存在/可用。 为什么 Linux 的中断分为上半部分和下半部分？ 上半部分：快速处理中断（响应快），只做必要操作。 下半部分：延迟处理耗时任务（软中断、tasklet、工作队列）。 原因：缩短中断屏蔽时间，提高系统实时性。 硬中断 vs 软中断 硬中断（Hardware Interrupt） 来源：外部硬件设备（键盘、网卡、磁盘等）。 特点：异步发生，由硬件信号触发，CPU 立即响应。 用途：处理 I/O 请求、定时器等。 软中断（Software Interrupt） 来源：软件指令触发（如 int 指令、系统调用）。 特点：同步发生，由程序主动触发，用于进入内核。 用途：系统调用、调试、异常处理。 Linux常见指令 【Linux】Linux常用命令60条（含完整命令语句）_linux必学的60个命令-CSDN博客 STM32 STM32学习笔记里记录地很详细，推荐看那里的，这里是引申。 ARM 中的寄存器，都有什么用 通用寄存器 (R0–R12) 临时存储、函数参数、返回值。 约定： R0–R3：函数参数 &amp; 返回值 R4–R11：通常作为被调用者保存 R12 (IP)：暂存寄存器 SP (Stack Pointer, 栈指针) 指向当前栈顶。 分为： MSP (Main SP)：异常/中断、启动时使用 PSP (Process SP)：线程模式任务栈（RTOS 常用） LR (Link Register, 链接寄存器) 保存函数返回地址。 在异常返回时，LR 含特殊值（如 EXC_RETURN），决定返回到线程/处理模式和使用 MSP/PSP。 PC (Program Counter, 程序计数器) 指向将要执行的下一条指令。 ARM 架构中一般是“取值 = 当前指令地址 + 偏移”。 xPSR (Program Status Register, 程序状态寄存器) 包含条件标志位 (N, Z, C, V)，执行状态，当前异常号等信息。 大小端是什么 大端：高字节存储在低地址。 小端：低字节存储在低地址。 例子：int a = 0x12345678;（默认LSB优先） 大端存储：12 34 56 78 小端存储：78 56 34 12 Cortex-M3 和 Cortex-M4 的区别 同时支持大端/小端模式 Cortex-M3：支持基本的 ARMv7-M 架构，32 位 RISC 内核，适合通用控制。 Cortex-M4：在 M3 基础上增加 DSP 指令集 和 单精度浮点运算 (FPU)，适合信号处理。 M4 = M3 + DSP + 可选FPU GPIO 工作模式 输入模式：上拉输入、下拉输入、浮空输入、模拟输入 输出模式：推挽输出、开漏输出 复用功能：外设复用（USART、SPI 等） 什么是 IO 口悬空，可能带来哪些问题 IO 悬空：输入引脚未接电路。 问题：电平不确定，可能产生抖动、功耗增加、误触发。 解决：加上拉或下拉电阻。 中断栈和任务栈有什么区别，保存在哪里 任务栈 每个任务都有独立栈，用来保存任务自己的局部变量、函数调用现场、寄存器。 由 RTOS 在创建任务时分配，通常放在 SRAM。 中断栈 中断发生时，CPU 自动把部分寄存器（PC、xPSR、LR 等）压入当前正在使用的栈。 裸机：使用主栈指针 MSP 作为中断栈。 RTOS（如 FreeRTOS）：通常把中断都跑在 MSP 上，而任务各自用 PSP。 为什么 I2C 需要开漏输出 + 上拉电阻 开漏输出：只能拉低电平，不能输出高电平。 上拉电阻：总线空闲时保持高电平，实现线与。 原因：多个设备共享总线，避免总线冲突。 I2C总线挂死，如何排查 硬件排查：首先用示波器或逻辑分析仪查看SCL和SDA波形。若发现任一线被持续拉低（通常是SDA），则逐个断开从设备，定位故障源。同时检查电源稳定性和上拉电阻值（常用4.7kΩ）。 软件恢复：在代码中添加超时检测机制（例如等待ACK或总线释放时，设置100ms超时）。一旦超时，触发恢复序列：手动生成9-16个SCL时钟脉冲（通过GPIO模拟），强制从设备释放SDA线。 I2C上拉电阻阻值 标准模式（100kbit/s）：4.7kΩ~10kΩ 快速模式（400kbit/s）：2.2kΩ~4.7kΩ I2C通信出现低电平0.4V，高电平2.6V等中间电平 总线争抢：主机与从机同时试图控制SDA线（推挽输出模式争抢），或电平转换芯片方向控制切换不及时。 上拉电阻过大或电源异常：上拉电阻过大导致高电平无法在规定时间内被拉至VDD，或电源电压本身异常。 端口配置错误：MCU模拟I2C时，SDA引脚错误配置为推挽输出模式而非开漏输出。在推挽模式下，若主机输出高电平而从机试图拉低，会产生中间电平。 SPI 的工作模式有哪些 由 CPOL（时钟极性） 和 CPHA（时钟相位） 决定，共 4 种模式： CPOL（Clock Polarity，时钟极性） =0：时钟空闲时为 低电平 =1：时钟空闲时为 高电平 CPHA（Clock Phase，相位） =0：第 1 个边沿采样（第一个有效边沿采样数据） =1：第 2 个边沿采样（先在第一个边沿切换数据，第二个边沿采样） 模式 0：CPOL=0, CPHA=0 模式 1：CPOL=0, CPHA=1 模式 2：CPOL=1, CPHA=0 模式 3：CPOL=1, CPHA=1 SPI往屏上刷一个像素点，如何操作 初始化SPI总线和设备 设置地址窗口到(x, y) 发送像素颜色（RGB565两字节，高在前） RS232 和 RS485 的区别 RS232： 单端信号，点对点通信 距离短 抗干扰弱 逻辑“1”≈ −3V ~ −15V，逻辑“0”≈ +3V ~ +15V RS485： 差分信号，支持多点总线 距离远 抗干扰强 A、B 线电压差 +2V~+6V 表示逻辑 1，−2V~−6V 表示逻辑 0 STM32 上电后到 __main 的过程 硬件复位 上电/复位后，Cortex-M 内核自动完成： 取向量表第 0 项 → Initial_SP，装入 MSP。 取向量表第 1 项 → Reset_Handler 地址，跳转执行。 Reset_Handler（启动文件 startup_xx.s 中定义） 设置堆栈指针（MSP）、初始化中断向量表基址。 调用 SystemInit()： 配置系统时钟（HSE/PLL 等）。 配置 Flash 访问延时、总线分频。 初始化外设时钟（FPU、Cache、MPU 等）。 有的厂商库里叫 HardwareInit() / SystemClock_Config()，作用类似。 C 运行时环境初始化 数据段初始化：将已初始化全局变量从 Flash 拷贝到 RAM。 BSS 段清零：未初始化的全局/静态变量置 0。 可能还会初始化堆区指针。 调用 __main（C 库入口函数） 进一步完成 C/C++ 环境初始化： 运行全局/静态对象的构造函数（C++）。 设置标准库需要的运行环境。 最终调用 main()。 MSP 和 PSP 两个指针是什么，都在什么时候用 MSP (Main Stack Pointer)：主堆栈指针，复位后默认使用，主要用于中断和异常。 PSP (Process Stack Pointer)：进程堆栈指针，通常用于线程/任务。 FreeRTOS：任务使用 PSP，内核/异常使用 MSP。 中断能有返回值和参数吗？ 不能：中断服务函数由硬件调用，没有返回值和参数。 传参方法：使用全局变量、队列、消息通知等方式。 RAM、ROM 和 Flash 的区别 RAM（随机存取存储器）：读写速度快，断电数据丢失。 ROM（只读存储器）：出厂时写入，通常不可修改。 Flash：非易失存储，可擦写，常用于固件和数据存储。 Cache 是什么，Cache 一致性又是什么 Cache：CPU 与内存之间的高速缓存，加快数据访问速度，它既能存指令，也能存数据。 Cache 一致性：多核 CPU 或 DMA 等访问共享数据时，确保各个缓存的数据与主存一致。 解决方式：MESI协议 什么是 SMP（了解） SMP (Symmetric Multi-Processing，对称多处理)：多个 CPU 核心共享同一内存和 I/O，运行同一个操作系统。 特点：负载均衡、可并行执行任务，常用于多核处理器系统。 为什么单片机不使用 malloc 函数 资源限制： 单片机 RAM 很小（几 KB ~ 几十 KB），动态分配容易造成内存碎片。 实时性要求： malloc/free 的执行时间 不可预测，会破坏实时性。 可靠性问题： 容易导致内存泄漏，调试困难，系统长期运行不稳定 什么是中断嵌套 在处理中断 A 时，允许更高优先级的中断 B 打断执行。 优点：提高实时性。 缺点：过多嵌套可能导致栈溢出 如何处理 Flash 擦写寿命问题 磨损均衡 (Wear Leveling)：均匀分布写入次数。 文件系统优化：使用专门的嵌入式文件系统（如 FATFS + WL）。 缓存/批量写入：减少频繁擦写。 中断上下文和进程上下文的区别 进程上下文：任务在用户态或内核态下运行，可以休眠/调度。 中断上下文：响应硬件中断时执行，不能休眠，不能调用阻塞函数。 CAN 通信的缺点 速率较低（典型 1Mbps）。 帧长度有限（8字节数据）。 总线型拓扑，节点过多易导致仲裁延迟。 无内置安全机制，易受干扰。 FreeRTOS FreeRTOS 中使用的调度算法 基于优先级的抢占式调度。 相同优先级下，采用 时间片轮转。 协作式调度，任务不会被强制打断，只有当任务主动调用、阻塞或结束时，才会切换到其他就绪任务 FreeRTOS 的时间片的大小 时间片由 SysTick 定时器中断周期决定。 FreeRTOS 中任务的状态 就绪态（Ready） 运行态（Running） 阻塞态（Blocked）（等待事件或超时） 挂起态（Suspended）（不可被调度，需手动恢复） 终止态（Deleted） FreeRTOS 创建任务的方法和区别 xTaskCreate：普通创建任务。 xTaskCreateStatic：静态创建，用户提供栈和 TCB。 区别：静态方式更安全，避免动态内存分配。 FreeRTOS 的空闲任务以及它的作用 空闲任务 (Idle Task)：系统启动后自动创建。 默认优先级最低，永远存在。 作用： 回收已删除任务的资源。 执行用户定义的钩子函数（如省电模式）。 FreeRTOS 如何实现任务同步 信号量：用于任务间同步（包括二值信号量、计数信号量）。 互斥量：解决资源互斥。 队列：任务间数据传递。 事件组：多任务事件同步 FreeRTOS 中的 SVC、SysTick 和 PendSV 的作用和区别 SVC (Supervisor Call)：系统调用，进入内核模式。 系统启动时用 SVC_Handler 进入第一个任务（第一次上下文切换）。 相当于“进入内核”的入口。 SysTick：系统定时器中断，触发任务调度，给操作系统提供 时间基准 (tick)。 周期性触发 SysTick_Handler。 内核更新系统时钟（xTickCount）。 PendSV：最低优先级中断，用于任务上下文切换。 因优先级最低，确保不会打断其他更重要的中断。 保存当前任务寄存器（上下文），切换栈指针（PSP），恢复下一个任务的上下文。 要实现任务调度，可以只有systick中断吗 理论上可以： SysTick 定时中断里直接做任务切换（保存现场、恢复下一个任务）。 但这样会导致： 调度逻辑绑死在 SysTick，不灵活。 若有其它触发（信号量、事件、外设中断唤醒任务），也必须塞进 SysTick，复杂度高。 FreeRTOS 为什么要用 PendSV PendSV 可设为最低优先级，确保任务切换不会打断其他中断处理。 这样 上下文切换延迟最小，效率最高。 FreeRTOS 中的任务控制块是什么 任务控制块 (TCB, Task Control Block)：保存任务的所有信息。 主要内容： 栈指针（pxTopOfStack） 任务优先级（uxPriority） 任务状态（xStateListItem） 延时/阻塞时间（pxStack） 任务名（pcTaskName） FreeRTOS 如何实现任务切换，过程是什么 触发条件 周期性 SysTick 中断（时间片/延时到期）。 任务调用阻塞函数（如 vTaskDelay、xQueueReceive）。 高优先级任务进入就绪态。 切换机制 触发调度请求：SysTick 或 taskYIELD() 设置 PendSV 异常挂起。 保存上下文：PendSV_Handler 将当前任务的 CPU 寄存器压入其任务栈（PSP）。 调度器决策：根据优先级选择下一个要运行的任务。 恢复上下文：从新任务栈中弹出寄存器，恢复执行环境。 返回任务：CPU 跳转到新任务的断点继续运行。 FreeRTOS 有哪两种内存分配方式，有哪五种分配算法 方式： 静态分配：用户提供内存（更安全）。 动态分配：系统在堆中申请。 算法（heap_1 ~ heap_5）： heap_1：最简单，不允许释放，无内存碎片。 heap_2：允许释放，但可能产生碎片。 heap_3：直接调用 malloc/free。 heap_4：合并相邻空闲块，减少碎片。 heap_5：支持多个非连续内存区域碎片合并。 为什么在 FreeRTOS 中信号量、队列等设计了两套函数 FreeRTOS 提供 带阻塞时间 和 不带阻塞时间 两套接口。 原因： 带阻塞时间：任务可在等待期间挂起，避免忙等。 不带阻塞时间：适合中断服务例程 (ISR)，因为中断中不能阻塞。 vTaskDelay 和 vTaskDelayUntil 的区别 vTaskDelay：延时相对当前时间。 vTaskDelayUntil：延时基于绝对时间（适合周期性任务，抖动小）。 硬件电路 STM32最小单元板构成 MCU 时钟电路 复位电路 电源电路 外设接口 LDO稳压器（了解） 定义：LDO（Low Dropout Regulator）是一种 低压差线性稳压器，只能 降压，即输出电压 &lt; 输入电压。 比较 取样的输出电压 和 基准电压。根据差值调节功率管。 优点：电路简单，噪声低，纹波小，适合模拟/射频电路供电。 缺点：效率低（受输入/输出电压差限制），只能降压，不能升压。 单片机明明3.3V和5V就够用了，为什么还需要12V以上的供电 满足大功率负载的需求，拥有更强的电压驱动能力，比如电机； 实现强弱电隔离，保证系统稳定性。 其他 电脑1G的空间，malloc(1.2G) 为什么可能成功 虚拟内存机制：malloc 申请的是虚拟地址空间，不一定立刻分配物理内存。 实际情况：只要虚拟内存够（物理内存+交换空间），就能申请成功。 常用的调试方法有什么（了解） 软件调试：printf、日志输出、断点调试（gdb）。 硬件调试：示波器、逻辑分析仪、JTAG/SWD。 分析工具：perf、valgrind、strace、Wireshark。 gdb 常见命令（了解） 启动调试 gdb ./a.out → 以 gdb 打开可执行文件。 run (简写 r) → 开始运行程序。 断点控制 break main (简写 b main) → 在 main 函数入口设置断点。 break 10 → 在源码第 10 行设置断点。 delete → 删除断点。 单步调试 next (简写 n) → 单步执行，函数整体当成一步（不进入函数体）。 step (简写 s) → 单步执行，遇到函数会进入函数体。 finish → 运行到当前函数结束并返回。 程序控制 continue (简写 c) → 继续运行，直到下一个断点或程序结束。 quit (简写 q) → 退出 gdb。 信息查看 print x (简写 p x) → 打印变量 x 的值。 bt (backtrace) → 查看调用栈，显示当前函数调用路径。 info locals → 查看当前函数的局部变量。 list (简写 l) → 查看当前源码附近的代码。 说明 随缘更新，有问题跟我讲，有好的问题也可以分享。"},{"title":"Linux学习笔记","date":"2025-08-26T14:40:30.000Z","url":"/2025/08/26/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["Linux","/tags/Linux/"]],"categories":[["Linux","/categories/Linux/"]],"content":" Linux学习笔记(学习ing…) FOC、CANOpen和AutoSAR是什么，真不熟。 抽空还是再看看Linux吧。（未完待续）"},{"title":"嘉立创画板","date":"2025-08-25T13:00:30.000Z","url":"/2025/08/25/%E5%98%89%E7%AB%8B%E5%88%9B%E7%94%BB%E6%9D%BF/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]],"categories":[["嘉立创","/categories/%E5%98%89%E7%AB%8B%E5%88%9B/"]],"content":" 嘉立创画板 复习，继续复习；学不完，根本学不完~~~ 电容通交阻直 XC=1wC=12πfC X_C=\\frac{1}{wC}=\\frac{1}{2 \\pi fC} XC​=wC1​=2πfC1​ 频率越高，电容阻抗越小，越容易通过。 电感通直阻交 XL=wL=2πfL X_L=wL=2 \\pi fL XL​=wL=2πfL 频率越低，电感阻抗越小，越容易通过。 LDO Low dropout regulator，低压差线性稳压器 外围器件少，电路简单，成本低 负载响应快，输出纹波小，噪声少 效率低，输入输出压差不能太大 只能降压 电子电路学习笔记（14）——LDO(低压差线性稳压器)_ldo电路-CSDN博客 流程： V_out ↓ —&gt; V+↓ —&gt; V_b ↓ —&gt; V_eb ↑ —&gt; V_out ↑ DC/DC转换器 外围器件多，电路复杂，成本高 负载响应比LDO慢，输出纹波大，噪声大 效率高，输入电压范围宽泛 既能升压，也能降压 开关电源稳压器，利用电容、电感的储能特性，通过可控开关，进行高频开关动作，将输入的电能存储在电容（感）里，当开关断开，电能再释放给负载，提供能量。 降压DCDC被称为BUCK电路 升压DCDC被称为BOOST电路 (11 封私信) 一文搞懂DCDC基础知识 - 知乎 BUCK（斩压） 通过开关的通断，来斩断输入电压，把输入高电压“切”成脉冲，经过电感/电容平滑后得到较低的直流电压。 Vo=DVin，D∈[0,1]； V_o = DV_{in}， D∈[0, 1]； Vo​=DVin​，D∈[0,1]； BOOST（斩流） 开关管反复导通/关断，斩断电感电流，利用电感电流的连续性，在关断时把电感储能释放到负载，使输出电压高于输入。 Vo=1(1−D)Vin，D∈[0,1]； V_o = \\frac{1}{(1 - D)}V_{in}， D∈[0, 1]； Vo​=(1−D)1​Vin​，D∈[0,1]； 纹波 纹波：直流输出上叠加的周期性交流分量。 大小表示：用峰峰值 Vpp或有效值 Vrms 需求 设计一款基于STM32的开发板。 电源设计 PCB设计 主控 电源 Q：为什么需要模数地隔离，模拟为什么会受到数字地的攻击？ 模拟电路对电压、电流细微变化非常敏感，数字电路有大量高速翻转信号，容易产生噪声电压，如果直接混在一起，容易测量不准。 数字电路的电流是阶跃式/突变的；底线也不是理想零电阻，有阻抗；当数字电流在地线上流动时，会在阻抗上形成瞬间压降，模拟电路会以为基准电压在抖动，从而出现偏差。 接口 PCB 正面 反面 导出Gerber文件，进入下面网站领取优惠券，打板寄回！！！ 嘉立创-领券专区 总结 本次画板花了两周左右，做了块STM32的最小单元板，相较于之前画的平衡车板子复杂了许多，想die… 原理图，是真的好画；理解，也好理解，但太容易忘了，还是得记住电源电路用的是LDO和DC-DC PCB，是真的折磨；画完的那一刻，能够理解实习期间旁边的硬件工程师一直在那“发癫”的原因了（一边画，一边小嘴抹了蜜） 【大师篇】1-产品设计流程_哔哩哔哩_bilibili"},{"title":"Opencv基础学习笔记","date":"2025-08-07T12:40:30.000Z","url":"/2025/08/07/Opencv%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["Opencv","/tags/Opencv/"],["计算机视觉","/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/"]],"categories":[["Opencv","/categories/Opencv/"]],"content":" Opencv基础学习笔记 Opencv基础部分，以前学过，做个笔记用于复习； 当然我建议学C++版本，更齐全，Python版本的课程教学内容缺太多了； 这里只看到第35节的基础部分就结束了（因为之前只学到这） [opencv_C++] 入门强推！！！【B站最全】_哔哩哔哩_bilibili 图像基本操作 BGR：Blue Green Red HSV：Hue(色调) Satration(饱和度) Value(明度) Shape：[500, 500, 3] — [h, w, RGB] 图像读取 cv2.IMREAD_COLOR：彩色图像 cv2.IMREAD_GRAYSCALE：灰度图像 图像保存 视频读取 截取部分图像数据 颜色通道提取 调整对比度和亮度 绘制基本图形和文本 边界填充 改变图片最外围的边框 BORDER_REPLICATE：复制法，复制最边缘像素。 BORDER_REFLECT：反射法，对图像中的像素进行镜像复制：fedcba|abcdefgh|hgfedcb BORDER_REFLECT_101：反射法，以最边缘像素为轴，对称，gfedcb|abcdefgh|gfedcba BORDER_WRAP：外包装法cdefgh|abcdefgh|abcdefg BORDER_CONSTANT：常量法，常数值填充。 图像融合 图像阈值与平滑处理 图像阈值 type为如下操作 cv2.THRESH_BINARY 超过阈值部分取maxval，其他取0 cv2.THRESH_BINARY_INV 超过阈值部分取0，其他取maxval cv2.THRESH_TRUNC 大于阈值部分设为阈值，其他不变 cv2.THRESH_TOZERO 大于阈值部分不变，其他为0 cv2.THRESH_TOZERO_INV 大于阈值部分为0，其他不变 常常配合createTrackbar使用 图像滤波 滤波的意义是为了让图片更加平滑，减少噪声。 中值滤波 双边滤波 双边滤波计算某一个像素点的新值时，不仅考虑距离信息（距离越远，权重越小），还考虑色彩信息（色彩差别越大，权重越小) 图像形态学 腐蚀（变黑） 去除小型噪声、分离粘连物体、细化边缘 膨胀（变白） 连接断裂的物体部分、填充物体内部的小孔或空洞、扩大物体尺寸、去除孤立噪声点 开运算与闭运算 开运算：消除细小噪声与孤立点、分离粘连物体、平滑物体外轮廓 作用：医学图像中去除组织切片的小斑点、文本识别前清除文档扫描件的墨渍或断裂笔画 闭运算：填充内部空洞与缝隙、连接临近物体、平滑内轮廓 作用：工业检测中填补零件表面的微小缺陷、遥感图像中连接断裂的道路或河流 形态学梯度计算 边缘检测、特征提取、图像增强与锐化、光照估计与校正 目标分割：结合梯度信息与区域生长算法，实现语义分割 礼帽与黑帽 突出图像中的局部亮暗特征或校正光照不均匀 礼帽 = 原始输入 - 开运算 突出原图像中更亮的局域 作用：提取比周围背景更亮的细小物体、消除不均匀光照的影响，增强微弱目标特征 黑帽可以用于提取原图片里面的有特征的线/数字 黑帽 = 闭运算 - 原始输入 突出原图像中更暗的局域 作用：提取比周围更暗的区域、通过闭运算填充亮背景中的暗水印，再减去原图实现去水印 提取图片中水平线和垂直线 读取图片，转灰度图像cv_BGR2GRAY 转二值图像adaptiveThreshold 获取形状和尺寸的结构元素getStructuringElement Scharr算子 laplacian算子 单独使用效果差，需配合高斯滤波（LOG算子）以抑制噪声 处理流程： 高斯模糊-去噪声GaussianBlur() 转换为灰度图像cvtColor() 拉普拉斯-二阶导数计算Laplacian() 取绝对值，显示结果convertScaleAbs() 算子对比 可以看出Scharr要比Sobel显示的边缘更多，而Laplacian显示的更少 边缘检测 Canny边缘检测 处理流程： 高斯模糊，用于平滑图像，滤除噪声 灰度转换 计算图像中每个像素点的梯度强度和方向 非极大值（Non-Maximum Suppression）抑制，消除边缘检测带来的杂散响应 应用双阈值（Double-Threshold）检测来确定真实的和潜在的边缘。 通过抑制孤立的弱边缘最终完成边缘检测。 高斯滤波器 计算梯度和方向 非极大值抑制 线性插值法：distance(g1, g2)表示两点之间的距离 ​ 设g1的梯度幅值M(g1), g2的梯度幅值M(g2) ​ 则dtmp1可以得到：M(dtmp1) = w * M(g2) + (1 - w) * M(g1) ​ 其中w = distance(dtmp1, g2) / distance(g1, g2) 双阈值检测 梯度 &gt; maxVal，则为maxVal；梯度 &lt; minVal，则为minVal 霍夫圆 前提：边缘检测已经做完 把原图做一次Canny 边缘检测，得到边缘检测的二值图 对原始图像执行一次 Sobel 算子，计算出所有像素的邻域梯度值 初始化圆心空间 N(a, b)，令所有的 N(a, b)=0。若要求圆心在图像中，则a，b值的范围分别对应图像的宽高，N(a,b)表示一共有a * b个 遍历 Canny 边缘二值图中的所有非零像素点，沿着梯度方向 (切线的垂直方向，根据Sobel 算子计算出的垂直梯度及水平梯度得来)固定搜索半径范围画线，将线段经过的所有累加器中的点 (a,b) 的 N(a,b)+=1。 统计排序 N(a,b)，得到可能的圆心（N(a,b) 越大，越有可能是圆心） 大白话：给定一个半径R，对于所有的白色点，都i会进行半径为R的画圆；颜色越深，越令人信服。 opencv —— HoughCircles 霍夫圆变换原理及圆检测 - 狂奔的小学生 - 博客园 opencv 十一 霍夫圆检测原理及高级使用案例（含优化步骤）-CSDN博客 像素重映射 重映射是从图像中的一个位置获取像素并将其放置在新图像中的另一位置的过程。 图像金字塔 图像金字塔是指一组图像且不同分辨率的子图集合，它是图像多尺度表达的一种，以多分辨率来解释图像的结构，主要用于图像的分割或压缩。 实际应用中需注意： 金字塔层数：通常4-6层，过多会导致信息冗余。 结构元素：高斯核大小影响平滑效果（常用5×5） 图像增强：分层调整细节与对比度 图像融合：无缝拼接不同图像 目标检测：多尺度定位物体 图像压缩：分层存储与渐进传输 噪声抑制与光照校正 向下采样方法（缩小） 向上采样方法（放大） 拉普拉斯金字塔：lap = img2 - down 直方图与傅里叶变换 直方图 它是一种提高图像对比度的方法，拉伸图像灰度值范围 直方图的横轴表示亮度，从左到右表示亮度从低到高 直方图的纵轴表示像素数量，从下到上表示像素从少到多。 直方图在某个亮度区间的凸起越高，就表示在这个亮度区间内的像素越多 若直方图的凸起主要集中在左侧，则说明这张照片的亮度整体偏低 作用： 图像分析与诊断 亮度与对比度评估 曝光检测 图像增强 直方图均衡化 图像分割与阈值处理 阈值选择 掩膜区域分析 颜色分析与处理 通道分离统计 颜色校正 图像匹配与检索 相似度比较 特征提取 四种基本类型： RGB直方图 通道直方图 明度直方图 颜色直方图 mask功能：一张图片有时候不需要统计整张图片，而是统计最中间或者做边界的一部分图片，那么就可以在参数中加入mask，原理是选中的部分为1，非选中的部分为0。 直方图均衡化 直方图均衡化会使图片突出的地方更加突出，可以增加图片的特征 计算原理：新灰度值 = 旧灰度值 * 累计概率 累计概率 = 当前灰度值的概率 + 小于当前灰度值的概率 均衡化后的图片亮的地方更加亮，暗的地方更加暗，使图片的立体感更加强烈，但也有一定问题（自己搜吧） 直方图比较方法 首先把图像从RGB色彩空间转换为HSV色彩空间，cvtColor 计算图像的直方图，然后归一化到[0 ~ 1]之间，calcHist和normalize 使用下列四方法之一进行比较，compareHist Correlation：相关性比较 Chi-Square：卡方比较 Intersection：十字交叉性 Bhattacharyya distance：巴氏距离 模板匹配 模板在原图像上从原点开始滑动，计算模板与（图像被模板覆盖的地方）的差别程度 假如原图形是AxB大小，而模板是axb大小，则输出结果的矩阵是(A-a+1)x(B-b+1) TM_SQDIFF：计算平方不同，计算出来的值越小，越相关 TM_CCORR：计算相关性，计算出来的值越大，越相关 TM_CCOEFF：计算相关系数，计算出来的值越大，越相关 TM_SQDIFF_NORMED：计算归一化平方不同，计算出来的值越接近0，越相关 TM_CCORR_NORMED：计算归一化相关性，计算出来的值越接近1，越相关 TM_CCOEFF_NORMED：计算归一化相关系数，计算出来的值越接近1，越相关 图像轮廓 轮廓特征 轮廓周围绘制矩形 用最少的线来代替，在几个点之间的直线，如果能用更少的点来表示，就采用更少的点 凸包（Convex Hull） 图像矩 OpenCV-Python快速入门（十一）：图像矩_python图像的矩-CSDN博客 点多边形测试 傅里叶变换 高频：变化剧烈的灰度分量，例如边界 低频：变化缓慢的灰度分量，例如一片大海 滤波 低通滤波器：只保留低频，会使得图像模糊 高通滤波器：只保留高频，会使得图像细节增强 项目 本科参与的一个项目，其实不难。 描述：给定一个绿色圆形标靶，测出其与相机的角度和距离；再给电机反馈这些参数。 相机标定法，借助matlab以及相机对着棋盘进行标定，获得如下参数。 **相机内参：**焦距（fx，fy）；主点坐标（cx，cy）；畸变系数（径向畸变k1，k2，k3和切向畸变p1，p2） 相机内参：旋转矩阵（3x3）；平移向量（3x1） "},{"title":"MQTT协议","date":"2025-08-04T15:39:36.000Z","url":"/2025/08/04/MQTT%E5%8D%8F%E8%AE%AE/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["MQTT","/tags/MQTT/"]],"categories":[["嵌入式","/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"]],"content":" MQTT协议 MQTT是应用层协议，基于传输层的TCP发送。 通常端口：1883 客户端给服务端发送，表示发布 服务端给客户端发送，表示推送 ClientID是用户名Username和密码Password相同下之下的多个角色，有记忆 配置环境 下载安装包 资料下载地址:  提取码: n25a 安装emqx作为服务端，打开PowerShell 输入bin/emqx start，接着在浏览器打开127.0.0.1:18083，网页默认用户名和密码是admin/public 使用网络调试助手和mqttx作为客户端 MQTT报文 剩余长度 剩余长度 = 可变报头长度 + 负载长度 可变长编码（1-4个字节）（128进制-----只要每个Byte的最高位为1，就继续往下读） 服务质量等级 0：不需要签收，开销小 1：需要1次签收 2：需要一次签收，并且需要一次回访 CONNECT CONNACK 第1个字节是 连接确认标志，位7-1是保留位且必须设置为0。 第0 (SP)位 是当前会话（Session Present）标志，即CONNECT的Clean Session。 DISCONNECT DISCONNECT报文没有可变报头和有效载荷。 SUBSCRIBE 剩余长度等于可变报头的长度（2字节）加上有效载荷的长度。 报文标识符，需要订阅和确认反馈一致，具体可以自己定义。 SUBACK 剩余长度等于可变报头的长度加上有效载荷的长度。 0x80 - Failure（失败） UNSUBSCRIBE 剩余长度等于可变报头的长度加上有效载荷的长度。 UNSUBACK 剩余长度 = 0x02 PING PING报文没有可变报头和有效载荷。 PINGRSP PINGRSP报文没有可变报头和有效载荷。 报文分类 Qos=0的PUBLISH：发送方用到PUBLISH报文，没有接收方的事 Qos=1的PUBLISH：发送方用到PUBLISH报文，接收方用PUBACK报文表示签收 Qos=2的PUBLISH：发送方先用到PUBLISH报文，接收方用PUBREC报文表示签收；发送方再用PUBREL报文开启回访，接收方用PUBCOMP报文表示回访确认 PUBLISH 在Qos=0时，DUP设置为0，即不重发； RETAIN = 1，Qos=0的带保留功能，即保留本条PUBLISH报文（最重要的，只有一条，后面关注的都会立即看到）。 有效负载就是需要发送的数据 有效载荷的长度计算：用固定报头中的剩余长度字段的值减去可变报头的长度。 Qos=0 Qos=1 没有签收，会一直发送请求，签收后就不会再发。 Qos=2 会话清理与保留 1：清理会话：没有记忆，不保留订阅。每次登陆后需要重新订阅需要的TOPIC。收不到离线消息。 0：保留会话：有记忆，不用重新订阅TOPIC。离线期间的消息（PUBLISH）我们可以收到。 CONNECT的SP Clean Session = 1 — SP= 0 Clean Session = 0，不一定 C2 C0 C0 C0 C0 0 0 1 1 1 遗嘱 很好，我选择跟它一起G了 报警功能，非正常断线（正常断线用14号报文，这里是直接断开TCP/被踢下线） 服务器会向订阅了遗嘱TOPIC的客户端推送遗嘱PUBLISH报文 大白话：B订阅了A，A非正常断线，则B会收到A的遗嘱报文 USER002需要再订阅WILL001的遗嘱TOPIC WILL001（遗嘱TOPIC） WILL001（PUBLISH报文数据） (可以不一样，设置一样是为了方便) 资料 【2025新版】MQTT协议手把手详解 EMQX自建服务器 所有报文功能 逐个字节构建分析与测试_哔哩哔哩_bilibili (11 封私信) MQTT协议，终于有人讲清楚了 - 知乎 MQTT协议详解(完整版)-CSDN博客"},{"title":"基于Bootloader的简易桌面闹钟","date":"2025-07-27T03:30:30.000Z","url":"/2025/07/27/%E5%9F%BA%E4%BA%8EBootloader%E7%9A%84%E7%AE%80%E6%98%93%E6%A1%8C%E9%9D%A2%E9%97%B9%E9%92%9F/","tags":[["STM32","/tags/STM32/"],["Bootloader","/tags/Bootloader/"],["项目","/tags/%E9%A1%B9%E7%9B%AE/"],["FreeRTOS","/tags/FreeRTOS/"]],"categories":[["项目","/categories/%E9%A1%B9%E7%9B%AE/"]],"content":"在这份项目里，Bootloader使用之前Bootloader学习笔记里做的样例。 可以说是为了这碗醋，包了这碗饺子 简易桌面闹钟 FreeRTOS移植：超详细的FreeRTOS移植全教程——基于stm32_freertos移植教程-CSDN博客 时钟方面需要改用FreeRTOS的SysTick，否则系统会卡死 实物 整体结构 OLED示意图 此处OTA的值存储在AT24C02的0xF0-0XF3字节处（AT24C02总共256字节） 简易模式 PA2进入多功能模式 PA0调整城市显示 PC13调整OTA状态 PB10可以重启设备 支持震动自动切换多功能模式 多功能模式 PA0进入简易模式 温湿度数据1s刷新一次 加速度0.5s刷新一次 10s无操作自动进入简易模式 SysTick、SVC、PendSV SysTick_Handler - 系统时钟 就像心跳，定期检查是否需要切换任务 频率固定，系统运行期间持续工作 负责时间管理和调度触发 SVC_Handler - 系统启动器 就像点火器，只负责启动第一个任务 只调用一次，启动后就不工作了 从特权模式切换到用户模式 PendSV_Handler - 任务切换器 就像交通指挥员，负责安排哪个任务先运行 需要切换时才工作，优先级最低 在用户模式下进行任务切换 Q：为什么使用PendSV_Handler来切换任务？ Pend → 可挂起的 SV → 系统服务 中断优先级最低；不影响其他中断 只能软件触发，可控；CPU不会意外触发它 硬件自动保存部分上下文；减少软件负担 特性 SysTick_Handler SVC_Handler PendSV_Handler 全称 System Tick Handler Supervisor Call Handler Pending Service Handler 中文名 系统滴答中断 超级调用中断 挂起服务中断 触发方式 硬件定时器 软件调用SVC指令 软件触发PendSV 新添内容 one-wire协议 One Wire（单线）总线协议，它只需要一根数据线就能实现双向通信，大大简化了硬件连接。 上拉电阻： 通常4.7kΩ，确保总线空闲时为高电平 开漏输出： 支持线与逻辑 【通信协议】单总线协议详解——以DHT11为例_单总线通信协议-CSDN博客 delay 裁剪FreeRTOS FreeRTOS FreeRTOS高优先级优先，具有优先级反转机制，注意config里的总优先级不能低于4。 Ucos和RT-Thread是低优先级优先 通信路径表 运行效果 Xmodem工具使用xcom（这东西老是丢包，下载操作还有BUG，丢包了再下载进去的是错的，以后再修改吧） 在简易模式和多功能模式均可以调整OTA_flag；若为0，可以进行OTA更新，若为1，则自动进入系统。 本实验通过【5】向外部FLASH的第1块下载简易模式（MODE=0），第2块下载简易+多功能模式（MODE=1） 后续借助【7】重启、PB10重启和【6】下载外部FLASH等功能，对第1块和第2块外部Flash片区内容进行实验测试，均符合预期效果。 【1】擦除和【2】下载，测得没有问题；【3】和【4】也是测试通过。 总结 整体代码太冗长了，这里就只把核心部分贴上去了。 还有，记得调整两个0x5000，不然程序是运行不了的。"},{"title":"CAN通信学习","date":"2025-06-12T03:40:30.000Z","url":"/2025/06/12/CAN%E9%80%9A%E4%BF%A1%E5%AD%A6%E4%B9%A0/","tags":[["CAN通信","/tags/CAN%E9%80%9A%E4%BF%A1/"],["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]],"categories":[["嵌入式","/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"]],"content":" CAN通信笔记 CAN（Controller Area Network Bus），控制局域网总线。 基本特征 两根通信线（CAN_H、CAN_L），无需共地 差分信号通信，抗干扰能力强 高速CAN（ISO11898）：125k~1Mbps，&lt;40m 低速CAN（ISO11519）：10k~125kbps，&lt;1km 异步，无需时钟线，通信速率由双方协定 半双工，可挂载多设备，多设备同时发送通过仲裁判断先后 11/29位报文ID，用于区分消息功能，同时决定优先级**（小的优先）** 可配置1~8字节的有效载荷 可实现广播式和请求式两种传输 应答、CRC校验、位填充、位同步、错误处理等特性 硬件电路 两个终端电阻的意义 防止回波反射 没有设备操作时，将两根差分线电压“收紧”，使其电压一致 （高速CAN的电阻阻值小，所以收紧更快，但能耗更大） 电平标准 CAN总线使用差分信号,即（Vcan_H - Vcan_L） 高速CAN规定 电压差为0V表示逻辑1（隐性电平） 电压差为2V表示逻辑0（显性电平） 低速CAN规定 电压差为-1.5V表示逻辑1（隐性电平） 电压差为3V表示逻辑0（显性电平） 位填充 规则：发送方连续发送5个相同电平后，自动追加一个相反电平的填充位；接收方检测到填充位时，会自动移除，恢复原始数据。 例如： 即时发送： 100000110 10000011110 实际发送： 1000001110 1000001111100 实际接收： 1000001110 1000001111100 移除填充： 100000110 10000011110 位填充的作用： 增加波形的定位信息，利于接收方执行“再同步”，防止波形长时间无变化，当只接收方不能精准掌握数据采样时机 将正常数据流与“错误帧”、“过载帧”区分开 保持CAN总线在发送正常数据流时的活跃状态，防止被总线误认为空闲 帧格式 帧类型 用途 数据帧 发送设备主动发送数据 遥控帧 接收设备主动请求数据 错误帧 某个设备检测出错误时向其他设备通知错误 过载帧 接收设备通知其尚未做好接收准备 帧间隔 用于将数据帧及遥控帧与前面的帧分隔开 帧ID值越小，优先级越高 数据帧 SOF（Start of Frame）：帧起始，表示后面一段波形是传输的数据位 ID（Identify）：标识符，区分功能，决定优先级 RTR（Remote Transmission Request）：数据帧（0），遥控帧（1）。 IDE（Identifier Extension）：用于区分标准格式（0）和扩展格式（1） r0/r1（Reserve）：保留位，为后续留空间 DLC（Data Length Code）：数据长度 ACK槽，发送方（1），接收方（0），如果没有接收方就（1），告知发送方 ACK槽允许多个接收方共同拉开总线 SRR：替代RTR的位，用于保证标准格式高于扩展格式的优先级 EOF（End of Frame）：帧结束，表示传输完毕 Q：为什么DLC是4位，但可以描述0-64个Byte？ 0-8 对应 0-8Byte 9-15 分别对应 12、16、20、24、32、58、64Byte 遥控帧 遥控帧无数据段，RTR为隐形电平1，其他部分与数据帧相同 错误帧 总线上所有设备都会监督总线数据，一旦发现“位错误”、“填充错误”、“CRC错误”、“格式错误”、“应答错误”，这些设备就会发出错误帧来破坏数据，同时终止当前的发送设备。 主动错误会破坏别人的，被动错误会破坏自己的 过载帧 接收方收到大量数据而无法处理时，其可以发出过载帧，延缓发送方的数据发送，以平衡总线负担，避免数据丢失。 帧间隔 在 CAN 总线上，每一帧报文（数据帧、远程帧、错误帧、过载帧）结束之后，不会立刻开始下一帧，中间必须插入一段 固定格式的空隙，这就是 帧间隔。固定是3个隐性“1”。 位同步 CAN总线没有时钟线，总线上所有设备通过约定波特率来确定每一位数据位时长 发送方以约定的位时长，每隔固定时间输出一个数据位 接收方以约定的位时长，每隔固定时间采样总线的电平，输入一个数据位 理想状态下，接收方能依次采样到发送方发出的每个数据位，且采样点位于数据位中心附近 位时序 为了能够灵活调整每个采样点的位置，使采样点对齐数据位中心附近，CAN总线对每一个数据位的时长进行更细划分，分为同步段（SS）、传播时间段（PTS–Propagation Time Segement）、相位缓冲段1（PBS1）和相位缓冲段2（PBS2），每隔段由若干个最小时间单位（Tq）构成 SS = 1Tq PTS = 1 ~ 8 Tq PBS1 = 1 ~ 8 Tq PBS2 = 2 ~ 8 Tq 最开始就没有同步时序。 硬同步(初始位置同步) 每个设备都有一个位时序计时周期，当某个设备（发送方）率先发送报文，其他所有设备（接收方）收到SOF的下降沿时，接收方会将自己的位时序计时周期拨到SS段，与发送方的位时序计时周期保持同步； 硬同步只在第一个下降沿（SOF下降沿）有效； 经过硬同步后，若发送方和接收方的时钟几乎没有误差，则后续所有数据位的采样点必然都会对齐数据位中心附近 最开始接收采样正确，但仍有误差，随着误差积累，采样点逐渐偏离。 再同步 若发送方或接收方的时钟有误差，随着误差积累，数据位边沿逐渐偏离SS段，则此时接收方根据再同步补偿宽度（SJW）通过加长PBS1段，或缩短PBS2段，调整同步 再同步可以发生在每一个下降沿之后的每个数据位跳变边沿 SJW = 1 ~ 4 Tq 如果误差值小于等于SJW指定值，则误差几个Tq，补偿几个Tq，否则补偿SJW SJW是补偿的上限，防止波形中的噪声对位时序造成过大影响。 波特率的计算 波特率 = 1 / (一个数据位的时长) = 1 / (Tss + Tpts + Tpbs1 + Tpbs2) 举例 SS = 1 Tq，PTS = 3 Tq，PBS1 = 3 Tq，PBS2 = 3 Tq；Tq = 0.5 us 波特率 = 1 / (0.5us + 1.5us + 1.5us + 1.5us) = 200kbps 仲裁 CAN总线只有一对差分信号线，同一时间只能有一个设备操作总线发送数据，如果多个设备同时有发送需求，该如何分配？ 规则1——先占先得 若当前已经有设备操作总线发送数据帧/遥控帧，则其他任何设备不能再同时发送数据帧/遥控帧（可以发送错误帧/过载帧破坏当前数据） 任何设备检测到连续11个隐性电平（帧间隔），即认为总线空闲，只有总线空闲，设备才可以发送数据帧/遥控帧 一旦有设备正在发送数据帧/遥控帧，总线就会变活跃状态，必然不会出现连续11个隐性电平（连续6个就是错误帧/过载帧），其他设备自然也不会破坏当前发送 若总线活跃，其他设备有发送需求，则需要等待总线变空闲，才能执行发送需求 规则2——非破坏性仲裁 根据ID号（仲裁段）进行非破坏性仲裁，ID号小的取到总线控制权，ID号大的仲裁失利将转为接收状态，等待下一次总线空闲时再尝试发送。 实现非破坏性仲裁两个要求： 线与特性：总线上任何一个设备发送显性电平0时，总线就会呈现显性电平0，只有当所有设备都发送隐性电平1时，总线才会呈现隐性电平1；即0 &amp; X = 0， 1 &amp; 1 = 1. 回读机制：每隔设备发出一个数据位后，都会读回总线当前的电平状态，以确认自己发出的电平是否被真实发送出去了。根据线与特性，发出0，读回必然是0，但是发出1读回不一定是1.（此刻是还在仲裁段，发出数据1，读回数据0，表示有设备在占用总线，ID小的优先） 优先级补充 数据帧和遥控帧ID号一样时，数据帧的优先级高于遥控帧 标准格式的11位ID号和扩展格式29位ID号的前11位系统，标准格式的优先级高于扩展格式（SSR必须始终为1） 错误类型 错误有5种：位错误、填充错误、CRC错误、格式错误、应答错误 为了防止某个设备发疯，一直认为别的设备发送是错误帧，引入错误状态 错误状态 主动错误状态的设备正常参与通信并检测到错误时发出主动错误帧（会破坏别的数据帧） 被动错误状态的设备正常参与通信但检测到错误时只能发出被动错误帧（不会破坏别的数据帧） 总线关闭状态的设备不能参与通信 每隔设备内部管理一个TEC和REC，根据TEC和REC确定直接的状态 STM32 CAN外设 波特率最高可达1Mbps 3个可配置优先级的发送邮箱 —— 发送缓冲区 2个3级深度接收FIFO —— 接收缓冲区 14个过滤器组 —— 过滤无关报文 时间触发通信、自动离线恢复、自动唤醒、禁止自动重传、接收FIFO溢出处理方式可配置、发送优先级可配置、双CAN模式 标识符过滤器 每个过滤器的核心由两个32位寄存器组成：R1[31:0]和R2[31:0]；x = 0,…,13 FSCx：位宽设置；置0，16位；置1，32位 FBMx：模式设置；置0，屏蔽模式；置1，列表模式 FFAx：关联模式；置0，FIFO 0；置1，FIFO 1 FACTx：激活设置；置0，禁用；置1，启用、 （TIP：第二行Mask的0x700 ---- 0111 0000 0000，表示接收的第2到4位必须和ID相同） 测试模式 工作模式 位时间特征 TIP：STM32里面PBS1和PBS2合并成一个BS段 中断 "},{"title":"Bootloader学习笔记","date":"2025-05-09T19:07:16.000Z","url":"/2025/05/10/Bootloader%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["STM32","/tags/STM32/"]],"categories":[["嵌入式","/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"]],"content":" Bootloader+IAP 简要说明 本学习笔记主要包括STM32F103C8T6下的Bootloader+IAP Bootloader：用于更新APP的程序 IAP：在设备运行时，由Bootloader引导对自身程序擦写 OTA：无线通信将新的固件下载到设备中（Over The Air） 说明 使用的APP数据，OTA标志位，版本号存储在AT24C02 多个备份APP数据存储在W25Q64 Q：已经操作了AT24C02和W25Q64，为什么还要操作单片机上的SRAM？ AT24C02和Flash读写太慢，跟不上CPU的速度，SRAM是临时、高速的数据交换区。 整体流程图 这里说明下没有Running APP那一环，Visio源文件找不到了 分区 A区存放APP，B区存放Bootloader程序。OTA_Flag表示是否更新APP，存放在AT24C02中 ❌️ | A | B | ------&gt;程序运行后，先进入A区；若OTA_Flag=1开始更新数据，当正在更新的A区出现异常退出，下一次上电后运行A发现程序不全，无法再进入B区进行后续更新A区的操作，并且之前的A区程序有出现问题，悲报，成砖头了。 ✔️ | B | A | ------&gt;程序运行后，先进入B区，观测到OTA_Flag=1后对A区进行数据更新，即使异常退出，后续仍然可以进入B区对A区进行更新，更新完成后置OTA_Flag=0。 方案 🦝DMA + 空闲中断 在无需CPU帮助下，DMA负责外设与寄存器之间数据传输 空闲中断（IDLE）是串口通信中判断“接收完成”的经典方式 Q：如何消除空闲中断？ 读一次标志位寄存器，再读一次数据寄存器，即可消除空闲中断 环形缓冲区：数据传输过程中，接收速度和处理速度可能不一致，因此需要缓冲区先保存数据，防止数据丢失；一维数组，确认单次接收最大量，防止出现越界问题 Q：如何判断Read和Write的状态问题？ 预留一个空位。Read == Write，即空；（Write + 1）% N == R，即满； 通过一个count计数，W是生产者，R是消费者；每次W就count+1，每次R就count-1；0&lt;=count&lt;=Max_Count。 SE指针对（环形缓冲）：缓冲区是一维数组，总长度为 2048 Byte，划分为10个数据块，每个数据块200 Byte。通过两个指针 IN（生产者指针）和 OUT（消费者指针）管理缓冲区的读写操作。当 IN ≠ OUT 时，表示缓冲区中存在待处理的数据包。指针每次移动一个数据块（200字节），当指针到达缓冲区末尾时自动回卷到起始位置，实现环形缓冲机制。 ❗TIP：每次接收后，都需要判断剩余空间，以防内存不足，及时回卷；需要记录已经存放的累加值 编程 STM32F103C8T6使用外部高速时钟HSE，8MHz；通过PLL（倍频锁相环）可以达到72MHz 串口与DMA .h程序 配置串口和DMA 设置相关外设时钟 初始化GPIO(IO分区,MODE,频率,IO口) 配置串口（初始化，波特率，校验，数据位长度，停止位个数，接收发情况） 配置串口DMA 打开串口中断（IDLE为空闲中断） 调用其他功能函数 使能串口 串口空闲中断函数 检测空闲中断 消除空闲中断标志位（只有读标志位寄存器和数据位寄存器才能将空闲标志位清除） 在空闲中断中读取串口DMA增添数据的长度(DMA,通道) — counter += (总量 - 剩余空闲值) 设置缓冲区的IN指针 Disable DMA，重新配置DMA（DMA，通道，大小，地址），保证不出现完成状态，再使能DMA 要一直让DMA读取数据，直到出现空闲中断才会停止，因此不会出现完成状态 编写新的Printf函数 I2C 软件I2C，延时部分需要自己重新设计 .h程序 Delay 初始化、START和STOP信号 硬件I2C，开启时钟 配置GPIO（PB6，PB7，开漏模式） 配置SCL和SDA两条线 起始信号：SCL高电平，SDA从高电平变为低电平 停止信号：SCL高电平，SDA从低电平变为高电平 数据信号：SCL高电平，SDA保持不变；SCL低电平，SDA电平可以修改 应答信号：SCL高电平，SDA低电平，应答，否则，非应答 发送一个字节 读取一个字节 等待从机ACK AT24C02 I2C通信，设备地址：1 0 1 0 E2 E1 E0 R/非W； 读R=1，0XA1； 写W=0，0XA0； 按字节写入 AT24C02共16页，一页16字节，共256字节；存在回卷问题 写入 Byte Write Page Write 读取 SPI 外部FLASH型号为W25Q64，使用硬件SPI 配置SPI0时钟，相关GPIO开启 复位SPI外设 配置SPI结构体成员（主从模式，发送类型（全双工），一帧大小，硬件/软件，大端/小端（大端），工作方式（极性（上下）/相位（一二），从机决定），传输速度） 初始化SPI 使能SPI 数据收发 SPI_I2S_FLAG_TXE表示发送区空了，SPI_SPI_FLAG_RXNE表示接收区不为空。切记全双工，有发就有收！ W25Q64 状态寄存器 主要看S0 — BUSY 指令表 相关程序 SPI+Flash需等待Busy状态，先读取状态寄存器地址，后随便写入其它（此时写入什么都不重要，主要获取寄存器中的数值），打开片选，使能Write再关闭 擦除64KB W25Q64总共8MB = 8 * 1024KB，一次擦除64KB，可得共计8 * 1024 / 64 = 128个Block 页写入256Byte 页地址 = page * 256 Byte，每次从页地址开始写入256 Byte，页地址总长24位 读取数据 STM32的FLASH Flash擦除后为0xFF 擦除Flash Flash一页1KB，下面函数实现一次擦除num页数据 流程： Flash开锁 确认地址，擦除地址数据 Flash锁定 写入Flash 一次写入num个4字节数据，地址自动递增 流程： Flash开锁 将数据写入对应地址 Flash锁定 Bootloader功能实现 AB分区规划 1个扇页1KB，A区起始位置：0x 0800 5000， 单片机RAM位置：0x20000000 ~ 0x20004FFF STM32F103C8T6 64KB 扇页 B区 20KB 0 ~ 19 A区 44KB 20 ~ 63 注意点 问题 解答 谁将OTA_Flag打勾？ A区负责控制，标志位存放在24C02 什么时候OTA_flag打勾 A区下载完毕之后 OTA时，最新版本的程序文件下载到哪？ 分片下载，共计256片塞入W25Q64（一页256Byte，共256页） OTA时，最新版本的程序文件如何下载？下载多少？ 服务器下发程序大小，分片下载到W25Q64 下载多少这个变量用不用保存？ 需要，保存到24C02之中 发生OTA事件时，B区如何更新A区 从W25Q64读取数据，写入A区Flash OTA宏定义 OTA读取标志位 OTA保存关键变量到AT24C02 引导更新OTA (从下面向上看) 分区跳转两大关键SP、PC设定 Cortex-M3有R0-R12通用寄存器，R13有MSP（主堆栈指针）和PSP（进程堆栈指针）(保存现场和恢复现场的指针)，R14是LR（连接寄存器，保存子函数之间跳转的返回值），R15是PC（程序计数器） Q：MSP指针和PSP指针，分别在什么情况下使用？ MSP (Main Stack Pointer) 系统默认的栈指针。 上电复位后，CPU 自动把 MSP 当栈指针。 通常用来处理 异常 / 中断 / 内核级任务。 PSP (Process Stack Pointer) 需要软件设置（CONTROL 寄存器里切换）。 通常用来跑 用户线程 / 普通任务。（FreeRTOS里的每个任务栈） 20(A区起始页) * 1024 = 20480 —&gt; 0x00005000 + 0x08000000 = 0x08005000，此为A区开始时SP地址 A区起始位置0x08005000 + 4(32位的指针是4Byte)，此为A区开始时PC地址 BootLoader事件 (从上面向下看) 主程序 Xmodem协议 Xmodem使用SecureCRTP软件配置连接串口通信，它相较于Ymodem的区别是具有更小的Package长度 格式 Byte1 Byte2 Byte3 Byte4 ~ Byte131 Byte132 ~ Byte133 Start of Header(SOH) Packet Number ~(Packet Number) Pcacket Data CRC16 Check 指令 位 指令 说明 SOH 0x01 128字节数据包帧头 STX 0x02 1024字节数据包帧头 EOT 0x04 结束传输 ACK 0x06 正确应答 NAK 0x15 错误应答，重传数据 CAN 0x18 取消传输 CTRLZ 0x1A 数据填充 HSC 0x43 握手 例子 CRC16程序 STM32支持CRC32，不支持CRC16，需要自己写 多项式p(x) = x^16 + x^12 + x^5 + 1，借助多项式将输入的数值进行模2除法，在C语言中是进行异或运算^。 参考 havenxie/stm32-iap-uart-boot: STM32 IAP(UART模式)的BOOT部分 【手把手教程 4G通信物联网 OTA远程升级 BootLoader程序设计】GD32F103C8T6单片机【上篇章】_哔哩哔哩_bilibili 补充（7.24） Bootloader执行流程 上电或复位 当系统上电或复位时，处理器从一个固定的地址开始执行，这个地址称为 向量表（Vector Table） 的起始地址。 读取向量表地址（比如 Flash 起始地址） 默认情况下，ARM Cortex-M 处理器会从地址 0x08000000（即 Flash 起始地址）读取： 0x08000000：初始 MSP（Main Stack Pointer） 0x08000004：Reset Handler 的地址，也就是主程序的入口点 设置 MSP 处理器将 0x08000000 处的值加载到 MSP（Main Stack Pointer），为堆栈初始化。 跳转到 Reset Handler 处理器将 0x08000004 处的值作为程序计数器 PC，开始执行实际程序。 SRAM在此的意义 SRAM（Static RAM）是 MCU 的运行内存（RAM），栈、全局变量、局部变量都存放在这里。 MSP 指针一般会指向 SRAM 的顶端（例如 0x20000000），向下增长。 应用程序运行期间所有动态数据、堆栈帧等都存在于 SRAM 中。 APP程序配置 system_stm32f10x.c文件中的VECT_TAB_OFFSET，设置0x5000 配置Target DMA如何配置RX_BUFFER + 1配合IDLE实现接收不定长数据 DMA设置：传输计数为RX_BUFFER + 1 IDLE触发：当接收数据长度小于设置计数时触发 长度计算：通过剩余计数计算实际接收长度 重新配置：每次IDLE中断后重新配置DMA "},{"title":"调试BUG与一些说明","date":"2025-05-08T12:51:32.000Z","url":"/2025/05/08/%E8%B0%83%E8%AF%95BUG%E4%B8%8E%E4%B8%80%E4%BA%9B%E8%AF%B4%E6%98%8E/","tags":[["调试","/tags/%E8%B0%83%E8%AF%95/"]],"categories":[["嵌入式","/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"]],"content":"这里记录了调试过程中遇到的一些调试问题，往往一困就是几天，人麻了。 调试BUG STM32芯片被锁 有一段时间没用STM32芯片，发现ST-LINK读不到，毫无头绪。 解决办法：使用软件STM32 ST-LINK Utility，点击Connect + 按住STM32上芯片复位键才能连接，连接后将程序给清除掉，成功解决。 串口通信出现乱码 编码格式、波特率、主频都可能是问题原因； 如果输入英文和数字都出现问题，那大概率晶振问题，看一下是不是焊错了。 ESP32的新版I2C驱动不了摄像头 这个问题来自于旧I2C不支持新版摄像头驱动，一直报错，ESP IDF 5.4降低到ESP IDF 5.2即可。 更新过驱动，也实现了摄像头，但是配合其他外设也需要修改对应的旧版I2C（液晶屏触摸等），暂不操作。 一些说明 #pragma once，表示本头文件只可以包含一次，相当于 #ifndef #define #endif 为什么编码器要用short来表示16位 STM32平衡车项目中处理编码器的计数使用short； 计算机存的是补码，short字节范围：-32768~ 32767，负数会变成32768 - n 正数的原码 = 反码 = 补码 负数的反码是原码除了符号位其他位取反，补码是反码加1"},{"title":"基于ESP32S3的智能终端系统","date":"2025-02-22T04:10:16.000Z","url":"/2025/02/22/%E5%9F%BA%E4%BA%8EESP32%E7%9A%84%E6%99%BA%E8%83%BD%E7%BB%88%E7%AB%AF%E7%B3%BB%E7%BB%9F/","tags":[["项目","/tags/%E9%A1%B9%E7%9B%AE/"],["ESP32","/tags/ESP32/"],["LVGL","/tags/LVGL/"],["物联网","/tags/%E7%89%A9%E8%81%94%E7%BD%91/"]],"categories":[["项目","/categories/%E9%A1%B9%E7%9B%AE/"]],"content":" 实物 LVGL界面使用Gui Guider制作，使用LVGL 8.3；图标库来自iconfont iconfont-阿里巴巴矢量图标库 界面预览 其他功能参考立创和官方例程制作，使用ESP-IDF环境。 天气温度 和风天气作为服务端，配置相关端口号，实现WIFI获取。 首先配置WIFI **任务创建：**连接WiFi任务、获取网络时间任务、获取每日天气信息任务、获取实时天气信息任务、获取实时空气质量任务、主界面任务（从前往后依次执行） 需要创建一个lv_timer定时器，每隔1s判断更新已有数据，比如网络时间是1s更新一次，室外温度和天气图标是30min更新一次，每日温度范围和空气质量是1h更新一次。 WIFI连接任务 WIFI会有AP和STA两种状态，AP是客户，STA是类似基站，还有AP+STA；这里设置为AP模式。 创建了一个任务组，可同时通知几个任务进行更新操作。 获取网络时间任务 获取天气信息任务 获取和风天气相关URL 主要参考：第16章 桌面天气助手 | 立创开发板技术文档中心 登录 | 和风天气 和风天气图标官方链接： icon：Temperature Three Quarters Classic Solid Icon | Font Awesome 平衡计 使用QMI8658姿态传感器，通过加速度计算各个角度，并通过LVGL显示数据。 屏幕亮度更改 实质是利用PWM控制LCD的亮度bsp_display_backlight_on() 不能太亮，也不能太暗；通过设置阈值进行控制。 MP3音乐播放 使用DAC es8311实现音频输出，mp3格式，借助SPIFFS文件系统存放（在 SPI Flash里划分作为文件系统） 初始化spiffs 配置es8311 配置采样率、位宽、通道 采样率：1s采集多少个采样点 位宽：每个采样点用多少位二进制表示 MP3播放器初始化 【立创·实战派ESP32-S3】文档教程 | 立创开发板技术文档中心 摄像头 GGC0308，像素30W，用的是DVP接口 ESP32S3是一款双处理器的XTensa，可以使用xTaskCreatePinnedToCore将摄像头获取的画面和LCD显示分别放在不同的处理器进行处理，提升整体性能。 【立创·实战派ESP32-S3】文档教程 | 立创开发板技术文档中心 个人信息显示 简单的展示 partitions（分区表） Name Type SubType Offset Size Flags nvs data nvs 0x9000 24k phy_init data phy 0xf000 4k factory app factory 8M storage data spiffs 3M 常见分区说明 nvs → Non-Volatile Storage，存储键值对（比如 Wi-Fi 配网信息）。 otadata → OTA 升级信息区（存哪个固件是当前运行的）。 phy_init → PHY 校准数据。 factory → 固件（App）分区，烧录的程序在这里。 ota_0 / ota_1 → OTA 备用分区，用来放升级的固件。 spiffs / littlefs / fatfs → 文件系统分区，存配置、网页、图片资源等。 LVGL lvgl_port_lock/unlock 是 ESP-IDF 提供的封装，方便多任务安全调用 LVGL。 1. 任务 &amp; 定时 lv_timer_create(cb, period, user_data) 创建定时器，周期性执行回调（GUI 动画/状态刷新常用）。 lv_timer_del(timer) / lv_timer_reset(timer) 删除/复位定时器。 lv_tick_inc(ms) 系统 tick 增加（ESP32S3 通常用 esp_timer 每 1ms 调一次）。 lv_timer_handler() LVGL 主循环处理（通常在 GUI 任务里 while(1) 调用）。 2. 显示驱动（lv_disp_drv_t） lv_init() 初始化 LVGL 库。 lv_disp_drv_init(&amp;drv) 初始化显示驱动结构体。 lv_disp_draw_buf_init(&amp;buf, buf1, buf2, size) 初始化绘图缓冲。 lv_disp_drv_register(&amp;drv) 注册显示驱动。 lv_disp_flush_ready(drv) 刷新结束回调（DMA 传输完成后必须调用）。 ESP32S3 上一般会自己写 flush_cb，再通过 lv_disp_drv_register 绑定到 LCD（SPI/RGB）驱动。 3. 输入设备驱动（触摸屏） lv_indev_drv_init(&amp;drv) 初始化输入设备驱动结构体。 lv_indev_drv_register(&amp;drv) 注册输入设备。 lv_indev_drv_update(indev, &amp;new_drv) 更新输入设备驱动参数。 lv_indev_set_group(indev, group) 将输入设备加入某个 group（键盘/焦点管理）。 4. 对象（Widgets） 容器类 lv_obj_create(parent) → 创建通用容器 lv_obj_del(obj) → 删除对象 lv_obj_align(obj, LV_ALIGN_*, x_ofs, y_ofs) → 对齐 lv_obj_center(obj) → 居中 lv_obj_set_size(obj, w, h) lv_obj_add_style(obj, style, part) 常用组件 Label: lv_label_create, lv_label_set_text, lv_label_set_text_fmt Button: lv_btn_create, lv_obj_add_event_cb List: lv_list_create, lv_list_add_btn Textarea: lv_textarea_create, lv_textarea_get_text, lv_textarea_set_password_mode Keyboard: lv_keyboard_create, lv_keyboard_set_textarea Spinner: lv_spinner_create Msgbox: lv_msgbox_create, lv_msgbox_close Chart: lv_chart_create, lv_chart_add_series, lv_chart_set_next_value 5. 样式（Style） lv_style_init(&amp;style) lv_style_reset(&amp;style) lv_style_set_bg_color(&amp;style, lv_color_make(...)) lv_style_set_text_font(&amp;style, &amp;lv_font_montserrat_20) lv_style_set_pad_all(&amp;style, n) lv_obj_add_style(obj, &amp;style, part) 6. 动画 lv_anim_init(&amp;a) lv_anim_set_var(&amp;a, obj) lv_anim_set_exec_cb(&amp;a, cb) lv_anim_set_values(&amp;a, start, end) lv_anim_set_time(&amp;a, ms) lv_anim_start(&amp;a) ESP32-S3 用动画要注意刷新频率（避免卡顿，LCD 带宽有限）。 7. 事件 lv_obj_add_event_cb(obj, cb, LV_EVENT_CLICKED, user_data) lv_event_get_target(e) → 获取事件目标对象 lv_event_get_code(e) → 获取事件类型 lv_event_get_user_data(e) → 获取用户数据 8. 其他常见工具 lv_group_create() / lv_group_add_obj(group, obj) 焦点组管理（键盘/旋钮/遥控器）。 lv_color_make(r, g, b) 构造颜色（RGB565/888 取决于配置）。 lv_pct(n) 百分比尺寸。 其他 ESP32S3的FreeRTOS是自带的，但是STM32的FreeRTOS是移植的 项目 官方 FreeRTOS ESP32-S3 的 FreeRTOS（ESP-IDF） 来源 AWS / FreeRTOS 官方 基于 FreeRTOS，Espressif 定制 支持内核数 通常单核 支持多核（SMP） 硬件集成 不集成硬件 集成 Wi-Fi / BLE / 外设等 任务调度 单核调度器 双核调度器（支持亲和性） 功耗管理 需手动实现 支持 Tickless Idle，低功耗优化 API 接口 标准 FreeRTOS API 支持标准 + Espressif 自定义 API 文件系统/网络等 无 ESP-IDF 提供完整网络、文件系统支持 配置方式 FreeRTOSConfig.h menuconfig 菜单配置（Kconfig） "},{"title":"ESP32S3学习笔记","date":"2025-01-12T01:50:36.000Z","url":"/2025/01/12/ESP32S3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["ESP","/tags/ESP/"]],"categories":[["嵌入式","/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"]],"content":"主要学习立创ESP32S3 N16R8的基本配置以及其各部件组成 组成结构 类别 型号 参数 模组 ESP32-S3-WROOM-1-N16R8 搭载 Xtensa® 32 位 LX7 双核处理器，主频高达 240 MHz，内置SRAM 512kB，外置PSRAM 8MB，外置FLASH 16MB，2.4 GHz Wi-Fi (802.11 b/g/n) 40MHz带宽，Bluetooth 5 (LE) 和 Bluetooth Mesh，集成AI向量指令，加速神经网络计算和信号处理 显示屏 ST7789 2.0寸、IPS全视角、分辨率320*240、SPI接口 触摸屏 FT6336 电容触摸、I2C接口 姿态传感器 QMI8658 三轴加速度+三轴陀螺仪、I2C接口 音频DAC ES8311 单通道、I2C接口 音频ADC ES7210 四通道(开发板用三个通道)、I2C接口 音频功放 NS4150B 单声道D类音频放大器 麦克风 ZTS6216 配套双路麦克风、模拟输出 喇叭 DB1811AB50 1811音腔喇叭、1W USB HUB CH334F USB2.0 HUB USB转串口 CH340K 波特率最大2Mbps 电源芯片 SY8088AAC 提供双路、每路1A GH1.25接口 两路外拓传感器接口，可以给外部传感器供电5V和3.3V，可以作为GPIO、CAN、I2C、UART、PWM等接口 TF卡接口 采用1-SD模式与ESP32连接 Type-C接口 用于供电、程序下载、程序调试，以及USB数据通信 按键 一个复位按键、一个用户自定义按键 基础外设 按键Key 样例 姿态传感器（QMI8658） I2C控制，地址QMI8658_SENSOR_ADDR= 0x6A 内部集成 3 轴加速度传感器和 3 轴陀螺仪传感器，支持 SPI 和 I2C 通信 I2C的频率为100000 BSP_I2C_NUM为0 说明 PIN I2C_SCL GPIO_NUM_1 I2C_SDA GPIO_NUM_2 计算倾斜角度（加速度求角度法） 配置qmi8658 求取姿态数值 IO拓展（PAC9557） 外设拓展口，由I2C控制，地址PCA9557_SENSOR_ADDR = 0x19 音频输入（ES7210） AD0接高电平，AD1接低电平，I2C地址为0x41 ES7210 连接 MIC 负责音频输入，ES8311 只负责音频输出 ES7210 可以连接 4 个 MIC，开发板上连接了 3 个 MIC，MIC1 和 MIC2 接收人说话的声音， MIC3 连接了 ES8311 的输出，用于回声消除。 S3芯片会做回声消除，音响在播放声音的时候，可以说话打断它。 这个原理就是 ES8311 输出的信号，不仅给了喇叭，还给了 ES7210 的 MIC3 输入，ESP32 在接收到 MIC1、MIC2 和 MIC3 的声音后，可以分离出 MIC3，从而进行识别。 本部分例程 初始化I2S总线 初始化ES7120芯片 加载SD卡 录制声音 I2S的IO和寄存器配置 标准I2S和TDM_I2S模式 I2S模式 TDM_I2S模式 ES7210工作在I2S模式时，只能采集2个通道，而工作在TDM_I2S模式时，可以采集4个通道 音频输出（ES8311） 主函数包括： i2s_driver_init() 函数初始化 i2s 接口 es8311_codec_init() 函数初始化 i2c 接口并初始化 es8311 芯片 pca9557_init() 函数初始化 IO 扩展芯片 pca9557 pa_en() 函数用于控制音频功放的打开和关闭，IO1引脚 i2s_music() 函数是创建的任务函数，用于播放音乐 液晶显示（ST7789+FT6557） 使用SPI驱动，存储到SPIRAM中 液晶屏显示的开关有两个，一个是 esp_lcd_panel_disp_on_off()，一个是 bsp_display_backlight_on() 区别： esp_lcd_panel_disp_on_off() 用来控制的是液晶屏的驱动芯片 ST7789 中的寄存器，这个寄存器控制液晶屏显示与否。 bsp_display_backlight_on() 用来控制液晶屏 LED 背光，通过调节 PWM 占空比调节亮度，使用的是 LEDC 外设产生的 PWM 信号。 esp_lcd_panel_swap_xy() 函数控制 xy 坐标翻转，第 2 个参数，true 表示翻转，false 表示不翻转。 esp_lcd_panel_mirror() 函数控制 xy 方向是否镜像。第 2 个参数控制 x 方向，第 3 个参数控制 y 方向，true 表示镜像，false 表示不镜像。 实验 IO42 引脚控制液晶屏的背光，低电平亮，如果 IO42 引脚输出 PWM 信号，就可以通过调节占空比，均匀的控制液晶屏的背光亮度 亮度调节函数 摄像头（GC0308） TIP：一般 500W 像素以下的摄像头模块，使用 DVP 接口，以上的使用 MIPI 接口。MIPI 接口速度要高于 DVP 接口。 GC0308 摄像头最大分辨率 640 * 480，30W 像素，工作在 24MHz 频率下，输出 240 *320 分辨率时，可达 30 帧。 实验 PWDN 引脚控制摄像头进入待机模式和工作模式，高电平进入待机模式，低电平进入工作模式 .ledc_channel 和 .ledc_timer中，LEDC 外设用来给某个引脚产生 PWM 信号，这里可以用来产生时钟信号给摄像头的 XCLK 引脚。但是 S3 芯片用不着，因为 S3 芯片的 CAM 外设会产生 XCLK 信号。关于这一点，看 ESP32-S3 的技术参考手册可以了解到。 创建了两个任务，一个任务是摄像头获取画面的任务，一个是液晶屏显示画面的任务。其中，还创建了一个队列信号，摄像头获取到画面，发送队列信号通知 LCD 显示。ESP32S3 是双核处理器，这两个任务，一个定义在 CPU0 上运行，一个定义在 CPU1 上运行，这样可以提高运行速度。xTaskCreatePinnedToCore()函数的最后一个参数，用来定义在哪个 CPU 上运行。 esp_camera_fb_get()函数用来获取一帧摄像头图像，并把获取到的一帧信息返回 LVGL LVGL（Light and Versatile Graphics Library）是一个开源的图形用户界面库，旨在为嵌入式系统提供轻量级、可移植、灵活且易于使用的图形用户界面解决方案 配置 基础配置 Flash = 16MB 要存储MP3文件，需要设置FAT文件系统，Default block size = 4096 使用SPI，需要设置SPIRAM，应用外存，Octal（8线SPI） Mode PSRAM，80MHz clock speed 调用摄像头，设置CPU频率为240MHz，还有如下 使用LVGL，需要设置反转颜色，Color settings下的Swap the 2 bytes of…打勾 设置其他字体，Font usage可以开启 Enable Monserrat 24等 yml文件 参考 【下载中心】实战派 | 立创开发板技术文档中心 【ESP32-S3的开发】| 1.初识 ESP32-S3_esp32s3引脚图详细解释-CSDN博客 components · GSM-Weather-project/gsm-weather-esp32s3-esp-idf5.0 - 码云 - 开源中国"},{"title":"颜色、图片、文字、图标设置","date":"2025-01-10T03:10:36.000Z","url":"/2025/01/10/%E9%A2%9C%E8%89%B2%E3%80%81%E5%9B%BE%E7%89%87%E3%80%81%E6%96%87%E5%AD%97%E3%80%81%E5%9B%BE%E6%A0%87%E8%AE%BE%E7%BD%AE/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]],"categories":[["嵌入式","/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"]],"content":" 颜色、图片、文字、图标 设置颜色 Material color palette — Vuetify 设置图片 借助Image2LCD软件，按照如下图配置 将输出的数组存入.h中，加上static，在主函数调用。 Image Converter — LVGL 设置文字 阿里巴巴普惠体系列打包免费字体下载 - 字体打包免费下载尽在字体家 字体转换器 – 免费在线转换字体 Font Converter — LVGL 设置图标 Font Awesome iconfont-阿里巴巴矢量图标库 "},{"title":"FreeRTOS学习笔记","date":"2024-12-20T06:41:12.000Z","url":"/2024/12/20/FreeRTOS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["STM32","/tags/STM32/"],["Bootloader","/tags/Bootloader/"]],"categories":[["嵌入式","/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"]],"content":"主要学习韦东山FreeRTOS的操作。 FreeRTOS概述与体验 FreeRTOS主要内容 FreeRTOS/Source下的文件 作用 task.c 任务操作 list.c 列表 queue.c 提供队列操作、信号量操作 timer.c 软件定时功能 event_groups.c 通过事件组功能 数据类型 TickType_t： FreeRTOS配置了一个周期性的时钟中断：Tick Interrupt 每发生一次中断，中断次数累加，这被称为tick count tick count这个变量的类型就是TickType_t TickType_t可以是16位的，也可以是32位的 FreeRTOSConfig.h中定义configUSE_16_BIT_TICKS时，TickType_t就是uint16_t 否则TickType_t就是uint32_t BaseType_t： 这是该架构最高效的数据类型 32位架构中，它就是uint32_t 16位架构中，它就是uint16_t 8位架构中，它就是uint8_t BaseType_t通常用作简单的返回值的类型，还有逻辑值，比如pdTRUE/pdFALSE 变量名 变量名前缀 含义 c char s int16_t, short l int32_t, long x BaseType_t，结构体等 u unsigned p 指针 uc uint8_t，unsigned char pc char指针 函数名 函数名前缀 含义 vTaskPrioritySet 返回值类型：void，在task.c中定义 xQueueReceive 返回值类型：BaseType_t，在queue.c中定义 pvTimerGetTimerID 返回值类型：pointer to void，在timer.c中定义 宏名 宏的前缀 在哪个文件定义 port (比如portMAX_DELAY) portable.h或portmacro.h task (比如taskENTER_CRITICAL()) task.h pd (比如pdTRUE) projdefs.h config (比如configUSE_PREEMPTION) FreeRTOSConfig.h err (比如errQUEUE_FULL) projdefs.h 一般的宏定义 宏 值 pdTRUE 1 pdFALSE 0 pdPASS 1 pdFAIL 0 内存管理 FreeRTOS的内存管理包括静态内存管理和动态内存管理。 堆：heap，由程序员自己malloc一块空间，用完后free标记为&quot;空闲&quot; 栈：stack，函数调用时局部变量保存在栈中，当前程序环境也是保存在栈中。 五种内存管理方法 文件 优点 缺点 heap_1.c 分配简单，时间确定，没有碎片 只分配，不回收 heap_2.c 动态分配，最佳匹配 有碎片、时间不懂 heap_3.c 调用标准库函数 速度慢、时间不定 heap_4.c 相邻的空闲碎片可合并 时间不定 heap_5.c 在heap_4.c基础上支持分隔的内存块 时间不定 FreeRTOS在创建任务时，需要2个内核对象：task control block(TCB)、stack。 heap_1 只实现了pvPortMalloc，并没有实现vPortFree。 如果程序不需要删除内核对象，可以使用它 heap_2 相较于heap_1 Heap_2使用最佳匹配算法(best fit)来分配内存 它支持vPortFree Q：这里的最佳匹配是怎么操作的？ 举例，一个5 10 15内存的空间，此时需要存入一个6大小的数据，那么就存放在10里面，变成5 4 15；后续又需要存放一个4大小的数据，就变成5 0 15。 heap_3 使用标准C库里的malloc、free函数 Q： heap_3线程安全吗? C库里的malloc、free函数并非线程安全的，heap_3中先暂停FreeRTOS的调度器，再去调用这些函数，使用这种方法实现了线程安全。 heap_4 heap_4使用首次适应算法(first fit)来分配内存。它还会把相邻的空闲内存合并为一个更大的空闲内存，这有助于较少内存的碎片问题。 Q：这里的首次匹配是怎么操作的？ 举例，一个10 5 3内存的空间，此时需要存入一个6大小的数据，那么就存放在10里面，变成4 5 3；后续又需要存放一个3大小的数据，就变成1 5 3。 heap_5 相比于heap_4，Heap_5并不局限于管理一个大数组：它可以管理多块、分隔开的内存。 heap相关的函数 pvPortMalloc/vPortFree 作用：分配内存、释放内存。 如果分配内存不成功，则返回值为NULL。 xPortGetFreeHeapSize 作用：当前还有多少空闲内存，heap_3中无法使用。 xPortGetMinimumEverFreeHeapSize 作用：空闲内存容量的最小值。 注意：只有heap_4、heap_5支持此函数 任务管理 任务状态：就绪态、阻塞态、挂起态、进行态 任务创建 同时创建两个程序，同优先级下，先执行最后创建的。 多个任务可以使用同一个函数，怎么体现它们的差别？ 栈不同 创建任务时可以传入不同的参数 任务删除 Q：怎么删除任务？ 自杀：vTaskDelete(NULL) 被杀：别的任务执行vTaskDelete(pvTaskCode)，pvTaskCode是自己的句柄 杀人：执行vTaskDelete(pvTaskCode)，pvTaskCode是别的任务的句柄 任务优先级与Tick 高优先级的任务先运行，可选择0 ~ (configMAX_PRIORITIES – 1) FreeRTOS会确保最高优先级的、可运行的任务立马执行 对于相同优先级的可执行任务，轮流执行 对于相同优先级的，通过Tick（滴答）中断实现，但它并不精确。 可以使用uxTaskPriorityGet来获得任务的优先级： 使用vTaskPrioritySet 来设置任务的优先级： 任务状态 Delay函数 vTaskDelay：至少等待指定个数的Tick Interrupt才能变为就绪状态 vTaskDelayUntil：等待到指定的绝对时刻，才能变为就绪态。 空闲任务及其钩子函数 空闲任务(Idle任务)的作用：释放被删除的任务的内存 在使用vTaskStartScheduler() 函数来创建、启动调度器时，这个函数内部会创建空闲任务： 空闲任务优先级为0：它不能阻碍用户任务运行 空闲任务要么处于就绪态，要么处于运行态，永远不会阻塞 如果使用vTaskDelete() 来删除任务，那么你就要确保空闲任务有机会执行，否则就无法释放被删除任务的内存。 可以添加一个空闲任务的钩子函数(Idle Task Hook Functions)，空闲任务的循环每执行一次，就会调用一次钩子函数。 钩子函数作用 执行一些低优先级的、后台的、需要连续执行的函数 测量系统的空闲时间：空闲任务能被执行就意味着所有的高优先级任务都停止了，所以测量空闲任务占据的时间，就可以算出处理器占用率。 让系统进入省电模式：空闲任务能被执行就意味着没有重要的事情要做，当然可以进入省电模式了。 钩子函数限制 不能导致空闲任务进入阻塞状态、暂停状态 如果你会使用vTaskDelete() 来删除任务，那么钩子函数要非常高效地执行。如果空闲任务移植卡在钩子函数里的话，它就无法释放内存。 如何使用钩子函数 FreeRTOS\\Source\\tasks.c中设置configUSE_IDLE_HOOK = 1，实现vApplicationIdleHook函数。 调度算法 配置项 A B C D E configUSE_PREEMPTION 1 1 1 1 0 configUSE_TIME_SLICING 1 1 0 0 x configIDLE_SHOULD_YIELD 1 0 1 0 x 说明 常用 很少用 很少用 很少用 几乎不用 A：可抢占+时间片轮转+空闲任务让步 B：可抢占+时间片轮转+空闲任务不让步 C：可抢占+非时间片轮转+空闲任务让步 D：可抢占+非时间片轮转+空闲任务不让步 E：合作调度 同步互斥与通信 能实现同步、互斥的内核方法有：任务通知(task notification)、队列(queue)、事件组(event group)、信号量(semaphoe)、互斥量(mutex) 队列： 里面可以放任意数据，可以放多个数据 任务、ISR都可以放入数据；任务、ISR都可以从中读出数据 事件组： 一个事件用一bit表示，1表示事件发生了，0表示事件没发生 可以用来表示事件、事件的组合发生了，不能传递数据 有广播效果：事件或事件的组合发生了，等待它的多个任务都会被唤醒 信号量： 核心是&quot;计数值&quot; 任务、ISR释放信号量时让计数值加1 任务、ISR获得信号量时，让计数值减1 任务通知： 核心是任务的TCB里的数值 会被覆盖 发通知给谁？必须指定接收任务 只能由接收任务本身获取该通知 互斥量： 数值只有0或1 谁获得互斥量，就必须由谁释放同一个互斥量 队列 特性 队列可以包含若干个数据：队列中有若干项，这被称为&quot;长度&quot;(length) 创建队列时就要指定长度、数据大小（大小固定） 数据的操作采用先进先出的方法(FIFO，First In First Out)：写数据时放到尾部，读数据时从头部读 也可以强制写队列头部：覆盖头部数据 队列传输数据两种方法： 拷贝：把数据、把变量的值复制进队列 引用：把数据、把变量的地址复制进队列 有多个任务在等待同一个队列的数据。当队列中有数据时，哪个任务会进入就绪态？ 优先级最高的任务 如果大家的优先级相同，那等待时间最久的任务会进入就绪态 队列函数 创建队列 动态分配内存：xQueueCreate，队列的内存在函数内部动态分配 参数 说明 uxQueueLength 队列长度，最多能存放多少个数据(item) uxItemSize 每个数据(item)的大小：以字节为单位 返回值 非0：成功，返回句柄，以后使用句柄来操作队列 NULL：失败，因为内存不足 静态分配内存：xQueueCreateStatic，队列的内存要事先分配好 参数 说明 uxQueueLength 队列长度，最多能存放多少个数据(item) uxItemSize 每个数据(item)的大小：以字节为单位 pucQueueStorageBuffer 如果uxItemSize非0，pucQueueStorageBuffer必须指向一个uint8_t数组， 此数组大小至少为&quot;uxQueueLength * uxItemSize&quot; pxQueueBuffer 必须执行一个StaticQueue_t结构体，用来保存队列的数据结构 返回值 非0：成功，返回句柄，以后使用句柄来操作队列 NULL：失败，因为pxQueueBuffer为NULL 复位 使用过程中可以调用xQueueReset()把队列恢复为初始状态 删除 删除队列的函数为vQueueDelete()，只能删除使用动态方法创建的队列，它会释放内存 写队列 参数 说明 xQueue 队列句柄，要写哪个队列 pvItemToQueue 数据指针，这个数据的值会被复制进队列， 复制多大的数据？在创建队列时已经指定了数据大小 xTicksToWait 如果队列满则无法写入新数据，可以让任务进入阻塞状态， xTicksToWait表示阻塞的最大时间(Tick Count)。 如果被设为0，无法写入数据时函数会立刻返回； 如果被设为portMAX_DELAY，则会一直阻塞直到有空间可写 返回值 pdPASS：数据成功写入了队列 errQUEUE_FULL：写入失败，因为队列满了。 读队列 参数 说明 xQueue 队列句柄，要读哪个队列 pvBuffer bufer指针，队列的数据会被复制到这个buffer 复制多大的数据？在创建队列时已经指定了数据大小 xTicksToWait 果队列空则无法读出数据，可以让任务进入阻塞状态， xTicksToWait表示阻塞的最大时间(Tick Count)。 如果被设为0，无法读出数据时函数会立刻返回； 如果被设为portMAX_DELAY，则会一直阻塞直到有数据可写 返回值 pdPASS：从队列读出数据入 errQUEUE_EMPTY：读取失败，因为队列空了。 查询 可以查询队列中有多少个数据、有多少空余空间 覆盖/偷看 当队列长度为1时，可以使用xQueueOverwrite()或xQueueOverwriteFromISR()来覆盖数据。 如果想让队列中的数据供多方读取，也就是说读取时不要移除数据，那么可以使用&quot;窥视&quot;，也就是xQueuePeek()或xQueuePeekFromISR()。 信息量 特性 信号：起通知作用 量：还可以用来表示资源的数量 当&quot;量&quot;只有0、1两个取值时，它就是&quot;二进制信号量&quot;(Binary Semaphores) 当&quot;量&quot;没有限制时，它就是&quot;计数型信号量&quot;(Counting Semaphores) 支持的动作：&quot;give&quot;给出资源，计数值加1；&quot;take&quot;获得资源，计数值减1 函数 创建 创建二进制信号量： 创建计数型信号量： 删除 动态创建的信号量，不再需要它们时，可以删除它们以回收内存。 give/take 互斥值 特性 FreeRTOS的互斥锁，并没有在代码上实现谁上锁，就只能由谁开锁，只是约定。 互斥量初始值为1 任务A想访问临界资源，先获得并占有互斥量，然后开始访问 任务B也想访问临界资源，也要先获得互斥量：被别人占有了，于是阻塞 任务A使用完毕，释放互斥量；任务B被唤醒、得到并占有互斥量，然后开始访问临界资源 任务B使用完毕，释放互斥量 函数 要想使用互斥量，需要在配置文件FreeRTOSConfig.h中定义： 创建 其他函数 互斥量不能在ISR中使用，ISR需要快速运行，不能阻塞太久。 优先级反转 假设任务A、B都想使用串口，A优先级比B低： 任务A获得了串口的互斥量 任务B也想使用串口，它将会阻塞、等待A释放互斥量 高优先级的任务，被低优先级的任务延迟，这被称为&quot;优先级反转&quot;(priority inversion) 互斥量可以通过&quot;优先级继承&quot;，临时提高有锁且低优先级的程序，可以很大程度**解决&quot;优先级反转&quot;**的问题 递归锁 递归锁实现了：谁上锁就由谁解锁 死锁 假设有2个互斥量M1、M2，2个任务A、B： A获得了互斥量M1 B获得了互斥量M2 A还要获得互斥量M2才能运行，结果A阻塞 B还要获得互斥量M1才能运行，结果B阻塞 A、B都阻塞，再无法释放它们持有的互斥量 死锁发生！ 解决这样问题可以使用递归锁 任务A获得递归锁M后，它还可以多次去获得这个锁 &quot;take&quot;了N次，要&quot;give&quot;N次，这个锁才会被释放 函数 事件组 概念 事件组的每一位表示一个事件 每一位事件的含义由程序员决定，比如：Bit0表示用来串口是否就绪，Bit1表示按键是否被按下 这些位，值为1表示事件发生了，值为0表示事件没发生 一个或多个任务、ISR都可以去写这些位；一个或多个任务、ISR都可以去读这些位 可以等待某一位、某些位中的任意一个，也可以等待多位 事件组用一个整数来表示，高8位留给内核使用，只能用其他的位来表示事件 如果configUSE_16_BIT_TICKS是1，那么这个整数就是16位的，低8位用来表示事件 如果configUSE_16_BIT_TICKS是0，那么这个整数就是32位的，低24位用来表示事件 configUSE_16_BIT_TICKS是用来表示Tick Count的，怎么会影响事件组？这只是基于效率来考虑 如果configUSE_16_BIT_TICKS是1，就表示该处理器使用16位更高效，所以事件组也使用16位 如果configUSE_16_BIT_TICKS是0，就表示该处理器使用32位更高效，所以事件组也使用32位 函数 创建 删除 设置事件 在任务中使用xEventGroupSetBits() 在ISR中使用xEventGroupSetBitsFromISR() xEventGroupSetBitsFromISR函数不是直接去设置事件组，而是给一个FreeRTOS后台任务(daemon task)发送队列数据，由这个任务来设置事件组。 等待事件 使用xEventGroupWaitBits来等待事件，可以等待某一位、某些位中的任意一个，也可以等待多位；等到期望的事件后，还可以清除某些位。 参数 说明 xEventGroup 等待哪个事件组？ uxBitsToWaitFor 等待哪些位？哪些位要被测试？ xWaitForAllBits 怎么测试？是&quot;AND&quot;还是&quot;OR&quot;？ pdTRUE: 等待的位，全部为1; pdFALSE: 等待的位，某一个为1即可 xClearOnExit 函数提出前是否要清除事件？ pdTRUE: 清除uxBitsToWaitFor指定的位 pdFALSE: 不清除 xTicksToWait 如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用pdMS_TO_TICKS()把ms转换为Tick Count 返回值 返回的是事件值， 如果期待的事件发生了，返回的是&quot;非阻塞条件成立&quot;时的事件值； 如果是超时退出，返回的是超时时刻的事件值。 同步点 使用xEventGroupSync()函数可以同步多个任务： 参数 说明 xEventGroup 哪个事件组 uxBitsToSet 要设置哪些事件，已经完成了哪些事件？ 比如0x05(二进制为0101)会导致事件组的bit0,bit2被设置为1 uxBitsToWaitFor 等待那个位、哪些位？ 比如0x15(二级制10101)，表示要等待bit0,bit2,bit4都为1 xTicksToWait 如果期待的事件未发生，阻塞多久。 可以设置为0：判断后即刻返回； 可设置为portMAX_DELAY：一定等到成功才返回； 可以设置为期望的Tick Count，一般用pdMS_TO_TICKS()把ms转换为Tick Count 返回值 返回的是事件值， 如果期待的事件发生了，返回的是&quot;非阻塞条件成立&quot;时的事件值； 如果是超时退出，返回的是超时时刻的事件值。 任务通知 特性 优势 效率更高：使用任务通知来发送事件、数据给某个任务时，效率更高。比队列、信号量、事件组都有大的优势。 更节省内存：使用其他方法时都要先创建对应的结构体，使用任务通知时无需额外创建结构体。 限制 不能发送数据给ISR： ISR并没有任务结构体，所以无法使用任务通知的功能给ISR发送数据。但是ISR可以使用任务通知的功能，发数据给任务。 数据只能给该任务独享： 使用队列、信号量、事件组时，数据保存在这些结构体中，其他任务、ISR都可以访问这些数据。使用任务通知时，数据存放入目标任务中，只有它可以访问这些数据。 在日常工作中，这个限制影响不大。因为很多场合是从多个数据源把数据发给某个任务，而不是把一个数据源的数据发给多个任务。 无法缓冲数据 ：使用队列时，假设队列深度为N，那么它可以保持N个数据。 使用任务通知时，任务结构体中只有一个任务通知值，只能保持一个数据。 无法广播给多个任务 ：使用事件组可以同时给多个任务发送事件。 使用任务通知，只能发个一个任务。 如果发送受阻，发送方无法进入阻塞状态等待： 假设队列已经满了，使用xQueueSendToBack()给队列发送数据时，任务可以进入阻塞状态等待发送完成。 使用任务通知时，即使对方无法接收数据，发送方也无法阻塞等待，只能即刻返回错误。 通知状态和通知值 每个人物都有一个结构体：TCB，里面存在2个成员： 一个是uint8_t类型，用来表示通知状态 一个是uint32_t类型，用来表示通知值 通知状态有3种取值： taskNOT_WAITING_NOTIFICATION：任务没有在等待通知 taskWAITING_NOTIFICATION：任务在等待通知 taskNOTIFICATION_RECEIVED：任务接收到了通知，也被称为pending(有数据了，待处理) 任务通知的使用 使用任务通知，可以实现轻量级的队列(长度为1)、邮箱(覆盖的队列)、计数型信号量、二进制信号量、事件组。 函数 eNotifyAction参数说明： eNotifyAction取值 说明 eNoAction 仅仅是更新通知状态为&quot;pending&quot;，未使用ulValue。 这个选项相当于轻量级的、更高效的二进制信号量。 eSetBits 通知值 = 原来的通知值 | ulValue，按位或。 相当于轻量级的、更高效的事件组。 eIncrement 通知值 = 原来的通知值 + 1，未使用ulValue。 相当于轻量级的、更高效的二进制信号量、计数型信号量。 相当于xTaskNotifyGive()函数。 eSetValueWithoutOverwrite 不覆盖。 如果通知状态为&quot;pending&quot;(表示有数据未读)， 则此次调用xTaskNotify不做任何事，返回pdFAIL。 如果通知状态不是&quot;pending&quot;(表示没有新数据)， 则：通知值 = ulValue。 eSetValueWithOverwrite 覆盖。 无论如何，不管通知状态是否为&quot;pendng&quot;， 通知值 = ulValue。 软件定时器 特性 跟闹钟类似，只响一次/每隔多少时间就自动操作。 两种状态 运行(Running、Active)：运行态的定时器，当指定时间到达之后，它的回调函数会被调用 冬眠(Dormant)：冬眠态的定时器还可以通过句柄来访问它，但是它不再运行，它的回调函数不会被调用 软件定时器的上下文 守护任务 FreeRTOS中有一个Tick中断，软件定时器基于Tick来运行，但不在Tick中断中执行定时器函数，而是在RTOS Damemon Task中执行，即守护任务。 守护任务的优先级：configTIMER_TASK_PRIORITY 定时器命令队列的长度：configTIMER_QUEUE_LENGTH 回调函数 如下是定时器的回调函数原型： 定时器的回调函数是在守护任务中被调用的，守护任务不是专为某个定时器服务的，它还要处理其他定时器。 因此回调任务不能影响其他人： 回调函数要尽快实行，不能进入阻塞状态 不要调用会导致阻塞的API函数，比如vTaskDelay() 可以调用xQueueReceive()之类的函数，但是超时时间要设为0：即刻返回，不可阻塞 函数 创建 回调函数的类型是： 删除 启动/停止 启动定时器就是设置它的状态为运行态(Running、Active)。 停止定时器就是设置它的状态为冬眠(Dormant)，让它不能运行。 创建定时器时，设置了它的周期(period)。xTimerStart()函数是用来启动定时器。假设调用xTimerStart()的时刻是tX，定时器的周期是n，那么在tX+n时刻定时器的回调函数被调用。 如果定时器已经被启动，但是它的函数尚未被执行，再次执行xTimerStart()函数相当于执行xTimerReset()，重新设定它的启动时间。 复位 从定时器的状态转换图可以知道，使用xTimerReset()函数可以让定时器的状态从冬眠态转换为运行态，相当于使用xTimerStart()函数。 如果定时器已经处于运行态，使用xTimerReset()函数就相当于重新确定超时时间。 修改周期 从定时器的状态转换图可以知道，使用xTimerChangePeriod()函数，处理能修改它的周期外，还可以让定时器的状态从冬眠态转换为运行态。 修改定时器的周期时，会使用新的周期重新计算它的超时时间。 定时器ID 可以用来标记定时器，表示自己是什么定时器 可以用来保存参数，给回调函数使用 它的初始值在创建定时器时由xTimerCreate()这类函数传入。 更新ID：使用vTimerSetTimerID()函数 查询ID：查询pvTimerGetTimerID()函数 一般使用配置 要使用定时器，需要做些准备工作： 中断管理 特性 中断流程，ISR要尽量快 保存现场：Task1被打断，需要先保存Task1的运行环境，比如各类寄存器的值 分辨中断、调用处理函数(这个函数就被称为ISR，interrupt service routine) 恢复现场：继续运行Task1，或者运行其他优先级更高的任务 ISR的优先级高于任务：即使是优先级最低的中断，它的优先级也高于任务。任务只有在没有中断的情况下，才能执行。 Q：为什么要引入两套API函数？ 很多API函数会导致任务计入阻塞状态： ISR调用API函数时，ISR不是&quot;任务&quot;，ISR不能进入阻塞状态 所以，在任务中、在ISR中，这些函数的功能是有差别的 两套API函数列表 类型 在任务中 在ISR中 队列(queue) xQueueSendToBack xQueueSendToBackFromISR xQueueSendToFront xQueueSendToFrontFromISR xQueueReceive xQueueReceiveFromISR xQueueOverwrite xQueueOverwriteFromISR xQueuePeek xQueuePeekFromISR 信号量(semaphore) xSemaphoreGive xSemaphoreGiveFromISR xSemaphoreTake xSemaphoreTakeFromISR 事件组(event group) xEventGroupSetBits xEventGroupSetBitsFromISR xEventGroupGetBits xEventGroupGetBitsFromISR 任务通知(task notification) xTaskNotifyGive vTaskNotifyGiveFromISR xTaskNotify xTaskNotifyFromISR 软件定时器(software timer) xTimerStart xTimerStartFromISR xTimerStop xTimerStopFromISR xTimerReset xTimerResetFromISR xTimerChangePeriod xTimerChangePeriodFromISR 怎么切换任务 FreeRTOS的ISR函数中，使用两个宏进行任务切换： 中断与任务间的通信 队列、信号量、互斥量、事件组、任务通知等等方法，都可使用。 要注意的是，在ISR中使用的函数要有&quot;FromISR&quot;后缀。 资源管理 要独占式地访问临界资源，有3种方法： 公平竞争：比如使用互斥量等 谁要跟我抢，我就灭掉谁： 中断要跟我抢？我屏蔽中断 其他任务要跟我抢？我禁止调度器，不运行任务切换 屏蔽中断 任务中使用：taskENTER_CRITICA()/taskEXIT_CRITICAL() ISR中使用：taskENTER_CRITICAL_FROM_ISR()/taskEXIT_CRITICAL_FROM_ISR() 任务中屏蔽中断 在taskENTER_CRITICA()和taskEXIT_CRITICAL()之间： 低优先级的中断被屏蔽了：优先级低于等于configMAX_SYSCALL_INTERRUPT_PRIORITY 高优先级的中断可以产生：优先级高于configMAX_SYSCALL_INTERRUPT_PRIORITY 但是，这些中断ISR里，不允许使用FreeRTOS的API函数 任务调度依赖于中断、依赖于API函数，所以：这两段代码之间，不会有任务调度产生 在ISR中屏蔽中断 在taskENTER_CRITICA_FROM_ISR()和taskEXIT_CRITICAL_FROM_ISR()之间： 低优先级的中断被屏蔽了：优先级低于、等于configMAX_SYSCALL_INTERRUPT_PRIORITY 高优先级的中断可以产生：优先级高于configMAX_SYSCALL_INTERRUPT_PRIORITY 但是，这些中断ISR里，不允许使用FreeRTOS的API函数 任务调度依赖于中断、依赖于API函数，所以：这两段代码之间，不会有任务调度产生 暂停调度器 如果有别的任务来跟你竞争临界资源，可以把中断关掉：这当然可以禁止别的任务运行，但是这代价太大了。它会影响到中断的处理。 示例操作，下面可以递归使用。 调试方法 调试 打印 断言：configASSERT Trace Hook函数(回调函数) 打印 断言 Trace trace宏 描述 traceTASK_INCREMENT_TICK(xTickCount) 当tick计数自增之前此宏函数被调用。参数xTickCount当前的Tick值，它还没有增加。 traceTASK_SWITCHED_OUT() vTaskSwitchContext中，把当前任务切换出去之前调用此宏函数。 traceTASK_SWITCHED_IN() vTaskSwitchContext中，新的任务已经被切换进来了，就调用此函数。 traceBLOCKING_ON_QUEUE_RECEIVE(pxQueue) 当正在执行的当前任务因为试图去读取一个空的队列、信号或者互斥量而进入阻塞状态时，此函数会被立即调用。参数pxQueue保存的是试图读取的目标队列、信号或者互斥量的句柄，传递给此宏函数。 traceBLOCKING_ON_QUEUE_SEND(pxQueue) 当正在执行的当前任务因为试图往一个已经写满的队列或者信号或者互斥量而进入了阻塞状态时，此函数会被立即调用。参数pxQueue保存的是试图写入的目标队列、信号或者互斥量的句柄，传递给此宏函数。 traceQUEUE_SEND(pxQueue) 当一个队列或者信号发送成功时，此宏函数会在内核函数xQueueSend(),xQueueSendToFront(),xQueueSendToBack(),以及所有的信号give函数中被调用，参数pxQueue是要发送的目标队列或信号的句柄，传递给此宏函数。 traceQUEUE_SEND_FAILED(pxQueue) 当一个队列或者信号发送失败时，此宏函数会在内核函数xQueueSend(),xQueueSendToFront(),xQueueSendToBack(),以及所有的信号give函数中被调用，参数pxQueue是要发送的目标队列或信号的句柄，传递给此宏函数。 traceQUEUE_RECEIVE(pxQueue) 当读取一个队列或者接收信号成功时，此宏函数会在内核函数xQueueReceive()以及所有的信号take函数中被调用，参数pxQueue是要接收的目标队列或信号的句柄，传递给此宏函数。 traceQUEUE_RECEIVE_FAILED(pxQueue) 当读取一个队列或者接收信号失败时，此宏函数会在内核函数xQueueReceive()以及所有的信号take函数中被调用，参数pxQueue是要接收的目标队列或信号的句柄，传递给此宏函数。 traceQUEUE_SEND_FROM_ISR(pxQueue) 当在中断中发送一个队列成功时，此函数会在xQueueSendFromISR()中被调用。参数pxQueue是要发送的目标队列的句柄。 traceQUEUE_SEND_FROM_ISR_FAILED(pxQueue) 当在中断中发送一个队列失败时，此函数会在xQueueSendFromISR()中被调用。参数pxQueue是要发送的目标队列的句柄。 traceQUEUE_RECEIVE_FROM_ISR(pxQueue) 当在中断中读取一个队列成功时，此函数会在xQueueReceiveFromISR()中被调用。参数pxQueue是要发送的目标队列的句柄。 traceQUEUE_RECEIVE_FROM_ISR_FAILED(pxQueue) 当在中断中读取一个队列失败时，此函数会在xQueueReceiveFromISR()中被调用。参数pxQueue是要发送的目标队列的句柄。 traceTASK_DELAY_UNTIL() 当一个任务因为调用了vTaskDelayUntil()进入了阻塞状态的前一刻此宏函数会在vTaskDelayUntil()中被立即调用。 traceTASK_DELAY() 当一个任务因为调用了vTaskDelay()进入了阻塞状态的前一刻此宏函数会在vTaskDelay中被立即调用。 Malloc Hook函数 编程时，一般的逻辑错误都容易解决。难以处理的是内存越界、栈溢出等。 内存越界经常发生在堆的使用过程总：堆，就是使用malloc得到的内存。 并没有很好的方法检测内存越界，但是可以提供一些回调函数： 栈溢出Hook函数 在切换任务(vTaskSwitchContext)时调用taskCHECK_FOR_STACK_OVERFLOW来检测栈是否溢出，如果溢出会调用： 怎么判断栈溢出？ 方法1： 当前任务被切换出去之前，它的整个运行现场都被保存在栈里，这时很可能就是它对栈的使用到达了峰值。 这方法很高效，但是并不精确 比如：任务在运行过程中调用了函数A大量地使用了栈，调用完函数A后才被调度。 方法2： 创建任务时，它的栈被填入固定的值，比如：0xa5 检测栈里最后16字节的数据，如果不是0xa5的话表示栈即将、或者已经被用完了 没有方法1快速，但是也足够快 能捕获几乎所有的栈溢出 为什么是几乎所有？可能有些函数使用栈时，非常凑巧地把栈设置为0xa5：几乎不可能 优化 栈使用情况 在创建任务时分配了栈，可以填入固定的数值比如0xa5，以后可以使用以下函数查看&quot;栈的高水位&quot;，也就是还有多少空余的栈空间： 原理：从栈底往栈顶逐个字节地判断，它们的值持续是0xa5就表示它是空闲的。 使用运行时间统计 涉及的宏定义头 函数说明 uxTaskGetSystemState：获得任务的统计信息 参数 描述 pxTaskStatusArray 指向一个TaskStatus_t结构体数组，用来保存任务的统计信息。 有多少个任务？可以用uxTaskGetNumberOfTasks()来获得。 uxArraySize 数组大小、数组项个数，必须大于或等于uxTaskGetNumberOfTasks() pulTotalRunTime 用来保存当前总的运行时间(更快的定时器)，可以传入NULL 返回值 传入的pxTaskStatusArray数组，被设置了几个数组项。 注意：如果传入的uxArraySize小于uxTaskGetNumberOfTasks()，返回值就是0 vTaskList ：获得任务的统计信息，形式为可读的字符串。注意，pcWriteBuffer必须足够大。 vTaskGetRunTimeStats：获得任务的运行信息，形式为可读的字符串。注意，pcWriteBuffer必须足够大。 来源 第一章 FreeRTOS概述与体验 | 百问网 百问网《FreeRTOS入门与工程实践-基于STM32F103》教程-基于DShanMCU-103(STM32F103) | 百问网"},{"title":"基于STM32F103的智能平衡车","date":"2024-10-22T03:30:30.000Z","url":"/2024/10/22/%E5%9F%BA%E4%BA%8ESTM32%E7%9A%84%E6%99%BA%E8%83%BD%E5%B9%B3%E8%A1%A1%E8%BD%A6/","tags":[["STM32","/tags/STM32/"],["项目","/tags/%E9%A1%B9%E7%9B%AE/"],["PID","/tags/PID/"]],"categories":[["项目","/categories/%E9%A1%B9%E7%9B%AE/"]],"content":"主要实现基于STM32F103C8T6的HAL库编程PID平衡车项目。 实物 硬件部分 Layout布局 STM32 CubeMX配置 使用外部高速时钟8MHz，通过PLL倍频到72MHz RCC----&gt;HSE、LSE = Crystal/Ceramic Resonator（晶振）----&gt;HCLK = 72MHz OLED 屏的大小为0.96寸，像素点为128*64。 4PIN分别为GND、VCC(3.3V/5V)、SCL(IIC的时钟信号)、SDA(IIC的数据总线)。 名称 IO HAL配置 I2C1_SDA PB9 I2C1_SCL,OD模式 I2C1_SCL PB8 I2C1_SDA,OD模式 IIC 硬件IIC：上拉输入，开漏输出。(直接用STM32的真实外设) 软件IIC：上拉输入，推挽/开漏输出。（GPIO实现时序） IIC支持一主多从，同步，半双工，每个从机都有其设备地址。 起始信号：SCL高电平，SDA从高电平跳到低电平 停止信号：SCL高电平，SDA从低电平跳到高电平 ACK信号：SCL高电平，SDA为低（ACK），SDA为高（NACK） 发送一个Byte： 读取一个Byte： 取模软件（PCtoLCD） 设置：“宋体”， 16 * 16，阴码，列行式，逆向，再修改前缀。 MPU6050 MPU6050传感器可以同时检测出三轴加速度、三轴角速度以及温度数据，内部集成DMP（Digital Motion Processor数字运动处理器）模块，可以实现滤波、融合处理。 绕IMU的Z轴旋转：偏航角yaw 绕IMU的Y轴旋转：俯仰角pitch 绕IMU的X轴旋转：横滚角roll 通过IIC通信 名称 IO HAL配置 SDA PB3 GPIO_OUTPUT SCL PB4 GPIO_OUTPUT INT PB5 GPIO_EXIT5 TIP:MPU6050内部有上拉电阻。 MPU6050模块如果在最开始没有平稳放置，自检测后会进入return语句，导致初始化失效；注释掉其自检后的return，可临时解决问题 超声波 HC-SR04 超声波测距模块可提供2cm-400cm的非接触式距离感测功能，精度可达到3mm，模块包括超声波发射器、接收器和控制电路。 工作原理 名称 IO HAL配置 TRIG（输入触发，测距） PA3 GPIO_OUTPUT ECHO（传回信号、计算时间差） PA2 GPIO_EXTI2(外部中断2)，TIM3计数 TIP：为什么上升沿和下降沿都中断（上升时开始计时，下降时结束计时）。 Internal_Clock=HCLKPSC+1 Internal\\_Clock=\\frac{HCLK}{PSC + 1} Internal_Clock=PSC+1HCLK​ NVIC----&gt;EXTI line2 interrupt = ENABLE TIM3----&gt;PSC = 71，1MHz = 1us 使用的自动重载器ARR是16位，因此65535us=0.065535s，乘上340m/s / 2可得最远距离超过4m。 电机驱动 TB6612电机 IN1 IN2 直流电机的状态 0 0 制动 0 1 正转 1 0 反转 1 1 制动 PWM 全称Pulse Width Modulation(脉宽调制)；实质是在一个方波中，高电平的占比。 名称 IO HAL配置 PWMA PA11 TIM1_CH4，Pulse = 7200 AIN2 PB12 GPIO_OUTPUT AIN1 PB13 GPIO_OUTPUT BIN1 PB14 GPIO_OUTPUT BIN2 PB15 GPIO_OUTPUT PWMB PA8 TIM1_CH1，Pulse = 7200 PWM的频率f=HCLK(PSC+1)(ARR+1)占空比Duty=PulseARR+1f=5KHz，HCLK=72MHz，则PSC=1,ARR=7199 \\\\ PWM的频率f = \\frac{HCLK}{(PSC + 1)(ARR + 1)}\\\\ \\\\ 占空比Duty=\\frac{Pulse}{ARR + 1}\\\\ \\\\ f=5KHz，HCLK=72MHz，则PSC=1,ARR=7199 \\\\ \\\\ PWM的频率f=(PSC+1)(ARR+1)HCLK​占空比Duty=ARR+1Pulse​f=5KHz，HCLK=72MHz，则PSC=1,ARR=7199 实现函数 编码器 速度通过脉冲波的方式测量，旋转一圈11个脉冲；两个霍尔传感器A相、B相，可以判断旋转方向。A相领先B相，即顺时针 名称 IO HAL配置 编码器1 PA0、PA1 TIM2—Encoder Mode TI1 and TI2 编码器2 PB6、PB7 TIM4—Encoder Mode TI1 and TI2 Encoder Mode TI1只计算A相上升沿 Encoder Mode TI2只计算B相上升沿 Encoder Mode TI1 and TI2上升沿就计算，计数精度会更加准确 TIP：编码器输出的脉冲计数本身是无符号的，此时正转时数值递增，反转时数值递减。 蓝牙 使用JDY-31蓝牙模块（从机），通过蓝牙转串口通信。 名称 IO HAL配置 RXD PB10 USART3_TX TXD PB11 USART3_RX USART3设置MODE = Asynchronous(异步)，波特率为9600Bits/s，8位，无校验位，停止位1位 USART3 global interrupt = ENABLE PID 原理 本项目使用串级PID，速度环PI+直立环PD。 θ为当前小车的倾角roll+机械中值θ′为倾角微分，即角速度gyro_x假如速度环目标角度Med为θ1，作为参数输入到直立环，则直立环的输出a将直接作用于电机，有如下关系式。直立环输出a=kp∗(θ−θ1)+kd∗θ′e(k)是速度环中目标速度与当前速度的偏差∑e(k)为偏差的积分项。速度环输出θ1=kp1∗e(k)+ki1∗∑e(k)因此a=kp∗θ+kd∗θ′−kp∗[kp1∗e(k)+ki1∗∑e(k)] \\theta为当前小车的倾角roll+机械中值 \\\\ \\theta^{&#x27;}为倾角微分，即角速度gyro\\_x \\\\ 假如速度环目标角度Med为\\theta_1，作为参数输入到直立环，\\\\ 则直立环的输出a将直接作用于电机，有如下关系式。\\\\ 直立环输出 a= kp * (\\theta - \\theta_1) + kd *\\theta^{&#x27;} \\\\ \\\\ e(k)是速度环中目标速度与当前速度的偏差 \\\\ \\sum{e(k)}为偏差的积分项。\\\\ 速度环输出\\theta_1 = kp_1 * e(k) + ki_1 * \\sum{e(k)}\\\\ \\\\ 因此a= kp * \\theta + kd *\\theta^{&#x27;} - kp * [kp_1 * e(k) + ki_1 * \\sum{e(k)}] \\\\ θ为当前小车的倾角roll+机械中值θ′为倾角微分，即角速度gyro_x假如速度环目标角度Med为θ1​，作为参数输入到直立环，则直立环的输出a将直接作用于电机，有如下关系式。直立环输出a=kp∗(θ−θ1​)+kd∗θ′e(k)是速度环中目标速度与当前速度的偏差∑e(k)为偏差的积分项。速度环输出θ1​=kp1​∗e(k)+ki1​∗∑e(k)因此a=kp∗θ+kd∗θ′−kp∗[kp1​∗e(k)+ki1​∗∑e(k)] 调整P、I、D的效果 比例P需要看什么时候跌倒，主要依靠倾斜角度。 微分D需要看什么时候振荡，若KD过大，则会振荡地严重。其效果就是阻尼，越大越慢。 积分I需要看什么情况下平衡地快，其主要用于消除稳态误差，提高控制精度。 调整过程 1、先确定机械中值，通过它来中和计算出的theta，这个需要自己手动测量。 2、调参P、I、D 确定极性：设置kp为正，向前倾斜时，平衡车轮子速度加快，则极性正确。 直立环PD 直立环直接调用公式。（输入期望角度、真实角度和角速度） 当然还需要看下我们希望平衡车在什么角度下能够返回，以此保持平衡，KP计算(7200 / 30)，这里的30是角度；通过将KP置0后，得到此时的gyro_x（数值为2000左右），再进行KD计算（7200/2000） 速度环PI （输入期望速度、左编码器、右编码器） 1、计算偏差值：误差值 = （左+右）- 期望速度 2、低通滤波：误差A = (1-a)×偏差值 + a×上一次的偏差值，再更新上一次的偏差值 3、积分：Encoder_S += 误差A （STM32是离散的数字信号，求积分就是求和） 4、限幅Encoder_S 5、速度环套用公式 KP通过公式换算，KI一般为KP/200； 转向环PD （用于转向操作，输入角速度、角度值） 蓝牙控制 通过蓝牙APP发送0x01（上）、0x05（左）、0x03（右）、0x07（下）等数据分别控制方向。 跌倒保护 通过MPU6050，监听roll值，若它低于/高于设定的界限，则将PWM设为0。 物体跟随 仅实现直线跟随，方案是借助超声波传回的距离，设置在10-20mm时可以跟随，若超过，则小车保持平衡不动。 TIP1:TIM1-TIM4用完了，如何10ms调用一次呢？答：MPU6050中的INT引脚，修改其采样率为100HZ即可 TIP2:MPU6050会进行自检，若陀螺仪不在水平状态最初状态不为平衡，则不通过，导致其计算结果一直为0，注释掉 其他 PID各种算法 1、位置式PID（本方式实际应用） 优点：静态误差小，溢出的影响小。 缺点：计算量很大，累积误差相对大，在系统出现错误的情况下，容易使系统失控，积分饱和。 使用：一般需要结合输出限幅和积分限幅使用。 2、增量式PID 优点：溢出的影响小，在系统出现错误的情况下,影响相对较小（因为只与过去的三次误差有关）,运算量也相对较小。 缺点：有静态误差（因为没有累积误差）。 3、积分分离式PID 积分分离式PID主要是针对位置式PID的积分，引入判断误差大小条件，是否使用积分项。 4、变速积分PID 积分分离式PID 积分的的权重是1或者0，而变积分PID积分的权重会动态变化。取决于偏差，偏差越大，积分越慢。 5、不完全微分PID 微分通过低通滤波。 6、微分先行 微分的作用是预测未来，能够预知变化，做出调整。其实就是先操作微分。 7、死区 输出了量，但是不执行任何动作，也就是输出的量不起作用。 8、梯形积分 积分有余差，消除不了，为了减少余差，提高运算的精度，便有了梯形积分PID。"},{"title":"STM32学习笔记","date":"2024-06-12T06:50:36.000Z","url":"/2024/06/12/STM32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["STM32","/tags/STM32/"]],"categories":[["嵌入式","/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"]],"content":"主要学习STM32C8T6的基本配置以及各部件操作。 Q：哈希体系和冯洛伊曼体系区别？ 前者是指令集和数据存储在不同存储器，后者是将两者存储在同一个存储器 计算机五大组成部分：控制器、运算器、存储器、输入设备、输出设备 32位处理器，一个指针4字节；64位处理器，一个指针8字节 STM32F103C8T6基本配置 STM32是小端存储，低地址的数据放在低字节上 堆从低地址向上增长，栈从高地址向下增长 内容 STM32F103C8T6最小系统版组成：MCU、时钟电路、复位电路、外部接口电路、电源电路，启动电路。 内核：Cortex-M3，32位处理器内核，最大寻址位2^32=4GB字节； Flash：64K字节； SRAM：20K字节； 2个ADC、4个定时器、2个IIC、2个SPI、3个USART、1个CAN Q：Cotex-M3寄存器组的用法? R0~R12为通用寄存器；R13是主堆栈指针（MSP）和进程堆栈（PSP）；R14是链接寄存器（LR），R15是程序计数器（PC） R0—R3用于传参和表达式计算； R4—R11用于保存局部变量； R12是临时寄存器； R13是堆栈指针，别名：SP； MSP（Main Stack Pointer）:主模式下使用 PSP（Process Stack Pointer）：操作系统/线程切换使用 R14是链接寄存器，用于保存函数返回地址，别名：LR； R15是程序计数器，用于跳转到下一个执行的命令，别名：PC； Q：STM32F1与F4的区别？ 内核 ：F1是M3，F4是M4 主频：F1最大主频是72MHz，F4最大主频是168MHz 浮点：F1无浮点计算，F4有 功能：F4外设比F1功能更强大 STM32的五个时钟源 HSI是高速内部时钟，RC振荡器，频率8MHz，精度不高 HSE是高速外部时钟，可接石英/陶瓷谐振器，频率4~16MHz，常用作主系统时钟源 LSI是低速内部时钟，RC振荡器，频率40KHz，通过低功耗时钟 LSE是低速外部时钟，石英晶体，频率32.768KHz PLL是锁相环倍频输出，时钟源可以为HSI / 2、HSE或HSE / 2，倍频范围是2~16倍，最大72MHz 时钟树：系统时钟 SYSCLK → AHB（HCLK）→ APB1/PCLK1、APB2/PCLK2 Q：设置系统时钟的基本流程？ 开启外部高速时钟HSE 设置Flash的等待周期 设置APB1、APB2、AHB分频系数（RCC_CFGR寄存器） 设置PLL的时钟来源和倍频系数 使能PLL 将系统时钟切换到PLL STM32启动过程 通过Boot引脚决定启动方式（Flash、系统内存、SRAM） 加载中断向量表（从起始地址读取，比如0x0800 0000） 初始化栈指针（加载__initial_sp，这是向量表的第0项，0x0800 0000） 指向复位程序（执行Reset_Handler，这是向量表的第1项，0x0800 0004） 在Reset_Handler中 复制数据段（data）到RAM 清空BSS段 调用SystemInit设置系统时钟 调用 __main ----&gt; main() 设置异常中断 HardFault_Handler GPIO 四种输入：上拉输入、下拉输入、浮空输入、模拟输入 四种输出：通用推挽、复用推挽、通用开漏、复用开漏 APB1总线控制DAC、USB、I2C、SPI、CAN、串口2345、普通TIM APB2总线控制ADC、USART1、GPIO、TIM1（高级定时器）、AFIO（复用功能） Q：开漏与推挽的区别？ 推挽可以正常输出高低电平，开漏只能输出低电平，高电平呈现高阻态，并且需要上拉电阻。 Q：通用和复用的区别？ 通用是单纯做输入或输出，复用是用作外设功能引脚 蜂鸣器 内容 有源蜂鸣器：内部自带振荡电路，将正负极接上直流电压即可发声，频率固定。 无源蜂鸣器：内部不带振荡电路，需要控制器提供振荡脉冲发生，频率不固定。 中断 内容 EXIT(Extern Interrupt)：外部中断控制器，监听GPIO引脚的电平变化 NVIC(Nested Vector Interrupt Control)：嵌套向量中断控制器，负责中断响应，优先级管理 本质：程序运行时，EXIT监听指定GPIO电平，一旦发生改变，CPU会暂停当前任务并保存现场，向NVIC发出中断请求，去处理中断程序；当中断程序处理完成后，自行恢复现场，继续执行。 GPIO —&gt; EXTI映射使用AFIO 触发方式：上升沿/下降沿/双边沿 Q：STM32支持多少个外部中断？ 19个外部中断，但只有7个中断服务函数。 Q：中断和异常？ 中断通常由外部硬件设备产生，如IO中断，时钟中断等；异常通常由CPU内部产生，如数组越界，除零操作等。 TIP：中断的优先级数值越小，优先级越高，比如抢占优先级和响应优先级。 TIMER 16位计数器、预分频器、自动重装寄存器的时基单元，在72MHz时钟可以实现最大59.65s的定时。 基础定时器：仅支持计数 通用/高级定时器：支持向上计数、向下计数、中央对齐 定时器计数频率：CK_CNT=HCLKPSC+1 定时器计数频率：CK\\_CNT = \\frac{HCLK}{PSC + 1} 定时器计数频率：CK_CNT=PSC+1HCLK​ HCLK是定时器输入时钟（一般是APB时钟），PSC是预分频器数值，RCC是自动重装寄存器（PWM的最大占空比）。 定时器溢出周期：T=(PSC+1)(ARR+1)fhclk 定时器溢出周期：T = \\frac{(PSC+1)(ARR+1)}{f_{hclk}} 定时器溢出周期：T=fhclk​(PSC+1)(ARR+1)​ Q：如何设置一个20ms定时器？ HCLK = 72MHz； 设置预分频系数PSC = 7199，计算CK_CNT = 10KHz = 0.1ms； ARR计数199次（200 - 1）。 Q：如果HCLK=72MHz，PSC=999，ARR=7199，那么是多少s？ T = (999 + 1)(7199 + 1) / 72000000 = 0.1s Q：如何开启定时器？ 开启RCC时钟 配置时基单元的时钟源 配置预分频系数和自动重装载值 配置中断控制和NVIC中断优先级 使能定时器 ADC Analog - Digital Converter：模拟 - 数字转换器 12位逐次逼近型ADC，转换时间约1us 输入电压：0 ~ 3.3V，转换范围：0 ~ 4095 ADC转换的步骤：采样 —&gt; 保持 —&gt;量化 —&gt; 编码 Q：STM32 ADC的总转换时间如何计算 T = 采样时间 + 12.5个ADC周期(12个周期量化，0.5周期位采样保持转换的准备时间) 例 1：F1 常见配置 HCLK = 72 MHz，PCLK2 = 72 MHz，ADC_PRE = 6 ⇒ f_ADC=12 MHz 采样时间选 13.5 cycles 1 个通道： T_ch = (13.5 + 12.5) / 12 MHz = 26 / 12000000 ≈ 2.17 us 若一次转换 3 个通道且都用 13.5 cycles： T_total = 3 × 2.17 us ≈ 6.5 μs STM32的Flash Flash写入只能将1写成0，不能将0写成1，因此要写新数据，必须先擦除（擦除是将0恢复成1） 结构层级：页 &lt; 扇区 &lt; 块 &lt; 芯片 每块 每扇页 每页 16扇页 16页 256 Byte 常用的Flash擦写规则 最小擦除：扇区 可选择擦除：扇区、块、全片 最大写入单位：页（不能跨页写入） 最小写入单位：1 字节 未写入时默认FLASH全为1（0xFF） 写操作只能把1变成0，若需恢复0变1，则必须先擦除 Q：NOR Flash和NAND Flash区别？ NOR Flash支持随机读取，NAND Flash块读取 NOR读得比NAND快 NOR写和擦慢，容量小，价格贵 存储器对比 SRAM：静态随机存储，不需要定时刷新充电，存储速度快，容量小，断电丢失 DRAM：动态随机存储，需要定时刷新充电，价格比SRAM便宜，但访问速度慢，耗电量大 E2PROM：带电可擦除可编辑只读存储器，断电后仍能保存信息，可以单字节擦除 FLASH（ROM）：闪存，存取速度慢，容量大，掉电不丢失，按扇区/块擦除 DMA Direct Memory Access：直接存储器访问控制器 用途：允许外设或存储器和存储器之间高速数据传输，无需CPU干预，节省CPU资源 使用小寄巧：DMA可以获取当前剩余数据量，根据设置的接收buffer大小减去当前剩余数据量，得到当前接收数据大小 STM32F103C8T6 DMA资源： DMA1 Q：DMA配置三要素 源地址、目标地址和传输长度（传输方向，数据宽度，地址递增模式，优先级、循环模式） Q：DMA的传输模式有哪些？ DMA_Mode_Normal，正常缓存模式，完成指定大小传输后停止 DMA_Mode_Circle， 循环模式，传输完成后自动重新加载，连续传输 通信协议总览 名称 双工 时钟 电平 设备 引脚 UART 全双工 异步 单端 点对点 TX、RX I2C 半双工 同步 单端 多设备 SCL、SDA SPI 全双工 同步 单端 多设备 CS、SCLK、MOSI、MISO CAN 半双工 异步 差分 多设备 CAN_H、CAN_L USB 半双工 异步 差分 点对点 DP、DM UART 串口通信 低位先行：若发送信息0X0F，则传输数据位是1111 0000，最终接收信息0X0F 过程：起始一个低电平信号表示开始发送数据，接着是8个数据位，然后是校验位（奇/偶/NONE），最后是高电平表示停止位（0.5/1/1.5/2） Q：开始位1Bit、数据位8Bit、停止位1Bit，波特率9600，则发送32个数据，需要多久？ 波特率9600，即1s发送9600Bit，大概需要((1+8+1)*32)/9600=0.033s=33ms Q：串口通信如何配置？ 串口时钟使能，GPIO时钟使能 复位串口外设 配置GPIO TX为复用推挽，RX为浮空输入 初始化串口参数（波特率，数据位，校验位，收发模式） 开启中断并初始化NVIC 使能串口外设 编写串口函数 Q：描述下RS232和RS485的区别？ TTL（全双工）：0V表示0，+3.3V~+5V表示1 RS232（全双工）：+3V ~ +15V表示0，-3V ~ -15V表示1，（TTL通过RS232芯片） RS485（半双工）：两线电压差-2V ~ -6V表示0，+2V ~ +6V表示1（TTL通过RS485芯片） I2C Inter IC BUS（同步、半双工），支持一主多从和多主多从（MSB高位先行） 两根通信线：SCL（Serial Clock）、SDA（Serial Data），上拉电阻一般4.7K~10K STM32支持7/10位地址模式 Q：I2C总线在传输过程中有哪些类型信号？ 开始信号：SCL高电平，SDA由高到低，开始发送数据 结束信号：SCL高电平，SDA由低到高，结束发送数据 应答信号：SCL高电平，发送8Bit数据，接收端向发送端发低电平，表示成功接收（在接收前需要释放SDA） TIP：一旦 开始信号产生后，数据传输必须在 SCL 为低时开始。 TIP：软件模拟I2C时，SDA电平切换只出现在SCL低电平阶段，不要搞混 Q：I2C的软硬件模式怎么配置？ 硬件模式：复用开漏输出+上拉电阻；内部有固定I2C结构；有通信速率设置，400Kbps 软件模式：通用开漏输出+上拉电阻；通过GPIO模拟I2C信号；没有通信速率配置，需要自己写一个delay，100Kbps TIP：有些人偷懒用 GPIO_MODE_OUTPUT_PP（推挽）来模拟，那必须手动释放SDA变高 Q：I2C的仲裁机制？ “线与”操作（&amp;&amp;），即低电平优先，谁先发送低电平，谁就对总线占有控制权。 Q：I2C的从机设备地址ID、写地址、读地址？ 特定地址写 当前地址读 SPI Serial Peripheral Interface：串行外设接口（MSB先行），速度比I2C快很多 四根通信线： SCLK（Serial Clock） MOSI（Master Output Slave Input） MISO（Master Input Slave Output） CS MISO输入为上拉或浮空输入，SCLK、MOSI输出配置为复用推挽输出、CS配置为推挽输出。 起止条件：CS高电平切换到低电平 终止条件：CS低电平切换到高电平 发送信息：CS一直为低电平 Q：四种工作模式 时钟极性CPOL（上升沿/下降沿）；时钟相位CPHA（第一个边沿/第二个边沿） CPOL = 0 ------&gt;上升沿 CPOL = 1 ------&gt; 下降沿 CPHA = 0 ------&gt;第一个边沿 CPHA = 1 ------&gt; 第二个边沿 Q：如何确定使用哪个模式 看从机空闲状态是低电平还是高电平，来确认CPOL；再从从机芯片时序图里确认何时采取数据。 下图解释：在没有进入Cycle时，通过SPICLK是高低电平来判断CPOL；CPHA通过正中间的那个边沿判断。 Q：陀螺仪可以用SPI通信吗，有什么好处？ 有的既可以使用SPI，也可以使用I2C，当然SPI的传输速度会更快 MPU6050只能I2C，MPU9250/QMI8658可以I2C和SPI 看门狗 看门狗监控程序运行状态，当程序因为设计漏洞、硬件故障导致出现卡死等问题时，看门狗可以及时复位程序；本质是定时器，在指定范围内，程序没有执行喂狗（重置计数器），看门狗硬件会自动产生复位信号。 独立看门狗（IWDG）：独立于主系统时钟，时间精度低，开启就无法关闭。 窗口看门狗（WWDG）：能产生系统复位信号和提前唤醒中断。 I2S I2S（Inter-IC Sound）是一种广泛应用于数字音频传输的串行接口标准 应用场景如下 I2S RX方向：麦克风在机械振动下将声音信号转变为电压信号，电压信号经过放大等处理，给到ADC采样，将模拟信号转化为数字信号；音频在ADC与DSP之间的传输协议就是使用的I2S协议。 I2S TX方向：数字信号经过编码、存储、压缩等技术后，发送给解码器DAC（DSP、专用解码器），将数字信号还原为模拟信号，最后给到喇叭完成声音/音频的播放。音频在DAC与DSP之间的传输就是使用I2S协议。 基本信号线 时钟线（Continues Serial Clock，SCK）：SCK提供传输时的时钟信号，确定了数据传输的速度和时序，也称之为BCLK；SCK的频率 = 2 x 采样频率 x 位宽 左/右声道线（Left-Right Clock，LRCK）：LRCK线指示了当前传输的是左声道的音频数据还是右声道的音频数据。又称帧同步信号。LRCK的频率 = 采样频率 数据线（Serial Data，SD）：SD线用于传输实际的音频数据。数据的位宽可以根据具体应用而变化，通常为16位或32位。TX方向为：Serial Data Out（SDOUT）；RX方向为：Serial Data In（SDIN）。 常见参数说明 采样率：1s中采样总次数 位宽（Word Length）：位宽指定每个采样数据的位数，通常为16位或32位。较大的位宽可以提供更高的分辨率和动态范围。 时钟极性（Clock Polarity）：时钟极性确定了数据位传输的时钟沿。根据具体的I2S设备和系统设置，可以定义在时钟上升沿或下降沿开始数据传输 帧同步极性（Frame Sync Polarity）：帧同步极性确定了帧同步信号的有效电平。帧同步信号指示音频数据的帧起始和结束位置。 传输格式（Data Format）：传输格式定义了音频数据的编码方式，传输格式还可以指定数据的顺序，如左声道先传输还是右声道先传输 主从模式 I2S工作模式可以是主模式（Master Mode）或从模式（Slave Mode）。两者唯一的区别是：Master Mode提供时钟信号（SCK）和帧同步信号（LRCK） 数据传输模式 I2S接口标准中，存在三种数据传输模式，分别是：**飞利浦标准模式（I2S mode），左对齐（Left Justified）和右对齐（Right Justified）**三种传输模式。 飞利浦标准模式 （1）LRCK（左右声道选择信号）：LRCK信号用于指示当前数据帧是左声道数据还是右声道数据。飞利浦格式中，当LRCK为低时，表示当前传输的数据是左声道数据；当LRCK为高时，表示当前传输的数据为右声道数据 （2）SCK（位时钟）：数据传输的时钟信号。在SCK下降沿发送数据，在SCK上升沿采样数据 （3）Data Delay：发送的有效数据相对于LRCK的跳变沿（从0到1或从1到0）延迟一个时钟周期 （4）数据发送从MSB开始；数据MSB与LRCK delay 1个SCK的边沿对齐 左对齐模式 （1）在左对齐格式中，LRCK为高时，表示当前传输的数据为左声道数据；当LRCK为低时，表示当前传输的数据为右声道数据 （2）在SCK下降沿发送数据，在SCK上升沿接收数据 （3）无data delay：发送的有效数据相当于LRCK跳变沿（从0到1或从1到0）不延迟 （4）数据发送从MSB开始；数据MSB与LRCK跳变沿对齐 右对齐模式 （1）右对齐格式中，LRCK为高时，表示当前传输的数据为右声道数据；当LRCK为低时，表示当前传输的数据为左声道数据 （2）在SCK下降沿发送数据，在SCK上升沿接收数据 （3）无Data delay：发送的有效数据相当于LRCK跳变沿（从0到1或从1到0）不延迟 （4）数据发送从MSB开始；数据LSB与LRCK跳变沿对齐 数据位宽与位深 位宽计算过程： 位宽：每个通道在一帧里占用的比特数 f_LRCK，左右声道时钟，就是采样率f_s fLRCK=fs(每通道的采样率) f_{LRCK}=f_{s}(每通道的采样率) fLRCK​=fs​(每通道的采样率) f_SCK，串行时钟，传输每一位数据的时钟频率 fSCK=每帧比特数×采样率 f_{SCK}=每帧比特数 \\times 采样率 fSCK​=每帧比特数×采样率 N，通道数，一帧里面包含的音频通道数；比如I2S-&gt;N=2；TDM_I2S-&gt;N=4,8… 位宽（槽宽）：在一帧中，每个通道占用的bit数 每帧比特数=通道数N×位宽(单位bit)fSCK=N×fLRCK×位宽位宽=fSCKN×fLRCK 每帧比特数=通道数N \\times 位宽(单位bit) \\\\ f_{SCK} = N \\times f_{LRCK} \\times 位宽 \\\\ 位宽 = \\frac{f_{SCK}}{N \\times f_{LRCK}} 每帧比特数=通道数N×位宽(单位bit)fSCK​=N×fLRCK​×位宽位宽=N×fLRCK​fSCK​​ 位深：表示音频数据量化后的精度（位宽 &gt;= 位深） 下面是32位位宽，20位位深，实际位宽就是一个通道能采到多少数据，位深是实际有效的数据 CAN（以下的不建议看，去看另外一篇吧） 内容 CAN总线（Controller Area Network Bus）控制器局域网总线。 一个节点包括3个部分：微处理MCU、CAN控制器、CAN收发器。（CAN_H、CAN_L为双绞线） 开环网络两端必须有2.2KΩ的终端电阻；闭环网络两端必须有120Ω的终端电阻（抗干扰作用）； （信号到终端被电阻吸收，避免反射回干扰下一次信号，所以一般都是放两端） CAN BUS（右边那一块）上的总线电平称为隐形电平和显性电平。 IOS11898标准 名称 性质 逻辑 CAN_H CAN_L 两条线上的电压差 Recessive 隐性 逻辑1 2.5V 2.5V 0 Dominant 显性 逻辑0 3.5V 1.5V 2V 多个节点一起开始发送，会涉及到总线仲裁。 CAN帧的种类 序号 名称 帧用途 1 数据帧 用于发送单元向接收单元传送数据的帧。 2 遥控帧 用于接收单元向具有相同 ID 的发送单元请求数据的帧。 3 错误帧 用于当检测出错误时向其它单元通知错误的帧。 （硬件自动完成） 4 过载帧 当一个节点正忙于处理接收的信息,可以通知其它节点暂缓发送新报文。（硬件自动完成） 5 帧间隔 用于将数据帧及远程帧与前面的帧分离开来的帧（硬件自动完成） 每个节点都可以自己发送帧（帧是CAN协议规定发送或接收的单位） 序号 名称 描述 1 帧起始 表示帧的开始，产生一个bit的显性电平 2 仲裁段 表示帧的优先级， 由标识符（ID）和传送帧类型(RTR)组成 3 控制段 表示数据的字节数，由6个bit构成 4 数据段 数据的具体内容，可发送0～8 个字节的数据 5 CRC段 用于校验传输是否正确 6 ACK段 表示确认是否正常接收（0为应答） 7 帧结束 表示此帧结束 仲裁段：可以根据配置好的设置，自动判断要不要接收报文，该方案也叫作过滤，判断依据是每个报文的ID。 标准格式的标识符长度为11位，拓展格式是29位 RTR位，它来表明是数据帧（0）还是远程帧（1） IDE表明此帧是标准帧（0）还是拓展帧（1）。 控制段：控制段表示数据段的字节数。 保留位（r0、r1），必须全部以显性电平发送，但接收方可以接收显性、隐性的各种组合。 数据长度码（Data Link Control），数据字节必须为0-8字节，但接收方对数据字节数=9~15的情况并不视为错误。 数据段：0-8个字节数据，CAN控制器有对应的寄存器。 位填充机制：当检测到五个连续相同的位信号，实际发送会自动插入一个补码，位填充区域为SOF到CRC结束之间 仲裁方案 在总线空闲时，最先开始发送的节点获得发送权，一旦开始发送，不会被其他节点抢占。 多个节点同时开始发送时，各发送节点从仲裁段的第一位开始进行仲裁。连续输出显性电平最多的节点可继续发送。(从左到右，Dominant ：显性优先) 具有相同ID的数据帧和远程帧在总线上竞争时，仲裁段的最后一位（RTR）为显性位的数据帧具有优先权可继续发送。 标准格式ID与具有相同ID的远程帧或者扩展格式的数据帧在总线上竞争时，标准格式的RTR 位为显性位的具有优先权可继续发送。 CAN过滤器配置 过滤模式：列表模式和掩码模式 列表模式：列出ID名称，判断ID是否一致来判断是否接受或者丢弃，受到列表容量大小限制。 掩码模式：确定ID特定位的值来判断是否接受或丢弃，不受列表容量大小限制。 配置过滤器，有三个重要的寄存器：CAN_FSIR、CAN_FxR1、CAN_FxR2 CAN总线错误分类 CubeMX配置 1、配置波特率 位数据段：同步段----传播段（补偿CAN网络的物理延迟）----相位缓冲段1----相位缓冲段2（补偿相位误差） 可能会有早到的，也可能会有晚到的，通过上面的四段可以进行拉长缩小来操作。 CAN波特率=TQ∗(TBS1+TBS2+SJY)=APB总线频率∗(TBS1+TBS2+SJY)分频系数 CAN波特率=TQ*(TBS1 + TBS2 + SJY) \\\\ \\\\ = \\frac{APB总线频率 * (TBS1 + TBS2 + SJY)}{分频系数} CAN波特率=TQ∗(TBS1+TBS2+SJY)=分频系数APB总线频率∗(TBS1+TBS2+SJY)​ 2、打开CAN的接受中断，两个接收邮箱、三个发送邮箱。 参考 Stm32最小系统板的构成详解-CSDN博客 嵌入式面试知识点总结 – STM32篇_stm32 112+16+64-CSDN博客 嵌入式知识点（STM32、uart、spi、iic等总线）_i2c dma hardfault-CSDN博客 flash基础知识_flash擦除最小单位-CSDN博客 STM32: ADC采样频率及相应时间的确定_adc采样频率计算公式-CSDN博客 基础通信协议之 IIC (I2C) 详细讲解_i2c通信的详细讲解-CSDN博客 SPI原理超详细讲解—值得一看-CSDN博客 (11 封私信) 【I2S】数字音频接口—I2S总线协议基本概念 - 知乎 一文读懂CAN总线协议 (超详细配34张高清图)_can总线协议详解-CSDN博客"},{"title":"如何做一个这样的网站","date":"2024-01-15T04:30:30.000Z","url":"/2024/01/15/%E5%A6%82%E4%BD%95%E5%81%9A%E4%B8%80%E4%B8%AA%E8%BF%99%E6%A0%B7%E7%9A%84%E7%BD%91%E7%AB%99/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"],["hexo","/tags/hexo/"]],"categories":[["网页","/categories/%E7%BD%91%E9%A1%B5/"]],"content":" 这个人太懒了，根本就妹写正文呀！还是来看看可爱猫猫吧！ 学习参考 搭建1：hexo史上最全搭建教程-CSDN博客 搭建2：使用Hexo在GitHub Pages上搭建部署免费的个人博客网站（下：Hexo部署）——最详细全面解读教程（没有之一） - 简书 hexo主题：Themes | Hexo 处理公式问题：Hexo折腾系列（六）数学公式渲染优化 - 江风引雨の小po站 图床工具参考1：Home - SM.MS | Dashboard 图床工具参考2：【Typora】github-与PicGO搭建图床-CSDN博客 添加音乐：3-hexo 添加音乐插件 | 叶落阁 表格未居中问题暂未解决，CSS美化？ 关于上传hexo d出现err: Error: Spawn failed报错问题 打开博客目录内的_config.yml配置文件，将自己的github的https仓库地址修改为自己github的SSH地址 怎么更新BLOG 2025.7.24留，好久没用，把更新文章的命令忘完，记录一下 "},{"title":"Markdown基础用法","date":"2023-04-12T03:40:30.000Z","url":"/2023/04/12/Markdown%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","tags":[["学习笔记","/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"]],"categories":[["Markdown","/categories/Markdown/"]],"content":" Markdown基础用法 官网网址： 可以下载排字模板和编辑主题。 使用Typora，通过Ctrl+/即可进入Markdown源代码编辑模式。 标题 #+空格+标题名称-----------一级标题 ##+空格+标题名称---------二级标题 ###+空格+标题名称--------三级标题 ####+空格+标题名称------四级标题 #####+空格+标题名称------五级标题 ######+空格+标题名称-----六级标题 最大支持六级标题 字体 对于标准的markdown文本是不支持居中对齐的。不过markdown同时兼容HTML，可以通过HTML语法格式书写来让文本居中对齐。 引用 ‘&gt;’+加空格+文字 分割线 1.三个*然后回车 2.三个-（减号）回车 插入图片 ①本地的图片：英文的！+[图片名称]+（路径） ②网络图：英文的！+[图片名称]+（网络图片地址） 比如： 链接 [点击跳转到+名称]（网站、文件等地址） 比如：我的博客 列表 ①有序列表；序号（1，①）+英文的句号（.）+输入得内容，然后回车自动补出下一个序号 ②无序列表；减号（-）+空格+输入内容 回车自动补出下一个 表格 右击创建表格 代码 Tab键上面的点（·）三个 + 代码类型（java c++ c#等）然后回车 数学公式 ∑i=0ni2=(n2+n)(2n+1)6 \\sum_{i=0}^n i^2 = \\frac{(n^2+n)(2n+1)}{6} i=0∑n​i2=6(n2+n)(2n+1)​ LaTeX公式格式 Markdown快捷键 撤销：Ctrl/Command + Z 重做：Ctrl/Command + Y 加粗：Ctrl/Command + B 斜体：Ctrl/Command + I 标题：Ctrl/Command + Shift + H 无序列表：Ctrl/Command + Shift + U 有序列表：Ctrl/Command + Shift + O 检查列表：Ctrl/Command + Shift + C 插入代码：Ctrl/Command + Shift + K 插入链接：Ctrl/Command + Shift + L 插入图片：Ctrl/Command + Shift + G 查找：Ctrl/Command + F mand + Shift + L 插入图片：Ctrl/Command + Shift + G 查找：Ctrl/Command + F 替换：Ctrl/Command + G"},{"title":"使用新域名后不加载主题","date":"2022-05-15T03:30:30.000Z","url":"/2022/05/15/%E4%BD%BF%E7%94%A8%E6%96%B0%E5%9F%9F%E5%90%8D%E5%90%8E%E4%B8%8D%E5%8A%A0%E8%BD%BD%E4%B8%BB%E9%A2%98/","tags":[["学习","/tags/%E5%AD%A6%E4%B9%A0/"],["hexo","/tags/hexo/"]],"categories":[["网页","/categories/%E7%BD%91%E9%A1%B5/"]],"content":" 心路历程 看了一圈CSDN，基本上都是抄抄改改，只有几个还有点负责心，但依然没有解决我的问题，差点就放弃了，不过好在通过试错给试出来了。 解决方法 使用了新域名后，发现网页的CSS和JS都没用了，但本地静态可以正常运行。这个时候需要修改个人博客底下的_config.yml文件，先找到这个地方： 将url改为githubname.github.io，不要出现下一层仓库名。 说明：CSDN上别人的解决方法不适用，是因为我们这个没有单独给出root，切记切记。"},{"title":"蓝桥杯第十二届心得","date":"2022-04-28T10:51:32.000Z","url":"/2022/04/28/%E8%93%9D%E6%A1%A5%E7%AC%AC%E5%8D%81%E4%BA%8C%E5%B1%8A%E5%8D%95%E7%89%87%E6%9C%BA%E5%BF%83%E5%BE%97/","tags":[["比赛","/tags/%E6%AF%94%E8%B5%9B/"]],"categories":[["嵌入式","/categories/%E5%B5%8C%E5%85%A5%E5%BC%8F/"]],"content":" 感悟 今年的蓝桥杯单片机难吗，不是很难，但注重细心。一分付出，一分收获。今年我有幸参加了第十二届的比赛，但因为自己操作不当，优化代码的过程中删了定时器，没在主函数删了调用函数，导致已经完成的大厦轰然倒塌。自己也很难受，但没办法，希望看到文章的你们不要犯这种低级问题。 Emmmm…，不过后来拿了省一，挺意外的。 新手上路 基础部分的内容，推荐大家去看小蜜蜂老师的视频，讲的很好，网址: . 学习思路 以下是我的学习思路 首先：先学会LED、蜂鸣器、继电器、按键、数码管、数码管位选、串口等基本操作。 其次：ds1302，ds18b20，eeprom(24C02)，PCF8591等。 然后：PWM呼吸灯，DA(因为我刚开始一直没找到)、超声波。 最关键的是一定要做省赛题！实操很重要！ 赛题链接： . 提取码：1234 一些需要注意的点！！ LED 首先要说的是LED灯，比如第10届省赛题目中，如果单独点亮LED，会出现原先没有定义的灯跟着一起亮，我的解决方法如下 延迟delay 本来不想单独拿出来讲的，实在是初学者这里出问题的太多了。 按键消抖 有时候题目会让你只加1，但你按了按键会出现加的好多，这里推荐一种解决方法 矩阵按键 我参考的B站一位UP主，写的很好，这里用的是reg52 DS13B20 关于ds13b20读取温度，onewire里面的延迟都要增大10-12倍。特别注意的就是，蜜蜂老师那的temp是16位的，LSB、MSB是8位的，还有就是老师那的delay(700)是unsigned int的而不是unsigned char，要特别注意一下。两位小数的读法我建议大家去找找相关内容看看，以免考到。 IIC IIC这一块除了DA输出，其他没啥可说的，DA输出参考代码如下(只需要这样然后主函数调用就行，接着你去拿万用表测J3的D/A与GND两个位置就可以得到差不多的数值)： 还有一个点就是应答和非应答。 PWM 有些小伙伴可能学了很久都没搞懂PWM是怎么搞的，我举个例子。 首先我们要的是小灯缓慢亮0.5s，缓慢灭0.5s，先定义一个100us的定时器，先经过count走了10次后，time++了，五次后也就是count加了50次(换算也就是50ms)，然后led灯会变一次pwm_duty，也就是小灯的亮度，总共要变10次，也就是0.5s，达到效果。 IO和MM模式 省赛我还没看到要求用MM模式的，大多数都是要求IO模式，最好都学一下，MM模式比IO模式多用一个absacc.h的头文件。 结尾 希望看到这篇文章的你，不会和我刚考完一样，感觉自己的付出和回报不成正比，自己的心态很受打击。当我知道没删那个的时候，我当时人直接懵了，手机也摔地上碎屏了，自己付出了很多，和老师与陪自己一起走过来经常交流的赛友们学到了很多，但最后因为一个很小的问题导致这样，自己真的完全接受不了。不过人生总有得有失吧，唉，大家国赛加油！ 最后记得根据题目意思交压缩包，而不是只交了一份hex文件！！！ 最后，青山不改，碧水长流"}]